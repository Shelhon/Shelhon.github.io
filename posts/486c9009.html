<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">
  








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数据库,学习," />










<meta name="description" content="基础篇内容 一、绪论二、关系数据库三、关系数据库标准语言">
<meta name="keywords" content="数据库,学习">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库学习基础篇①">
<meta property="og:url" content="https://www.shelhon.cn/posts/486c9009.html">
<meta property="og:site_name" content="无问西东">
<meta property="og:description" content="基础篇内容 一、绪论二、关系数据库三、关系数据库标准语言">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/1.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/2.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/3.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/4.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/实体及其属性图.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/实体及其联系图.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/实体-联系图.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/基本层次联系.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/5.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/6.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/7.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/8.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/9.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/10.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/11.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/12.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/13.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/14.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/15.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/16.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/17.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/18.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/19.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/20.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/21.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/22.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/23.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/24.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/25.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/26.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/27.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/28.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/29.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/30.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/31.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/32.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/33.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/34.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/35.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/36.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/37.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/38.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/39.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/40.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/41.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/42.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/43.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/44.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/45.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/46.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/47.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/48.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/49.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/50.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/51.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/52.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/53.png">
<meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/54.png">
<meta property="og:updated_time" content="2018-11-06T04:32:04.942Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据库学习基础篇①">
<meta name="twitter:description" content="基础篇内容 一、绪论二、关系数据库三、关系数据库标准语言">
<meta name="twitter:image" content="https://www.shelhon.cn/posts/486c9009/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.shelhon.cn/posts/486c9009.html"/>





  <title>数据库学习基础篇① | 无问西东</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3275656b1c327868bf311aa7c5fdabd2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	
	<a href="https://github.com/Shelhon/Shelhon.github.io" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">无问西东</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">糊涂脸水聪明枕</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.shelhon.cn/posts/486c9009.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qsx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无问西东">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">数据库学习基础篇①</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T11:36:43+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

    
    
        
            <span class="post-updated">
            &nbsp; | &nbsp; 更新于
            <time itemprop="dateUpdated" datetime="2018-11-06T12:32:04+08:00" content="2018-11-06">
                2018-11-06
            </time>
            </span>
        
		  
		 
		 
          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  29,437
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  109
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong><center>基础篇内容</center></strong></p>
<p>一、绪论<br>二、关系数据库<br>三、关系数据库标准语言</p>
<hr>
<a id="more"></a>
<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h2><h3 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h3><ol>
<li><p>数据<br>数据是数据库存储的基本对象，有多种表现形式。数据的表现形式还不能完全表达其内容，需要经过解释，数据的解释是指对数据含义的说明，数据的含义成为数据的语义，数据和他的语义是不可区分的。</p>
</li>
<li><p>数据库（database，简称DB）<br>是存放数据的仓库，按照一定的格式存放的。严格来说，数据库是长期存储在计算机内，有组织、可共享的大量数据的集合。数据库中的数据按照一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性、并可为各种用户共享。<br>具有三个基本特点：永久存储、有组织、可共享</p>
</li>
<li><p>数据库管理系统（database management system ，DBMS）<br>DBMS的作用就是科学的组织和存储数据，高效的获取和维护数据。<br>主要功能包括了 </p>
<ol>
<li>数据定义功能：提供数据定义语言来对数据对象进行定义</li>
<li>数据组织、存储和管理： 基本目标是提供存储空间利用率和方便存取，提供多种方法（如索引查找，hash查找、顺序查找等）来提供存取效率</li>
<li>数据操纵功能：通过数据操纵语言对数据库进行基本操作，如查询，插入，删除和修改等。</li>
<li>数据库的事务管理和运行管理：数据库在建立、运用和维护时对数据库管理系统统一管理、控制、以保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。</li>
<li>数据库的建立和维护功能：包括了数据库初始数据的输入，转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。</li>
<li>其他功能：DBMS与网络中其他软件系统的通信功能；一个DBMS与另一个DBMS或文件系统的数据转换功能；异构数据库之间的互访和互操作功能等。</li>
</ol>
</li>
<li><p>数据库系统（database system，DBS）<br>数据库系统是指计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、应用系统、数据库管理员构成。</p>
</li>
</ol>
<img src="/posts/486c9009/1.png">
<hr>
<h3 id="二、-数据库系统的特点"><a href="#二、-数据库系统的特点" class="headerlink" title="二、 数据库系统的特点"></a>二、 数据库系统的特点</h3><ol>
<li><p>数据结构化<br>这是一个主要特征之一。所谓的“整体”结构化是指数据库的数据不再仅仅针对某一个应用，而是面向全组织；不仅数据内部是结构化的，而且整体也是结构化的，数据之间是具有联系的。在数据库系统中，不仅数据是整体结构化，而且存取数据的方式也很灵活，可以存取数据库中的某一个数据项、一组数据项、一个记录或一组记录。</p>
</li>
<li><p>数据的共享性高，冗余度低，易扩充<br>数据是面向整个系统，可以被多个用户多个应用共享使用，数据共享可以大大减少数据冗余，还能避免数据之间的不相容性和不一致性。<br>数据不一致性是指同一数据由于人工管理或者文件系统管理时，重复存储，导致不同拷贝的值不一样。</p>
</li>
<li><p>数据独立性高<br>数据的物理独立性：是指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。即，数据在磁盘上怎样存储由DBMS管理，用户程序不需要了解，应用程序要处理的只是数据的逻辑结构，这样当数据的物理存储改变了，应用程序不用改变。<br>逻辑独立性：是指用户的应用程序与数据库的逻辑结构是相互独立的，即，当数据的逻辑结构改变时，用户程序也可以不变。<br>数据独立性由DBMS的二级映像功能来保证。</p>
</li>
<li><p>数据由DBMS统一管理和控制<br>数据库的共享是并发共享，即多个用户可以同时存取数据库中的数据甚至同时存储同一个数据。<br>所以DBMS还提供以下几个数据控制功能：<br>（1）数据的安全性保护<br>（2）数据的完整性检查<br>（3）并发控制<br>（4）数据库恢复</p>
</li>
</ol>
<p> 总结：数据库是长期存储在计算机内有组织的大量的共享的数据集合。它可以提供各种用户共享，具有最小冗余度和较高的数据独立性。</p>
<hr>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>数据模型是现实世界数据特征的抽象</p>
<p>数据模型应该满足三个方面：比较真实的模拟现实世界；二是容易为人所理解；三是便于在计算机实现。</p>
<p>根据不同的目的，可以把模型划分两类：</p>
<ul>
<li>概念模型：也称为信息模型，按照用户的观点来对数据和信息建模，主要用于数据库设计</li>
<li>逻辑模型和物理模型：逻辑模型主要包括层次模型，网状模型，关系模型，面向对象模型和对象关系模型等。是按照计算机系统的观点对数据建模。主要用于DBMS的实现。物理模型是对数据最底层的抽象，描述数据在系统内部的表示方法和存取方法，是面向计算机系统的。物理模型的具体实现是DBMS的任务，数据库设计人员要了解和选择物理模型，一般用户则不需要考虑物理级的细节。</li>
</ul>
<hr>
<h3 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h3><p>一般来说，数据模型是严格定义一组概念的集合，这些概念精确地描述了系统的静态特性，动态特性和完整性约束条件。因此数据模型通常由数据结构，数据操作和完整性约束三部分来组成。</p>
<hr>
<p>一、 数据结构<br>数据结构描述数据库的组成对象以及对象之间的联系。有两类：</p>
<ol>
<li>是与对象的类型，内容，性质有关的，例如网状模型中的数据项，记录，关系模型中的域，属性，关系等。</li>
<li>是与数据之间的联系有关的对象，例如网状模型中的系型。</li>
</ol>
<hr>
<p>二、 数据操作</p>
<p>数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。</p>
<p>数据库的主要有查询和更新（包括插入，删除、修改）两大类操作。数据模型必须定义这些操作的确切含义，操作符号，操作规则（如优先级）以及实现操作的语言。</p>
<p>数据操作是对系统动态特性的描述。</p>
<hr>
<p>三、 数据的完整性约束条件</p>
<p>数据的完整性约束条件是一组完整性规则。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态和状态的变化，以保证数据的正确，有效，相容。</p>
<p>数据模型应该反映和规定本数据模型必须遵守的基本的通用的基本的通用的完整性约束条件。</p>
<p>数据模型还应该提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。</p>
<hr>
<h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><p>概念模型一方面应该具有较强的语义表达能力，能够方便、直接的表达应用中的各种语义知识、另一方面应该简单，清晰，易于用户理解。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>（1） 实体：客观存在并可相互区别的事物成为实体。可以是具体的人事物，也可以是抽象的概念或者联系，比如老师和学校的工作关系。</p>
<p>（2）属性：实体所具有的某一特性称为属性。一个实体可以由若干的属性来刻画，比如学生这个实体可以由学号姓名性别出生年月等信息组成。</p>
<p>（3）码:唯一标识实体的属性集称为码。比如学号是学生实体的码。</p>
<p>（4）域：属性的取值范围称为该属性的域，比如学号的域为8位整数，姓名的域为字符串集合，学生年龄的域为整数，性别的域为（男，女）</p>
<p>（5）实体型：具有相同属性的实体必然具有共同的特征和性质。用实体名以及属性名称集合来抽象和刻画同类实体，称为实体型。比如学生（学号，姓名，性别，出生年月，所在院系，入学时间）就是一个实体型。</p>
<p>（6）实体集：同一类型实体的集合称为实体集，例如全体学生就是一个实体集</p>
<p>（7）联系：实体内部的联系通常是指组成实体的各属性之间的联系；实体之间的联系通常是指不同的实体集之间的联系。</p>
<hr>
<h4 id="实体型之间的联系"><a href="#实体型之间的联系" class="headerlink" title="实体型之间的联系"></a>实体型之间的联系</h4><p>一、两个实体型的联系分为三种：</p>
<ol>
<li><p>一对一联系（1：1）<br>如果对于实体集A中每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，则称为一对一联系。比如电影院座位和观众实体之间的联系</p>
</li>
<li><p>一对多联系（1：n）<br>如果对于实体集A中每一个实体，实体集B中有n个实体（n&gt;=0）与之联系，比如部门和员工两个实体集之间的联系。</p>
</li>
<li><p>多对多联系（n:n）<br>表示实体集A中多个实体可与实体集B中多个实体相联系。例如一门课程可以同时有若干学生选修，而一个学生也可以同时选修多门课程，这就是多对多联系。<br>实际上，一对一联系是一对多联系的特例，而一对多联系又是多对多联系的特例。</p>
<hr>
</li>
</ol>
<p>二、 两个以上的实体型之间的联系</p>
<p>一般来说，两个以上的实体型也存在一对一，一对多，多对多的联系<br>比如 课程，老师，参考书 。一个课程可以由若干个老师讲授，也可以使用若干本参考书，这就是一对多。<br>供应商与项目，零件的联系，一个供应商可以供给多个项目多种零件，而且每个项目可以使用多个供应商供应的零件，每种零件可由不同的供应商攻击。所以是多对多联系。</p>
<img src="/posts/486c9009/2.png">
<hr>
<p>三、 单个实体型内的联系</p>
<p>同一个实体集内的各实体之间也可以存在一对一，一对多，多对多的联系。<br>比如职工内部也存在领导与被领导的关系，而一个职工仅被另一个职工直接领导，这是一对多的联系</p>
<hr>
<p>四、概念模型的一种表示方法：实体—联系方法</p>
<p>概念模型的方法挺多，最著名的是实体-联系方法（entity-relationship Approach）。该方法用E-R图来描述现实世界的概念模型，也称为E-R模型</p>
<p>E-R图提供表示实体型、属性和联系的方法：</p>
<ul>
<li>实体型 ：用矩阵表示，矩形框内写明实体名</li>
<li>属性：用椭圆表示，并用无向边将其相应的实体型连接起来</li>
</ul>
<p>例如 ：学生实体具有学号、姓名、性别、出生年份、系、入学时间等属性，用E_R图表示如下</p>
<img src="/posts/486c9009/3.png">
<ul>
<li>联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁边表上联系的类型（1:1,1:n或m:n）</li>
</ul>
<p>如果联系具有属性，那么这些属性也需要用无向边和该联系连接起来</p>
<img src="/posts/486c9009/4.png">
<hr>
<p>五、 一个实例</p>
<p>下面用E-R图来表示某个工厂物资管理的概念模型</p>
<p>物资管理设计的实体有：</p>
<ul>
<li>仓库 —-属性有仓库号，面积，电话号码</li>
<li>零件 —-属性有零件号，名称，规格，单价，描述</li>
<li>供应商—-属性有供应商号，姓名，地址，电话号码，账号</li>
<li>项目 —-属性有项目号，预算，开工日期</li>
<li>职工 —-属性有职工号，姓名，年龄，职称</li>
</ul>
<p>这些实体的联系如下：<br>（1）一个仓库可以存放多种零件，一种零件可以存放在多个仓库中，因此仓库和零件具有多对多的联系。用库存量来表示某种零件在某个仓库中的数量<br>（2）一个额仓库有多个职工当仓库保管员，一个职工只能在一个仓库工作，因此仓库和职工之间是一对多的联系。<br>（3）职工之间具有领导和被领导关系，即仓库主任领导若干保管员，因此职工实体型中具有一对多的联系。<br>（4）供应商、项目和零件三者之间具有多对多的联系。即一个供应商可以供给若干项目多种零件，每个项目可以使用不同供应商供应的零件，每种零件可由不同的供应商供给。</p>
<img src="/posts/486c9009/实体及其属性图.png" title="实体及其属性图">
<img src="/posts/486c9009/实体及其联系图.png" title="实体及其联系图">
<img src="/posts/486c9009/实体-联系图.png" title="完整的实体-联系图">
<hr>
<h3 id="最常用的数据模型"><a href="#最常用的数据模型" class="headerlink" title="最常用的数据模型"></a>最常用的数据模型</h3><p>目前最常用的逻辑数据模型有：</p>
<ul>
<li>层次模型</li>
<li>网状模型</li>
<li>关系模型</li>
<li>面向对象模型</li>
<li>对象关系模型</li>
</ul>
<p>其中层次模型和网状模型称为非关系模型，在非关系模型中，实体用记录表示，实体的属性对应记录的数据项（或字段）。实体之间的联系在非关系模型中转换成记录之间的两两联系。</p>
<h4 id="非关系模型"><a href="#非关系模型" class="headerlink" title="非关系模型"></a>非关系模型</h4><p>非关系模型中的数据结构的单位是基本层次联系，就是指两个记录及他们之间的一对多（包括一对一）的联系。<br>如图</p>
<img src="/posts/486c9009/基本层次联系.png" title="基本层次联系">
<p>Ri位于联系Lij的始点，称为双亲节点，Rj位于联系Lij的终点，称为子女节点</p>
<hr>
<h4 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h4><p>层次模型用树形来表示各类实体以及实体间的联系。现实世界中许多实体之间的联系本来就呈现出一种很自然的的层次关系，如行政机构，家族关系等。</p>
<p>一、层次数据模型的数据结构</p>
<p>满足下面两个条件的集合为层次模型</p>
<p>（1）有且只有一个节点，没有双亲节点，这个节点称为根节点<br>（2）根以外的其他节点有且只有一个双亲节点。</p>
<p>在层次模型中，每个节点表示一个记录模型，记录（类型）之间的联系用节点之间的连线（有向边）表示，这种联系是父子之间的一对多的联系。</p>
<p>每个记录模型可包含若干个字段，记录类型描述的是实体，字段描述实体的属性，各个记录类型及其字段都必须命名。各个记录类型、同一个记录类型里的各个字段不能同名。</p>
<p>下图是一个教员学生层次模型，有4个记录型，其中记录型— 系 是根节点，由系编号，系名，办公地点三个字段组成。两个子女节点教研室和学生。记录型— 教研室 是系的子女节点，同时又是教员的双亲节点。由教研室编号，教研室名两个字段组成。记录型— 学生 由学号，姓名，成绩三个字段组成。记录型— 教员由职工号，姓名，研究方向三个字段组成。学生和教员是叶节点，他们没有子女节点。由系到教研室，由教研室到教员，由系到学生均是一对多的联系。</p>
<img src="/posts/486c9009/5.png" title="教员学生层次模型">
<p>下图是上图对应的一个值，该值是D02系记录值及其所有后代记录值组成的一棵树。</p>
<img src="/posts/486c9009/6.png">
<hr>
<p>二、 多对多联系在层次模型中的表示</p>
<p>如果用层次模型表示多对多联系，必须首先将多对多联系分解成一对多联系。分解方法两种：冗余节点法和虚拟节点法</p>
<p>下图是简单的多对多，一个学生可以选修多门课程，一门课程可由多个学生选修，学生由学号，姓名，成绩三个字段组成。课程由课程号两个字段组成。</p>
<img src="/posts/486c9009/7.png" title="简单的多对多联系">
<p>下图是采用冗余节点法，通过增加两个冗余节点将多对多联系转换成两个一对多联系</p>
<img src="/posts/486c9009/8.png" title="冗余节点法">
<p>下图是采用虚拟节点的分解方法，将冗余节点换成虚拟节点，所谓虚拟节点就是一个指针，指向所代替的节点。</p>
<img src="/posts/486c9009/9.png" title="虚拟节点法">
<p>冗余节点法的优点是结构清晰，允许节点改变存储位置，缺点需要额外空间，并有潜在的不一致性问题。虚拟节点的优点在减伤空间的浪费吗，避免产生潜在不一致性，缺点是节点改变了存储位置可能引起虚拟节点中指针的修改。</p>
<hr>
<p>三、层次模型的数据操纵与完整性约束</p>
<p>层次模型的数据操纵主要有查询，插入，删除和更新，进行插入，删除，更新操作时要满足层次模型的完整性约束条件。</p>
<p>在进行插入操作的时候，如果没有相应的双亲节点就不能插入它的子女节点值，比如在上面的教员学生层次模型中，若新加入一名教员，但是还没分配教研室，这就就不能插入到数据库中。</p>
<p>在进行删除操作时，如果删除双亲节点，那么双亲节点下的子女节点值也被同时删除。在教员学生层次模型中，删除教研室，那么该教研室的教员的数据也会全部丢失。</p>
<p>四、层次数据模型的存储结构</p>
<p>层次数据库中不仅要存储数据本身，还要存储数据之间的层次联系。层次模型数据的储存常常是和数据之间的储存结合在一起的，常用方法有两种</p>
<ol>
<li>邻接法<br>按照层次树穿越的顺序把素有记录值依次邻接存放，即通过物理空间的位置相邻来体现（或隐含）层次顺序。</li>
</ol>
<img src="/posts/486c9009/10.png">
<ol>
<li>链接法<br>用指针来反映数据之间的层次联系。</li>
</ol>
<p>子女-兄弟链接法：每个记录设两类指针，分别指向最左边的子女（每个记录型对应一个）和最新的兄弟。</p>
<img src="/posts/486c9009/11.png" title="子女-兄弟链接法">
<p>层次序列链接法：按照树的前序穿越链接各记录值</p>
<img src="/posts/486c9009/12.png" title="层次序列链接法">
<p>五、层次模型的优缺点</p>
<p>优点：</p>
<ol>
<li>层次模型的数据结构比较简单清晰</li>
<li>层次数据库的查询效率高<br>层次数据库的性能优于关系数据库，不低于网状数据库</li>
<li>层次数据模型提供了良好的完整性支持</li>
</ol>
<p>缺点：</p>
<ol>
<li>现实世界很多是非层次性的，如节点之间具有多对多联系</li>
<li>一个节点如果具有多个双亲等，层次模型表示这类联系方法就很笨拙。</li>
<li>查询子女节点必须通过双亲节点</li>
<li>由于结构严密，层次命令趋于程序化</li>
</ol>
<hr>
<h4 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h4><p>由于很多联系是非层次的，用层次模型表示非树形结构是很不直接的，而网状模型则可以克服这个问题。</p>
<p>一、 网状数据模型的数据结构<br>满足以下两个条件则称为网状模型：<br>（1）允许一个以上的节点无双亲<br>（2）一个节点可以有多余一个的双亲</p>
<p>网状模型是一种比层次模型更具有普遍性的结构，去掉了层次模型的两个限制，允许多个节点没有双亲节点，允许节点可以有多个双亲节点。还允许两个节点之间有多重联系（称为符合联系）。网状模型可以更直接的去描述现实世界，而层次模型实际上是网状模型的一个特例。</p>
<p>网状模型中每一个节点表示一个记录类型（实体），每个记录类型可包含若干个字段（字体的属性），节点间的连线表示记录类型（实体）之间的一对多的父子联系。在层次模型中，子女节点和双亲节点的联系是唯一的，而在网状模型中的是可以不唯一的。</p>
<p>下面是网状模型的例子</p>
<img src="/posts/486c9009/13.png" title="网状模型">
<p>以学生选课为例：</p>
<ul>
<li>一个学生可以选修若干门课程，某一课程可以被多个学生选修，因此学生与课程之前是多对多联系。为了表示多对多的联系，引入了一个学生选课的联结记录，由三个数据项组成，即学号，课程号，成绩，表示某个学生选修某一门课程及其成绩。</li>
<li>学生选课就包含了三个记录，学生、课程、选课</li>
<li>每个学生可以选多门课程，即对学生记录中的一个值，选课记录中可以多个值相联系，而选课记录中的一个值，只能和学生记录中的一个值联系。学生和选课之间的联系是一对多的联系。联系名为S-SC。同样课程与选课的联系也是一对多的联系。联系名为C-SC 。</li>
</ul>
<img src="/posts/486c9009/14.png">
<p>下图是一个学生，选课，课程的网状数据库的一个值</p>
<img src="/posts/486c9009/15.png">
<hr>
<p>二、 网状数据模型的操纵和完整性约束</p>
<p>DBTG在模式DDL中提供了定义DBTG数据库完整性的若干概念和语句：<br>（1）支持记录码的概念，码即唯一表示记录的数据项的集合。例如学生记录中的学号是码，因此不允许学生记录中出现重复的学号。<br>（2）保证一个联系中双亲记录和子女记录之间是一对多的联系。<br>（3）可以直接双亲记录和子女记录的某些约束条件。比如有些子女记录要双亲记录存在才可以插入，双亲记录删除也会连同删除。</p>
<p>三、网状数据模型的存储结构</p>
<p>最常用的是链接法，包括单向链接，双向链接，环状链接和向首链接，此外还有其他方法：引元阵列法，二进制阵列法，索引法，根据具体情况来使用。</p>
<p>设一个网状数据库的实例：</p>
<ul>
<li>学生记录：S1 , S2 , S3;</li>
<li>课程记录：C1 , C2 , C3;</li>
<li>S1的选课记录: S1C1A 、S1C2A;</li>
<li>S2的选课记录: S2C1A 、S2C3B;</li>
<li>S3的选课记录: S3C1B 、S3C2B</li>
<li>S4的选课记录: S4C1A 、S4C2A 、S4C3B</li>
</ul>
<img src="/posts/486c9009/16.png" title="学生、选课、课程的网状数据库实例">
<ul>
<li><p>学生选课数据库中 学生、课程、选课三个记录的值可以分别按某种文件组织方式存储，记录之间的联系用单向链接实现</p>
</li>
<li><p>图中的实线链表示S-SC联系，即把S1学生和他的选课记录（选修的C1，C2两门课程的选课记录）链接起来，同样把S2,S3,S4学生和他们的选课记录链接起来；</p>
</li>
<li>虚线表示C-SC联系，把C1课程和选修了C1课程的学生记录（有S1,S2,S3,W4学生选修了C1）链接起来，同样把C2,C3课程和选修了这些课程的学生记录链接起来。</li>
</ul>
<p>四、网状数据模型的优缺点</p>
<p>优点：</p>
<ol>
<li>能够更直接的描述现实世界，比如一个节点可以有多个双亲，节点之间可以有多重联系</li>
<li>具有良好的性能，存取效率较高</li>
</ol>
<p>缺点：</p>
<ol>
<li>结构比较复杂，随着应用环境的阔达，数据库的结构变得越来越负责，不利于最终用户掌握。</li>
<li>网状模型的DDL，DML复杂，并且要嵌入某一种高级语言（COBOL ，C）。用户不容易掌握，不容易使用。</li>
<li>由于记录之间的联系是通过存取路径实现的，应用程序在访问在访问数据时必须选择适当的存取路径，因此用户必须了解系统结构的细节，家中了编写应用程序的负担。</li>
</ol>
<hr>
<h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>关系模型是目前最重要的一种数据模型。关系数据莫系统采用关系模型作为数据的组织方式。</p>
<p>一、 关系数据模型的数据结构</p>
<p>关系模型与上面的模型不同，是建立在严格的数学概念的基础上的。<br>从用户观点上看，关系模型是由一组关系组成，每个关系的数据结构是一张规范化的二维表。以下图学生登记表为例</p>
<img src="/posts/486c9009/17.png" title="关系模型的数据结构">
<ul>
<li>关系（relation）：一个关系对应通常说的一张表，如学生登记表</li>
<li>元祖（tuple）: 表中的一行即为一个元祖；</li>
<li>属性（Attribute）：表中的一列即为一个属性，给每一个属性起一个名称即为属性名。如这张表有6列，对应六个属性（学号，姓名，年龄，性别，系名，年级）</li>
<li>码（key）：也称为码键。表中某个属性组，它可以唯一确定一个元祖，如表中的学号可以确定一个学生，也就称为本关系的码</li>
<li>域（domain）：属性的取值范围，如人的年龄一般在1~150岁之间，大学生年龄属性域是（14~38），性别的域是（男，女），系名的域是一个学校所有系名的集合；</li>
<li>分量：元祖中的一个属性值</li>
<li>关系模式：对关系的描述，一般表示为<ul>
<li>关系名（属性1，属性2，…… ，属性n）</li>
</ul>
</li>
</ul>
<p>上面的关系可以描述为</p>
<ul>
<li>学生（学号，姓名，年龄，性别，系名，年级）</li>
</ul>
<p>在关系模型中，实体以及实体间的联系都是用关系来表示。例如，学生，课程，学生与课程之间的多对多联系在关系模型中可以如下表示：</p>
<ul>
<li>学生（学号，姓名，年龄，性别，系名，年级）</li>
<li>课程（课程号，课程名，学分）</li>
<li>选修（学号，课程号，成绩）</li>
</ul>
<p>关系模型要求关系必须是规范化的，即要求关系必须满足一定的规范条件：关系的每一个分量必须是一个不可分的数据项，也就是说不允许表中还有表。</p>
<img src="/posts/486c9009/18.png" title="不符合关系模型的表">
<p>下图是一个术语的粗略对比</p>
<img src="/posts/486c9009/19.png" title="术语对比">
<hr>
<p>二、 关系数据模型的操纵和完整性约束</p>
<p>主要操作：查询，插入，删除和更新数据。</p>
<p>完整性约束包含三大类：实体完整性，参照完整性，用户定义完整性</p>
<p>关系模型中的的数据操作都是集合操作，操作对象和操作结果都是关系，即若干元祖的集合，而不像非关系模型中国那样是单记录的操作方式。另一方面，关系模型把存取路径隐藏起来，用户只需要指出“干什么”、“找什么”，不必详细说明“怎么干”或“怎么找”，从而大大的提高了数据的独立性，提高了用户生产率。</p>
<p>三、关系数据模型的存储结构</p>
<p>在关系数据模型中，实体及实体间的联系都用表来表示，在关系数据库的物理组织中，有的DBMS 一个表对应一个操作系统文件，有的DBMS从操作系统获得若干大的文件，自己设计表、索引等存储结构。</p>
<p>四、关系数据模型的优缺点<br>优点：</p>
<ol>
<li>关系模型与非关系模型不同，是建立在严格的数学概念的基础上</li>
<li>关系模型的概念单一，无论实体还是实体之间的联系都用关系来表示。对数据的检索和更新结果也是关系（即表）所以其数据结果简单、清晰、用户易懂易用。</li>
<li>关系模型的存取路径对用户透明，从而更有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作。</li>
</ol>
<p>缺点：</p>
<ol>
<li>由于存取路径透明，查询效率往往不如非关系数据模型。</li>
</ol>
<hr>
<h2 id="数据库的系统结构"><a href="#数据库的系统结构" class="headerlink" title="数据库的系统结构"></a>数据库的系统结构</h2><blockquote>
<p>本章学习的是数据库系统的模式结构</p>
</blockquote>
<h3 id="数据库系统模式的概念"><a href="#数据库系统模式的概念" class="headerlink" title="数据库系统模式的概念"></a>数据库系统模式的概念</h3><p>在数据模型中有“型”（T）和“值（value）”的概念。型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。例如学生记录定义为（学号，姓名，性别，系别，年龄，籍贯）这样的记录型，而（900201,李明，男，计算机，22,江苏）则是该记录型的一个记录值</p>
<p>模式是数据库中全体数据的逻辑结构和特征的描述，仅仅涉及到型的描述，不涉及到具体的值。模式的一个具体值称为模式的一个实例。同一个模式可以有很多实例。</p>
<p>模式是相对稳定的，而实例是相对变动的，因为数据库的数据是不断更新的，模式反应的是数据的结构和联系，而实例反映的是数据库某一时刻的状态。</p>
<h3 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h3><p>三级模式是指数据库系统由外模式，模式和内模式构成。</p>
<img src="/posts/486c9009/20.png" title="层次结构图">
<h4 id="模式（Schema）"><a href="#模式（Schema）" class="headerlink" title="模式（Schema）"></a>模式（Schema）</h4><ol>
<li><p>模式也叫逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。属于数据库系统模式结构的中间层，既不涉及数据的物理存储细节和硬件环境，也与具体的应用无关。</p>
</li>
<li><p>模式实际上是数据库数据在逻辑级上的视图。一个数据库只有一个模式。数据库模式以某一种数据模型为基础，考虑所有用户的需求，结合成一个逻辑整体。</p>
</li>
<li>定义模式时要定义数据的逻辑结构，比如数据记录是由哪些数据项构成，数据项的名字、类型、取值范围等，而且要定义数据之间的联系，定义与数据有关的安全性、完整性要求。</li>
</ol>
<h4 id="外模式（External-Schema）"><a href="#外模式（External-Schema）" class="headerlink" title="外模式（External Schema）"></a>外模式（External Schema）</h4><ol>
<li><p>外模式也称为子模式或者用户模式，是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p>
</li>
<li><p>外模式通常是模式的子集。一个数据库可以有多个外模式，。对模式中的同一数据，在外模式中的结构、类型、长度、保密级别都可以不同。同一个外模式可以被某一个用户的多个应用系统使用，但是一个应用程序只能使用一个外模式。</p>
</li>
<li><p>外模式是保证数据库安全性的一个有力措施，每个用户只能看见和访问所对应的外模式中的数据，数据中的其余数据是不可见的。</p>
</li>
</ol>
<h4 id="内模式（Internal-Schema）"><a href="#内模式（Internal-Schema）" class="headerlink" title="内模式（Internal Schema）"></a>内模式（Internal Schema）</h4><p>内模式也称为存储模式（Storage Schema），一个数据库只有一个内模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。例如，记录的存储方式是顺序结构存储还是B树结构存储；索引按什么方式组织；数据是否压缩，是否加密；数据的存储记录结构有何规定等。</p>
<p>粗略的表达：内模式就是存储如表在哪个表空间在哪里有索引，表空间的数据文件放在哪里，在哪个磁盘。</p>
<hr>
<h3 id="数据的二级映像和功能和数据独立性"><a href="#数据的二级映像和功能和数据独立性" class="headerlink" title="数据的二级映像和功能和数据独立性"></a>数据的二级映像和功能和数据独立性</h3><p>数据库系统的三级模式是对数据的三个抽象级别，为了在系统内部实现这三个抽象层次的联系和转换，提供了两层映像：</p>
<ul>
<li>外模式/模式 映像</li>
<li>模式 / 内模式 映像</li>
</ul>
<p>这两层映像保证了数据库系统的数据能够具有较高的逻辑独立性和物理独立性。</p>
<h4 id="外模式-模式-映像"><a href="#外模式-模式-映像" class="headerlink" title="外模式/模式 映像"></a>外模式/模式 映像</h4><ol>
<li>模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。</li>
<li>同一个模式可以有任意多个外模式，。</li>
<li>每一个外模式，数据库系统都有一个外模式/模式映像，定了了外模式与模式之间的对应关系，这些映像的定义通常包含在各自的外模式的描述中。</li>
</ol>
<p>当模式改变时，由数据库管理员对每个 外模式/模式映像进行改变，可以使外模式不变，从而不必修改应用程序。保证了数据与程序的逻辑独立性。</p>
<h4 id="模式-内模式映像"><a href="#模式-内模式映像" class="headerlink" title="模式/内模式映像"></a>模式/内模式映像</h4><p>数据库只有一个模式，也只有一个内模式，所以模式/内模式映像是唯一的，定义了数据全局逻辑结构与存储结构之间的对应关系。例如说明逻辑记录和字段在内部是如何表示的。该映像定义一般包含在模式描述中。</p>
<p>当数据库的存储结构改变了，数据库管理员对模式/内模式映像作相应改变，就可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性。</p>
<p>三种模式的归纳：</p>
<ol>
<li><p>在三级模式中，模式即全局逻辑结构是数据库的中心和关键，独立于数据库的其他层次，设计数据库模式结构时应首先确定数据库的逻辑模式。</p>
</li>
<li><p>数据库的内模式依赖于全局逻辑结构，独立于外模式，也独立于存储设备。它是将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率。</p>
</li>
<li><p>数据库的外模式面向具体的应用程序，定义在逻辑模式之上，独立于存储模式和存储设备。当应用需求发生较大变化，相应外模式不能满足其视图要求时，外模式就得做改动。因此设计外模式需要充分考虑应用的扩充性。</p>
</li>
</ol>
<hr>
<h2 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h2><p>大概分为</p>
<ol>
<li>硬件平台及数据库：<ul>
<li>大内存</li>
<li>大磁盘</li>
<li>系统具有较高的通道能力</li>
</ul>
</li>
<li>软件：<ul>
<li>DBMS</li>
<li>支持DBMS的操作系统</li>
<li>具有数据库接口的高级语言</li>
<li>以DBMS为核心的应用开发工具</li>
<li>为特定应用环境开发的数据库应用系统</li>
</ul>
</li>
<li>人员<ul>
<li>数据库管理员</li>
<li>系统分析员和数据库设计人员</li>
<li>应用程序员</li>
<li>用户</li>
</ul>
</li>
</ol>
<hr>
<h1 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h1><h2 id="关系数据结构及形式化定义"><a href="#关系数据结构及形式化定义" class="headerlink" title="关系数据结构及形式化定义"></a>关系数据结构及形式化定义</h2><h3 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h3><p>关系模型的数据结构只包含单一的数据结构——-关系<br>在用户看来，关系模型中的数据的逻辑结构是一张扁平的二维表</p>
<ol>
<li><p>域（domain）<br>域是一组具有相同数据类型的集合</p>
</li>
<li><p>笛卡儿积（Cartesian product）<br>给定一组域D1，D2, … … ，Dn，这些域可以相同</p>
</li>
</ol>
<img src="/posts/486c9009/21.png">
<img src="/posts/486c9009/22.png">
<ol>
<li>关系（relation）</li>
</ol>
<img src="/posts/486c9009/23.png">
<p>当n=1时，称该关系为单元关系<br>当n=2时，称为二元关系</p>
<p>关系是笛卡尔积的有限子集，所以关系也是二维表。<br>每行对应一个元祖，每列对应一个域，由于域可以相同，为了加以区分，必须对每列起一个名字，称为属性（attribute），n目的关系必有n个属性。</p>
<ul>
<li>候选码（Candidate Key）： 关系中可以唯一地标识一个元组的 属性 或 属性组。</li>
<li>主码（Primary Key）： 若一个关系又多个候选码，则选定其中一个为主码。</li>
<li>主属性（Non-Key attribute）：包含在任何候选码中的诸属性称为主属性。不包含在任何候选码中的属性称为非码属性。</li>
<li>外码（Froregin Key）： 如果关系模式 <strong>R</strong> 中的属性或者属性组非该关系的码，但是它是其他关系的码，那么该属性集对关系模式 <strong>R</strong>而言是外码。</li>
<li>全码（All-Key）：关系模型的所有属性组是这个关系模式的候选码，称为全码。</li>
</ul>
<p>一般来说，D1,D2,D3,D4…..Dn的笛卡尔积是没有实际语义的，只有它的某个子集才有实际含义。</p>
<p>关系有三种类型：基本关系（基本表或基表）、查询表、视图表</p>
<ul>
<li>基本表是实际存在的表，是实际存储数据的逻辑表示。</li>
<li>查询表是查询结果对应的表</li>
<li>视图表是由基本表或者其他视图表到处的表，是虚表，不对应实际存储的数据</li>
</ul>
<p>基本关系具有六条性质：</p>
<ul>
<li>列的同质性</li>
<li>列名唯一性</li>
<li>列序无关性</li>
<li>元祖相异性</li>
<li>行序无关性</li>
<li>分量原子性</li>
</ul>
<p>在实际关系数据库产品中，不一定完全会具备这几条性质</p>
<h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p>关系模式是型，关系是值</p>
<p>关系的描述称为关系模式 ，形式化表示为R(U,D,DOM,F)<br>其中R为关系名，U为组成该关系的属性名集合，D为属性组U中的属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合</p>
<h3 id="关系数据库-1"><a href="#关系数据库-1" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>关系数据库的型也称为关系数据库模式，是对关系数据库的描述。<br>关系数据库模式包括：</p>
<ul>
<li>若干域的定义</li>
<li>在这里域上定义的若干关系模式</li>
</ul>
<hr>
<h2 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h2><p>关系模型给出了关系操作能力的说明，但不对RDBMS给出具体的语法要求，也就是说不通的RDBMS可以定义和开发不通的语言来实现这些操作。</p>
<h3 id="基本的关系操作"><a href="#基本的关系操作" class="headerlink" title="基本的关系操作"></a>基本的关系操作</h3><p>通常分为两大操作：</p>
<ul>
<li>查询（query）</li>
<li>插入（insert）、删除（delete）、修改（update）</li>
</ul>
<p>关系的查询表达能力很强，是关系操作中最主要的部分。</p>
<p>查询操作又可以分为：选择（select）、投影（project）、链接（join）、除（divide）、并（union）、交（intersection）、笛卡尔积等<br>其中选择，投影，并，差，笛卡尔积是5种基本操作，其他操作可以由基本操作来定义和导出的。</p>
<p>关系操作的特点就是集合操作方式，即操作的对象和结果都是集合。也称为一次一集合（set-at-a-time）的方式，而非关系数据库模型的数据操作方式则为一次一记录（record-at-a-time）的方式。</p>
<h3 id="关系数据语言分类"><a href="#关系数据语言分类" class="headerlink" title="关系数据语言分类"></a>关系数据语言分类</h3><p>早期是用代数方式或逻辑方式表示，称为关系代数和关系演算</p>
<p>关系代数，元祖关系演算和域关系演算均为抽象的查询语言，跟具体的RDBMS中实现的语言不完全一样。</p>
<p>一种介乎于关系代数和关系演算之间的语言SQL，具有丰富的查询功能，还具有数据定义和数据控制功能，是集合了查询、DDL、DML和DCL于一体的关系数据语言。</p>
 <img src="/posts/486c9009/24.png">
<hr>
<h2 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h2><p>关系模型的完整性规则是对关系的某种约束条件，也就是说关系的值随着时间变化时应该满足一些约束条件，这些条件实际上是现实世界的要求，任何关系都是需要时刻满足这些语义约束。</p>
<h3 id="关系的三类完整性约束"><a href="#关系的三类完整性约束" class="headerlink" title="关系的三类完整性约束"></a>关系的三类完整性约束</h3><h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><p>规则：若属性（一个或一组属性）A是基本关系R的主属性，那么A不能取空值</p>
<p>所谓空值就是“不知道”或“不存在”的值</p>
<p>规则说明：</p>
<ul>
<li>实体完整性是针对基本关系而言的</li>
<li>现实世界的实体是可区分的，即他们具有某种唯一标识</li>
<li>关系模型中以主码作为唯一标识</li>
<li>主码中的属性即主属性不能取空值。</li>
</ul>
<h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><ol>
<li><p>关系间的引用：在关系模型中实体及实体间的联系都是用关系来描述的，因此可能存在关系与关系间的引用。</p>
</li>
<li><p>外码</p>
<ul>
<li>设FALSE是基本关系R 的一个或一组属性，但不是关系R 的码。如果F与基本关系s的主码Ks相对应，则称F为基本关系R的外码</li>
<li>基本关系R称为参照关系</li>
<li>基本关系S称为被参照关系或目标关系</li>
<li>关系R和关系S不一定是不同的关系</li>
</ul>
<img src="/posts/486c9009/25.png">
</li>
</ol>
<ul>
<li><p>显然目标关系S的主码Ks和参照关系R的外码F必须定义在同一个（或同一组）域上。</p>
</li>
<li><p>注意的是，外码不一定要和相应的主码同名，不过在实际中，为了便于识别，尽量取相同的名字。</p>
</li>
</ul>
<p>所以参照完整性规则就是定义外码和主码之间的引用规则</p>
<p>参照完整性规则： 若属性（属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同关系），则对于R中每一个元祖在F上的值必须为</p>
<ul>
<li>或者取空值（F的每个属性值均为空值）</li>
<li>或者等于S中某个元祖的主码值</li>
</ul>
<p>具体如图</p>
 <img src="/posts/486c9009/26.png">
<h4 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h4><p>不同的数据库系统根据应用环境的不同，还需要特殊的约束条件，而用户定义的完整性就是针对某一具体关系数据库的约束条件。</p>
<ul>
<li>针对某一具体关系数据库的约束条件，反应某一具体应用的所涉及的数据必须满足的语义要求</li>
<li>关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法去处理它们，而不要用程序来承担这一个功能</li>
</ul>
<hr>
<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><p>关系代数是一种抽象的查询语言，<br>运算对象，运算符，运算结果是运算的三大要素<br>关系代数的运算对象是关系，运算结果也是关系<br>运算符包括四类：集合运算符，专门的关系运算符，算术比较符，逻辑运算符。</p>
<img src="/posts/486c9009/27.png" title="关系代数运算符">
<p>关系代数的运算按运算符的不同可分为传统的集合运算符和专门的关系运算符。其中集合运算符是把关系看成元祖的集合。专门的关系运算符不仅涉及行还涉及列。比较运算符和逻辑运算符是用来辅助专门的关系运算符进行操作的。</p>
<h3 id="传统的集合运算"><a href="#传统的集合运算" class="headerlink" title="传统的集合运算"></a>传统的集合运算</h3><ol>
<li><p>并（Union）<br>关系 R 与 S 具有相同的关系模式，即 R 与 S 的元数相同（结构相同），R 与 S 的并是属于 R 或者属于 S 的元组构成的集合，记作 R ∪ S，定义如下：</p>
<center>R∪S = {t | t∈R ∨ t∈S}</center>
</li>
<li><p>差（Difference）<br>关系 R 与 S 具有相同的关系模式，关系 R 与 S 的差是属于 R 但不属于 S 的元组构成的集合，记作 R − S，定义如下</p>
<center>R−S = {t | t∈R∨t∉S}</center>
</li>
<li><p>交（Intersection）<br>关系R和关系S交由即属于R又属于S的元组组成， 其结果仍为n目关系</p>
<center>R∩S = {t | t∈R ∧ t∈S }</center>
</li>
<li><p>笛卡尔积（cartesian product）<br>两个无数分别为 n 目和 m 目的关系 R 和 S 的 笛卡尔积是一个 (n+m) 列的元组的集合。组的前 n 列是关系 R 的一个元组，后 m 列是关系 S 的一个元组，记作 R × S，定义如下：</p>
<center>R×S = { t | t =< (tn,tm) ∧ tn∈R ∧ tm∈S}</center>


</li>
</ol>
 <img src="/posts/486c9009/28.png" title="并">
 <img src="/posts/486c9009/29.png" title="差">
 <img src="/posts/486c9009/30.png" title="交">
 <img src="/posts/486c9009/31.png" title="笛卡尔积">
<h3 id="专门的关系运算"><a href="#专门的关系运算" class="headerlink" title="专门的关系运算"></a>专门的关系运算</h3><p>专门的运算关系包括 选择、 投影、连接 、 除运算等。</p>
<p>先做几个记号</p>
 <img src="/posts/486c9009/32.png">
 <img src="/posts/486c9009/33.png">
 <img src="/posts/486c9009/34.png">
<blockquote>
<p> 目=列数，n目或者n度指的是关系表有n个属性，也就是有n列</p>
</blockquote>
 <img src="/posts/486c9009/35.png">
<ol>
<li><p>选择(selection)<br>定义：在关系R中选出满足指定条件F的元组(行操作)<br>表达式：σF(R) = {t | t∈R ∧ F(t)=’真’},<br>逻辑表达式F的基本形式为：X1 θ Y1<br>其中 θ 表示比较运算符或者逻辑运算符，X1、Y1等是属性名或常量或简单函数，而属性名也可以用它的序号来代替<br>比较运算符:<br>① ： &gt; 大于<br>② ：  ≥    大于等于<br>③ ： &lt; 小于<br>④ ： ≤  小于等于<br>⑤ ： =  等于<br>⑥ ： &lt;&gt;  不等于</p>
<p>逻辑运算符：<br>┐    非<br>∧    与<br>∨    或</p>
</li>
</ol>
<p>下图查询信息系（is系）全体学生</p>
 <img src="/posts/486c9009/36.png">
<p>其中下角标 5 为Sdept的属性序号</p>
<ol>
<li>投影(projection)<br>定义：从关系R中选出若干属性A组成新关系(列操作)<br>表达式：πA(R) = { t[A] | t∈R}<br>其中A为R中的属性列<br>投影操作是从列的角度进行和运算的<br>投影之后不仅取消了原关系的某些列，还可能取消了某些元组，因为取消了某些属性后，就可能出现重复行，所以应该取消这些完全相同的行。</li>
</ol>
 <img src="/posts/486c9009/37.png">
<ol>
<li><p>连接(join)<br>定义：从两个关系R和S的笛卡尔积中选取属性间满足指定条件AθB的元组<br>表达式：R∞S(AθB) = {t(r)t(s)|t(r)∈R∧t(s)∈S∧t(r)[A]θt(s)[B]}</p>
<img src="/posts/486c9009/38.png">
</li>
</ol>
 <img src="/posts/486c9009/39.png">
 <img src="/posts/486c9009/40.png">
 <img src="/posts/486c9009/41.png">
 <img src="/posts/486c9009/42.png">
<p>普通连接</p>
<center>
关系R：
A　B　C

a　b　c
b　a　c
c　a　b

关系S:
A　B　C

b　a　 c
a　b　 c
c　a　 b

连接起来：
RA RB RC　SA SB SC

a　b　c 　 a　b　c
a　b　c 　 b　a　c
a　b　c 　 c　a　b
b　a　c 　 a　b　c
b　a　c 　 b　a　c
b　a　c 　 c　a　b
c　a　b 　 a　b　c
c　a　b 　 b　a　c
c　a　b 　 c　a　b

</center>
就是R的第一行不断的加S的第一行，第二行，第三行，
R的第二行不断的加以S的第一行，第二行，第三行
一直加下去

拓展关系：
连接分两种：等值连接与自然连接
①等值连接：指定条件AθB的θ为'= '时
那么就把上面普通连接里面RA和SB相同的保留，其他去掉，而且重复的两行也去掉一行
<center>
RA RB RC　SA SB SC
a　b　c 　 b　a　c
a　b　c 　 c　a　b
b　a　c 　 a　b　c
</center>
②自然连接：在等值连接的基础上去除重复的属性
<center>

A　B　C
a　b　c
a　b　c 
b　a　c 

</center>

<ol>
<li>除运算(division)<br>定义：设关系R除以关系S的结果为关系T,则T包含所有在R但不在S中的属性及值,且T的元组与S的元组的所有组合都在R中.<br>表达式：<br>R÷S = {t(r)[X]|t(r)∈R∧π(Y)(S)属于Y(x)},其中Y(x)为x在R中的象集,x=t(r)[X]</li>
</ol>
 <img src="/posts/486c9009/43.png">
 <img src="/posts/486c9009/44.png">
<p>上面的演算经过有限次复合后形成的式子称为关系代数表达式</p>
<hr>
<h2 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h2><p>分为元组关系演算和域关系演算</p>
<h3 id="元组关系演算语言ALPHA"><a href="#元组关系演算语言ALPHA" class="headerlink" title="元组关系演算语言ALPHA"></a>元组关系演算语言ALPHA</h3><p>元组关系演算以元组变量作为谓词变元的基本对象。典型的元组关系演算语言是E.F.Codd提出的ALPHA语言，但这一语言并没有实际实现。现在关系库管理系统INGRES所用的QUEL语言是参会照ALPHA语言研制的，与ALPHA十分相似</p>
<p>基本格式中:操作语句主要有GET、PUT、HOLD、UPDATE、DELETE和DROP六条语句</p>
<p>ALPHA语言语句的基本格式是:</p>
<p>操作语句 工作空间名(表达式):操作条件</p>
<p>工作空间是用户与系统的通信区，它可以用一个字母表示，通常用W表示；表达式用于指定语句的操作对象，它可以是关系名和属性名，一条语句可以同时操作多个关系或多个属性；操作条件是一个逻辑表达式，它用于将操作结果限定在满足条件的元组中，操作条件可以为空；呆以在基本格式的基础上加上排序要求，定额要求等。</p>
<p>一、 检索操作</p>
<p>(1) 简单检索(即不带条件的检索)</p>
<p>格式： GET 工作空间名 （表达式1） 查询所有被选修的课程号码。<br>GET W (SC.Cno) </p>
<p>(2) 限定的检索(即带条件的检索)</p>
<p>格式： GET 工作空间名（表达式1） ：<br>操作条件 查询信息系(IS)中年龄小于20岁的学生的学号和年龄。<br> GET W (Student.Sno， Student.Sage):Student.Sdept=’IS’∧Student.Sage&lt;20 </p>
<p>(3) 带排序的检索</p>
<p>格式： GET 工作空间名（表达式1） [：操作条件] DOWN/UP 表达式2<br>查询计算机科学系(CS)学生的学号、 年龄， 结果按年龄降序排序。<br> GET W (Student.Sno， Student.Sage): Student.Sdept=‘CS’DOWN Student.Sage </p>
<p>(4) 带定额的检索</p>
<p>格式 : GET 工作空间名（定额）（表达式1）[：操作条件] DOWN/UP 表达式2<br>取出一个信息系学生的学号。<br> GET W (1) (Student.Sno): Student.Sdept=’IS’ </p>
<p>(5) 用元组变量的检索</p>
<ol>
<li>元组变量的含义<br>表示可以在某一关系范围内变化（也称为范围变量Range Variable）</li>
<li>元组变量的用途<br>简化关系名：设一个较短名字的元组变量来代替较长的关系名。<br>操作条件中使用量词时必须用元组变量。</li>
<li>定义元组变量<br>格式： RANGE 关系名 变量名</li>
</ol>
<p>一个关系可以设多个元组变量 查询信息系学生的名字<br>RANGE Student X<br>GET W (X.Sname):X.Sdept=‘IS’</p>
<p>(6) 用存在量词的检索</p>
<p>查询选修2号课程的学生名字。 </p>
<p>RANGE SC X  GET W (Student.Sname): ΕX(X.Sno=Student.Sno∧X.Cno=’2’) </p>
<p>查询至少选修一门其先行课为6号课程的学生名字<br>RANGE  Course CX<br>　　　　SC　 SCX<br>GET W (Student.Sname):<br>∃ SCX (SCX.Sno=Student.Sno∧<br>∃ CX (CX.Cno=SCX.Cno∧CX.Pcno=’6’))</p>
<p>(7) 带有多个关系的表达式的检索</p>
<p>查询成绩为90分以上的学生名字与课程名字 </p>
<p>RANGE  SC SCX<br>GET W (Student.Sname， Course.Cname): ∃SCX (SCX.Grade≥90∧SCX.Sno=Student.Sno∧Course.Cno=SCX.Cno)</p>
<p>(8) 用全称量词的检索</p>
<p>查询不选1号课程的学生名字。<br> RANGE SC SCX<br>GET W (Student.Sname): ∀SCX(SCX.Sno≠Student.Sno∨SCX.Cno≠’1’)</p>
<p>(9) 用两种量词的检索</p>
<p>查询选修了全部课程的学生姓名。</p>
<p>RANGE Course  　CX<br>　　　　SC　　SCX<br>GET W (Student.Sname) : ∀ CX ∃ SCX (SCX.Sno=Student.Sno ∧ SCX.Cno = CX.Cno)</p>
<p>(10) 用蕴函（Implication） 的检索</p>
<p>查询最少选修了95002学生所选的课程的学生的学号</p>
<p>思路：依次检查每一门课程，看95002是否选了这门课，如果选了，再看看有没有其他学生选了这么课，遍历完后。看看是否存在学生把95002选了的课都选了，如果存在即符合。</p>
<p>RANGE Course CX<br>　　　　SC　SCX<br>　　　　SC　SCY<br>GET W(Student Sno):∀ CX ( ∃ SCX  (SCX.Sno=’95002 ∧ SCX.Cno=CX.Cno)<br>　　　　　　　　　　→ ∃ SCY（SCY.Sno=Student.Sno ∧ SCY.Cno=CX.Cno))</p>
<p>(11) 聚集函数</p>
 <img src="/posts/486c9009/45.png">
<p>查询学生所在系的数目。 </p>
<p>GET W (COUNT(Student.Sdept))<br>COUNT函数在计数时会自动排除重复值。</p>
<p>二、更新操作</p>
<p>（1）修改操作<br>修改操作用UPDATE语句实现，步骤是：</p>
<ul>
<li>用HOLD语句将要修改的元组从数据库中读到工作空间中 HOLD 工作空间名（表达式1） [：操作条件 ] </li>
<li>用宿主语言修改工作空间中元组的属性 </li>
<li>用UPDATE语句将修改后的元组送回数据库中</li>
</ul>
<p>把95007学生从计算机科学系转到信息系 </p>
<p>HOLD W (Student.Sno， Student.Sdetp): Student.Sno=’95007   （从Student关系中读出95007学生的数据）<br>MOVE ‘IS’ TO W.Sdept （用宿主语言进行修改）<br>UPDATE W （把修改后的元组送回Student关系）</p>
<p>（2）插入操作</p>
<ul>
<li>用宿主语言在工作空间中建立新元组 </li>
<li>用PUT语句把该元组存入指定关系中  PUT 工作空间名 （关系名） </li>
</ul>
<p>学校新开设了一门2学分的课程‚计算机组织与结构‛ ， 其课程号为8， 直接先行课为6号课程。 插入该课程元组 </p>
<p>MOVE ‘8’ TO W.Cno<br>MOVE ‘计算机组织与结构’ TO W.Cname<br>MOVE ‘6’ TO W.Cpno<br>MOVE ‘2’ TO W.Ccredit<br>PUT W (Course)　　　　(把w中的元组插入到制定关系course中)</p>
<p>put语句只对一个关系操作，表达式必须为单个关系名</p>
<p>（3）删除</p>
<ul>
<li>用HOLD语句把要删除的元组从数据库中读到工作空间中 </li>
<li>用DELETE语句删除该元组  DELETE 工作空间名</li>
</ul>
<p>95110学生因故退学， 删除该学生元组。 </p>
<p>HOLD W (Student):Student.Sno=’95110’<br>DELETE W</p>
<hr>
<h3 id="域关系语言QBE"><a href="#域关系语言QBE" class="headerlink" title="域关系语言QBE"></a>域关系语言QBE</h3><p>域关系演算以元组变量的分量（即域变量）作为谓词变元的基本对象。最突出的特点是操作方式，它是一种高度非过程化的基于屏幕表格的查询语言，用户通过终端屏幕编辑程序，以填写表格的方式构造查询要求，而查询的结果也是以表格形式显示。</p>
<p>QEB中用示例元素来表示查询结构可能的情况，示例元素实际上就是域变量。以下就是QEB的操作框架：</p>
 <img src="/posts/486c9009/46.png">
 <img src="/posts/486c9009/47.png">
<hr>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>关系数据库是目前使用最广泛的数据库系统。<br>关系数据库与非关系数据库的区别：关系系统只有“表”这一种数据结构，而非关系数据库系统还有其他数据结构，以及对这些数据结构的操作。</p>
<hr>
<h1 id="关系数据库标准语言SQL"><a href="#关系数据库标准语言SQL" class="headerlink" title="关系数据库标准语言SQL"></a>关系数据库标准语言SQL</h1><blockquote>
<p>SQL—-结构化查询语言，是关系数据库的标准语言，SQL是一个通用的，功能极强的关系数据库语言。</p>
</blockquote>
 <img src="/posts/486c9009/48.png">
<h2 id="SQL特点"><a href="#SQL特点" class="headerlink" title="SQL特点"></a>SQL特点</h2><p>SQL语言之所以能够为用户和业界所接受，并成为国际标准，是因为它是一个综合的、功能极强同时又简捷易学的语言。SQL语言集数据查询、数据操纵、数据定义和数据控制功能于一体，主要特点包括：</p>
<ol>
<li><p>综合统一<br>SQL集合数据定义、数据操纵、数据控制于一体，语言风格统一。可以独立完成数据库生命周期中的全部活动</p>
<ul>
<li>定义关系模式，插入数据，建立数据库</li>
<li>对数据库中的数据进行查询和更新</li>
<li>数据库重构和维护</li>
<li><p>数据库安全性、完整性控制</p>
<p>在关系模型中实体和实体间的联系均用关系表示，这种数据结构的单一性带来了数据操作符的统一性，查找、插入、删除、更新等每一种操作都只需要一种操作符</p>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>高度非过程化</p>
</li>
<li><p>面向集合的操作方式<br>SQL采用集合操作方式，不仅操作对象、查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合。</p>
</li>
<li><p>以同一种语法结构提供多种使用方式<br>SQL即使独立的语言，也是嵌入式语言。既可以在终端键盘直接输入SQL命令进行数据库操作，也可以嵌入到高级语言，如C、Java程序中提供给程序员使用。这种统一的语法提供多种不同的使用方式的做法，提供了极大的灵活性与方便性。</p>
</li>
<li><p>语言简洁，易学易用<br>核心功能只有九个动词，如下图所示</p>
<img src="/posts/486c9009/49.png">
</li>
</ol>
<h2 id="SQL基本概念"><a href="#SQL基本概念" class="headerlink" title="SQL基本概念"></a>SQL基本概念</h2><p>SQL语言支持关系数据库三级模式结构。其中外模式对应于视图和部分基本表，模式对应于基本表，内模式对应于存储文件。</p>
<p>SQL支持关系数据库三级模式结构，如下：</p>
 <img src="/posts/486c9009/50.png">
<ul>
<li>基本表：独立存储于数据库中的数据表（关系），可有若干个索引。</li>
<li>索引：对表中的属性组进行逻辑上排序，可以加快检索速度。</li>
<li>视图：由基表导出的虚表，数据库中只保存视图的定义。</li>
<li>存储文件：以OS文件的形式保存数据库的表、视图、索引等数据库对象。</li>
</ul>
<hr>
<h2 id="学生-课程数据库"><a href="#学生-课程数据库" class="headerlink" title="学生-课程数据库"></a>学生-课程数据库</h2><p>学生-课程模式 S-T :</p>
<ul>
<li>学生表：Student(Sno,Sname,Ssex,Sage,Sdept)</li>
<li>课程表：Course(Cno,Cname,Cpno,Ccredit)</li>
<li>学生选课表：SC(Sno,Cno,Grade)</li>
</ul>
 <img src="/posts/486c9009/51.png" title="Student表">
 <img src="/posts/486c9009/52.png" title="Course表">
 <img src="/posts/486c9009/53.png" title="SC表">
<h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>SQL的数据定义功能包括了：</p>
<hr>
<p>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一<br>｜　　　　　　｜　　　　　　　操作方式　　　　　　　　　　　　　｜<br>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一<br>｜　操作对象　｜　　 创建　　 　 　｜　　删除　　　 ｜ 　 　 修改 　｜<br>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一<br>｜　　模式　　｜CREATE SCHEMA ｜DROP SCHEMA　｜　ｘｘｘ　　　｜<br>｜　　表　　　｜CREATE TABLE　 ｜DROP TABLE 　　｜ALTER TABLE  ｜<br>｜　　视图　　｜CREATE VIEW 　 ｜ DROP VIEW　 　｜　ｘｘｘ 　  　｜<br>｜　　索引　　｜CREATE INDEX 　｜DROP INDEX　　｜　ｘｘｘ　　　｜<br>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一</p>
<hr>
<p>SQL通常不提供修改模式定义、修改视图定义和修改索引定义的操作，如有要修改，只能先删除再重建。</p>
<h3 id="模式的定义和删除"><a href="#模式的定义和删除" class="headerlink" title="模式的定义和删除"></a>模式的定义和删除</h3><p>一、定义模式<br>“模式”是一个数据库的命名空间，一个框架，打个比方：在java中，创建模式相当于创建一个包，而创建表相当于创建一个类，一个类是在某一个包下面进行管理的。在mysql中，创建模式与创建数据库是一样的，也就是create schema &lt;模式名&gt;与 create database &lt;数据库名&gt;是等效的。所以模式的定义与删除语句如下：</p>
<blockquote>
<p>create schema &lt;模式名&gt; authorization &lt;用户名&gt;</p>
</blockquote>
<p>例如创建一个学生-课程的模式S-T<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create schema &quot;S-T&quot; authorization wang;//为用户wang创建一个模式S-T</span><br></pre></td></tr></table></figure></p>
<p>删除模式语句如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop schema &lt;模式名&gt; &lt;cascade|restrict&gt;</span><br></pre></td></tr></table></figure>
<p>其中cascade与restrict两者必选其一。</p>
<p>cascade(级联)，表示删除模式的同时，把该模式中的所有数据库对象（例如表等）也全部删除。</p>
<p>restrict（限制），表示如果该模式下已经定义了下属的数据库对象（如表、视图等），则拒绝执行该删除语句的执行<br>还可以在创建模式的时候同时在这个模式定义中进一步创建基本表，视图，定义授权，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create schema &lt;模式名&gt; authorization &lt;用户名&gt; [&lt;表定义子句&gt; | &lt;视图定义子句&gt; |&lt;授权定义子句&gt;]</span><br></pre></td></tr></table></figure>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE SCHEMA TEST AUTHORIZATION ZHANG</span><br><span class="line">	 CREATE TABLE TAB1(COL1 SMALLINT,</span><br><span class="line">			   COL2 INT,</span><br><span class="line">			   COL3 CHAR(20),</span><br><span class="line">			   COL4 NUMERIC(10,3),</span><br><span class="line">			   COL5 DECIMAL(5,2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该语句为用户ZHANG创建了一个模式TEST，并且定义了一个表TAB1</p>
<p>二、删除模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP SCHEMA　&lt;模式名&gt; &lt; CASCADE | RESTRICT &gt;</span><br></pre></td></tr></table></figure>
<p>其中CASCADE ：级联删除。即：删除模式的同时把模式中所有的数据库对象（模式中定义的下属数据库对象）全部删除</p>
<p>RESTRICT：限制删除。即：删除模式时，如果模式中已定义下属数据库对象，则拒绝删除。</p>
<p>这两个必须二选一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP SCHEMA ZHANG CASCADE</span><br></pre></td></tr></table></figure>
<p>该语句删除了模式ZHANG，同时定义的TAB1也被删除了</p>
<h3 id="基本表的定义、删除与修改"><a href="#基本表的定义、删除与修改" class="headerlink" title="基本表的定义、删除与修改"></a>基本表的定义、删除与修改</h3><p>一、定义基本表</p>
<p>基本格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;表名&gt;(&lt;列名&gt; &lt;数据类型&gt;[列级完整性约束条件] </span><br><span class="line">                   [,&lt;列名&gt; &lt;数据类型&gt;[列级完整性约束条件]]  </span><br><span class="line">                    .......</span><br><span class="line">                   [,&lt;表级完整性约束条件&gt; ])；</span><br></pre></td></tr></table></figure>
<p>例子：执行完语句后，会在数据库中建立一个新的空的“学生”表Student，并将有关“学生”表的定义及有关约束条件存放到数据字典中</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">	( sno <span class="built_in">CHAR</span>(<span class="number">9</span>) PRIMARY <span class="keyword">KEY</span>,  <span class="comment">/* 列级完整性约束条件，Sno是主码*/</span></span><br><span class="line">	 Sname <span class="built_in">CHAR</span>(<span class="number">20</span>)  <span class="keyword">UNIQUE</span> ,    <span class="comment">/* Sname取唯一值*/</span></span><br><span class="line">	 Ssex <span class="built_in">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">	 Sage SMALINT,</span><br><span class="line">	 Sdept <span class="built_in">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>
<p>二、数据类型<br> 关系模型中重要的概念是域，每一个属性来自一个域，它的取值必须是域中的值。在SQL中域的概念用数据类型来实现，不同的RDBMS在支持的数据类型不完全相同。<br>一个属性选用哪种数据类型要根据实际情况来决定，一般考虑两个方面，一是取值范围，二是要什么什么运算。<br>下面是MySQL 数据类型：：文本、数字和日期/时间类型。<br> Text 类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CHAR(size):保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符.</span><br><span class="line"></span><br><span class="line">VARCHAR(size):保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。</span><br><span class="line">注释：如果值的长度大于 255，则被转换为 TEXT 类型。</span><br><span class="line"></span><br><span class="line">TINYTEXT:存放最大长度为 255 个字符的字符串。</span><br><span class="line"></span><br><span class="line">TEXT:存放最大长度为 65,535 个字符的字符串。 </span><br><span class="line"></span><br><span class="line">BLOB:用于 BLOBs (Binary Large OBjects)。存放最多 65,535 字节的数据。</span><br><span class="line"></span><br><span class="line">MEDIUMTEXT:存放最大长度为 16,777,215 个字符的字符串。</span><br><span class="line"></span><br><span class="line">MEDIUMBLOB:用于 BLOBs (Binary Large OBjects)。存放最多 16,777,215 字节的数据。</span><br><span class="line"></span><br><span class="line">LONGTEXT:存放最大长度为 4,294,967,295 个字符的字符串。</span><br><span class="line"></span><br><span class="line">LONGBLOB:用于 BLOBs (Binary Large OBjects)。存放最多4,294,967,295 字节的数据</span><br><span class="line"></span><br><span class="line">ENUM(x,y,z,etc.)：允许你输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。</span><br><span class="line">注释：这些值是按照你输入的顺序存储的。</span><br><span class="line">可以按照此格式输入可能的值：ENUM(&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;)</span><br><span class="line"></span><br><span class="line">SET：与 ENUM 类似，SET 最多只能包含 64 个列表项，不过 SET 可存储一个以上的值。 |</span><br></pre></td></tr></table></figure>
<p> Number 类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TINYINT(size)：-128 到 127 常规。0 到 255 无符号*。在括号中规定最大位数。</span><br><span class="line"></span><br><span class="line">SMALLINT(size)：-32768 到 32767 常规。0 到 65535 无符号*。在括号中规定最大位数。</span><br><span class="line"></span><br><span class="line">MEDIUMINT(size)：-8388608 到 8388607 普通。0 to 16777215 无符号*。在括号中规定最大位数。</span><br><span class="line"></span><br><span class="line">INT(size)：-2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数。</span><br><span class="line"></span><br><span class="line">BIGINT(size)：-9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。</span><br><span class="line"></span><br><span class="line">FLOAT(size,d)：带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。</span><br><span class="line"></span><br><span class="line">DOUBLE(size,d)：带有浮动小数点的大数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。</span><br><span class="line"></span><br><span class="line">DECIMAL(size,d)：作为字符串存储的 DOUBLE 类型，允许固定的小数点。</span><br></pre></td></tr></table></figure>
<ul>
<li>这些整数类型拥有额外的选项 UNSIGNED。通常，整数可以是负数或正数。如果添加 UNSIGNED 属性，那么范围将从 0 开始，而不是某个负数。</li>
</ul>
<p>Date 类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATE() : 日期。格式：YYYY-MM-DD</span><br><span class="line">注释：支持的范围是从 &apos;1000-01-01&apos; 到 &apos;9999-12-31&apos;</span><br><span class="line"></span><br><span class="line">DATETIME() : *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS</span><br><span class="line">注释：支持的范围是从 &apos;1000-01-01 00:00:00&apos; 到 &apos;9999-12-31 23:59:59&apos;</span><br><span class="line"></span><br><span class="line">TIMESTAMP() : *时间戳。TIMESTAMP 值使用 Unix 纪元(&apos;1970-01-01 00:00:00&apos; UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS</span><br><span class="line">注释：支持的范围是从 &apos;1970-01-01 00:00:01&apos; UTC 到 &apos;2038-01-09 03:14:07&apos; UTC</span><br><span class="line"></span><br><span class="line">TIME() : 时间。格式：HH:MM:SS 注释：支持的范围是从 &apos;-838:59:59&apos; 到 &apos;838:59:59&apos; </span><br><span class="line"></span><br><span class="line">YEAR() : 2 位或 4 位格式的年。</span><br><span class="line">注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。</span><br></pre></td></tr></table></figure>
<p>三、模式与表</p>
<p>每一个基本表都属于某一个模式，一个模式包含多个基本表<br>定义表所属的模式，有三种方法</p>
<ul>
<li><p>方法一：在表明中给出模式名<br>CREATE table “S-T”.Student(…..);  　　　/<em>   Student所属的模式是S-T</em>/<br>CREATE table “S-T”.Course(……); 　　　/<em>   Course所属的模式是S-T</em>/<br>CREATE table “S-T”.SC(…….); 　　　　 /<em>  SC所属的模式是S-T</em> /</p>
</li>
<li><p>方法二：在创建模式语句中同时创建表，在定义模式的例子里可以看到</p>
</li>
<li><p>方法三：设置所属的模式，这样创建表时不用给出模式名</p>
</li>
</ul>
<p>当用户创建基本表的时候没指定模式，那么系统会搜索路径来确定所属模式，如果路径包含一组模式列表，则使用第一个存在的模式作为对象的模式名。如果路径中的模式名都不存在，系统就给出错误。</p>
<p>四、修改基本表</p>
<p>SQL语言用ALTER TABLE来修改基本表，一般格式为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">ADD</span> &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]];</span><br><span class="line">[<span class="keyword">DROP</span> &lt;完整性约束名&gt;];</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span>&lt;列名&gt; &lt;数据类型&gt;];</span><br></pre></td></tr></table></figure></p>
<p>&lt;表名&gt;是要修改的基本表，ADD子句用于增加新列和新的完整性约束，DROP子句用于删除指定的完整性约束条件，ALTER COLUMN 子句用于修改原有的列定义，包括列名和数据类型</p>
<p>例子：向Student表中增加“入学时间”列，其数据类型为日期型</p>
<p>ALETER TABLE Student ADD_S_ENTRANCE DATE;</p>
<p>不论基本表是否原来有数据，新增加的一列均为日期型</p>
<p>五、删除基本表</p>
<p>当某个表不再需要时，用DROP TABLE语句删除它，格式为</p>
<p>DROP TABLE &lt;表名&gt; [ RESTRICT | CASCADE ];</p>
<p>若选择RESTRICT，则该表的删除是有限制条件,不能被其他表的约束所引用，也不能有视图，触发器，存储过程或函数等</p>
<p>若选择CASCADE，则没有限制条件，删除基本表的时候，相关的依赖对象也会一起删除，例如视图等</p>
<p>缺省的情况的是RESTRICT。</p>
<p>例子：删除Student表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> Student <span class="keyword">CASCADE</span>；</span><br></pre></td></tr></table></figure>
<p>基本表定义一旦被删除，不仅表中数据和定义被删除，而且表上建立的索引、视图、触发器等有关对象也一般会被删除。所以执行该操作需要特别小心</p>
<hr>
<h3 id="索引的建立与删除"><a href="#索引的建立与删除" class="headerlink" title="索引的建立与删除"></a>索引的建立与删除</h3><p>建立索引是加快查询速度的有效手段，根据需要，在基本表上建议一个或者多个的索引，以提供多种存取路径，加快查找速度。<br>但是索引也有不适宜的情况，原因是建立索引后，更新索引上的数据时会导致表中记录的物理顺序的变更，代价较大，且会占用一定的系统资源，因此对于经常更新的列不宜建立索引。</p>
<p>建议建立索引的情况：</p>
<ul>
<li>主码和外码一般会建立索引</li>
<li>以读为主或只读的表，只要空间允许可以建立多个索引</li>
<li>等值查询，且满足条件的元组数小于总元组数的5%，可以考虑在相关属性上建立索引</li>
<li>范围查询</li>
</ul>
<p>不建议建立索引的情况：</p>
<ul>
<li>不出现或很少出现查询的属性</li>
<li>属性值很少的属性</li>
<li>属性值分布严重不均的属性</li>
<li>经常更新的属性或表</li>
<li>过长的属性</li>
<li>太小的表</li>
</ul>
<p>一般建立与删除索引是有数据库管理员或者表的属主（owner），即建立表的人完成。系统存取数据时自动选择合适的索引作为存取路径，用户不必也不能显式的选择索引 。</p>
<p>一、建立索引</p>
<p>建立索引的一般格式为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>][cluster]<span class="keyword">index</span>&lt;索引名&gt;</span><br><span class="line"><span class="keyword">on</span> &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]...);</span><br></pre></td></tr></table></figure>
<p>其中，表名是要建立索引的基本表的名字。索引可以建立在一列或多列上，每个&lt;列名&gt;后面还可以用&lt;次序&gt;指定索引值的排列次序，可选ASC（升序）或DESC（降序），缺省值为ASC。<br>unique表示此索引的每一个索引值只对应唯一的数据记录。<br>cluster表示要建立的索引是聚簇索引。所谓聚簇索引是指索引项的数据与表中记录的物理顺序一致的索引组织。</p>
<p>例：在Student表上的姓名列建立一个聚簇索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> cluster <span class="keyword">index</span> Stusname</span><br><span class="line"><span class="keyword">on</span> Student(Sname);</span><br></pre></td></tr></table></figure>
<p>例：在sc表的Sno(升序), Cno(升序)和grade (降序)三列上建立一个普通索引SCno。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> SCno</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">table</span> SC(Sno,Cno,Grade <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure>
<p>二、删除索引</p>
<p>索引一旦建立，就由系统使用和维护它，不需要用户干预。建立索引是为了减少查询操作的时间。但如果数据增删改查频繁，就会浪费很多时间来维护索引，从而降低了查询效率，可以通过删除一些不必要的索引。 </p>
<p>删除索引的一般格式为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span>&lt;索引名&gt;;</span><br></pre></td></tr></table></figure>
<p>例：删除Student表上的Stusname索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> Stusname;</span><br></pre></td></tr></table></figure>
<p>删除索引时，系统会同时从数据字典中删去有关该索引的描述。</p>
<p>在RDBMS中索引一般采用B+树，HASH索引来实现，B+树索引具有动态平衡的优点。HSAH索引具有查找速度快的特点。索引是关系数据库的内部实现技术，属于内模式的范畴。</p>
<p>用户使用CREATE INDEX 语句定义索引的时候，可以定义索引是唯一索引、非唯一索引或者聚簇索引。至于某一个索引是采用B+树还是HASH索引则由具体的RDBMS来决定。</p>
<h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p>数据库查询是数据库的核心操作</p>
<p>一般格式为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [ALL | <span class="keyword">DISTINCT</span>] &lt;目标列表达式&gt;  [，&lt;目标列表达式&gt;]  ...</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名或者视图名&gt; [，&lt;表名或者视图名&gt;] ....</span><br><span class="line">[<span class="keyword">WHERE</span> &lt;条件表达式&gt;] </span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;列名<span class="number">1</span>&gt;[<span class="keyword">HAVING</span> &lt;条件表达式&gt;] ]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;列名<span class="number">2</span>&gt; [ <span class="keyword">ASC</span> | <span class="keyword">DESC</span> ] ]；</span><br></pre></td></tr></table></figure>
<p>根据where子句的条件表达式，从from子句指定基本表或者视图找出满足条件的元组，再按select子句中的目标列表达式，选出元组的属性值形成结果表</p>
<p>如果有group by子句，则将结果按&lt;列名1&gt;的值进行分组，该属性列值相等的元组为一个组。通常用在每组中作用聚集函数。如果group by子句滴啊有having短语，则只有满足指定条件的组才予以输出。</p>
<p>如果有order by子句，则结果表还要按照&lt;列名2&gt;的值升序或者降序排序。</p>
<hr>
<h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>单表查询是指仅涉及一个表的查询</p>
<p>一、选择表中的若干列</p>
<p>选择表中的全部列或者部分列，就是关系代数的投影运算</p>
<ol>
<li><p>查询制定列<br>在很多情况下，用户只需要一部分属性列，通过在select子句&lt;目标列表达式&gt;中指定要查询的属性列。<br>例子1 查询全体学生的学号和姓名。</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno ,Sname</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>该语句的执行过程：从Student表中取出一个元组，在该元组属性Sno和Sname上取值，形成一个新的元组走位输出。对表中所有元组做相同的处理，最后形成一个结果关系作为输出。

例子2

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname ,Sno ,Sdept</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure>


&lt;目标列表达式&gt;中各个列的先后顺序可以与表中的顺序不一致，根据需要改变列的显示顺序。
</code></pre><ol>
<li><p>查询全部列<br>将表中所有属性列出来，两种方法<br>第一种是在关键字后面把所有列都列出来<br>第二种就是指定为 * 这个符号。<br>例子：查询全体学生详细记录。</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br></pre></td></tr></table></figure>
<p> 等价于</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">SELECT</span> Sno ,Sname,Ssex ,Sage, Sdept</span><br><span class="line"><span class="keyword">FROM</span> Studetn;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询经过计算的量<br>SELECT 子句的&lt;目标列表达式&gt;不仅可以是表中的属性列，也可以是表达式</p>
<p> 例子：查询全体学生的姓名及其出生年份</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname ,<span class="number">2004</span>- Sage        <span class="comment">/*查询结果的第二列是一个算术表达式*/</span></span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure>
<p> 例子 查询全体学生的姓名、出生年份和所在院系，要求用小写字母表示所有系名</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname ,<span class="string">'Year of Birth:'</span>  <span class="number">2004</span>-Sage ,<span class="keyword">LOWER</span> (Sdept)</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure>
<p> 结果为</p>
<p> Sname  　　　‘Year of Birth:’　　 　2004-Sage　　　　　LOWER (Sdept)<br> ————————————————————————————————————<br> 刘勇　　　　‘Year of Birth:’　　　　　1984　　　　　　　　cs<br> 刘晨　　　　‘Year of Birth:’　　　　　1985　　　　　　　　cs<br> 王敏　　　　‘Year of Birth:’　　　　　1986　　　　　　　　ma<br> 张立　　　　‘Year of Birth:’　　　　　1985　　　　　　　　is<br> ————————————————————————————————————</p>
<p> 还可以通过指定别名来改变查询结果的列标题<br> 修改如下</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname ,<span class="string">'Year of Birth:'</span> BIRTH ,<span class="number">2004</span>-Sage BIRTHDAY,<span class="keyword">LOWER</span> (Sdept) DEPARTMENT</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure>
<p> 结果为</p>
<p> Sname  　　 　BIRTH　　 　 　　　BIRTHDAY　　　　　DEPATMENT<br> ————————————————————————————————————<br> 刘勇　　　　‘Year of Birth:’　　　　　1984　　　　　　　　cs<br> 刘晨　　　　‘Year of Birth:’　　　　　1985　　　　　　　　cs<br> 王敏　　　　‘Year of Birth:’　　　　　1986　　　　　　　　ma<br> 张立　　　　‘Year of Birth:’　　　　　1985　　　　　　　　is<br> ————————————————————————————————————</p>
</li>
</ol>
<p>二、选择表中的若干元组</p>
<ol>
<li>消除取值重复的行<br>两个本来并不完全相同的元组，投影到制定的某些列上后，就可能变成了相同的行了，可以用DISTINCT取消他们。</li>
</ol>
<p>例子 查询选修了课程的学生学号</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br></pre></td></tr></table></figure>
<p>输出结果为：<br>　　Sno<br>——————<br>200215121<br>200215121<br>200215121<br>200215122<br>200215122</p>
<p>如果为了去掉重复的行，必须制定DISTINCT关键词</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br></pre></td></tr></table></figure>
<p>输出结果为<br>　　Sno<br>——————<br>200215121<br>200215122</p>
<p>如果没有指定DISTINCT关键词，那么缺省为ALL，则保留结果中重复的行</p>
<ol>
<li>查询满足条件的元组<br>查询满足指定条件的元组可以通过where子句实现，</li>
</ol>
<p>　　　　　　　　　　　　　　　　常用的查询条件<br>——————————————————————————————————————<br>查询条件　　　　　　　　　　　　　谓词　　　　　　　　　　　　　　　<br>——————————————————————————————————————<br>比较　　　　　　　　=，&gt;，&lt;,&lt;=,&gt;=,!=,&lt;&gt;,!&gt;,!&lt;;NOT + 上述比较运算符<br>确定范围　　　　　　BETWEEN AND,NOT BETWWEN AND<br>确定集合　　　　　　IN, NOT IN<br>字符匹配　　　　　　LIKE , NOT LIKE<br>空值　　　　　　　　IS NULL , IS NOT NULL<br>多重条件（逻辑运算） AND, OR , NOT<br>——————————————————————————————————————</p>
<p>（1）比较大小<br>用于进行比较的运算符一般包括<br>=（等于），&gt;（大于），&lt;（小于）, &lt;=（小于等于）, &gt;=（大于等于）,!=（不等于）或  &lt;&gt;（不等于）, !&gt;（不大于）, !&lt;（不小于）;</p>
<p>（2）确定范围<br>谓词BETWEEN…AND….相对谓词是NOT BETWEEN …ADN….</p>
<p>例子 查询年龄不在20~23之间的学生姓名、系别和年龄</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname ,Sdept,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">23</span>;</span><br></pre></td></tr></table></figure>
<p>（3）确定集合<br>谓词IN可以用来查找属性值属于指定集合的元组</p>
<p>例子 查询计算机科学系（CS）、数学系（MA）和信息系（IS）学生的姓名和性别<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname ,Ssex</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="keyword">IN</span>(<span class="string">'CS'</span> , <span class="string">'MA'</span> , <span class="string">'IS'</span>);</span><br></pre></td></tr></table></figure></p>
<p>（4）字符匹配<br>谓词LIKE可以用来进行字符串的匹配，一般格式为：<br>[NOT] LIKE ‘&lt;匹配符&gt;’ [ESCAPE’ &lt;换码字符&gt;’]<br>其含义是查找指定的属性列值与&lt;匹配串&gt;相匹配的元组。&lt;匹配串&gt;可以是一个完整的字符串，也可以是含有通配符%和 _ 其中：</p>
<ul>
<li>% (百分号)代表任意长度的字符串,例如a%b表示以a开头，以b结尾的任意长度的字符串，如acb、addgb、ab等都满足该匹配</li>
<li>_ (下横线)代表任意单个字符，例如 a_b表示以a开头，以b结尾的的长度为3的任意字符串，如acb、adb、asb等都满足。注意的是一个汉字占用两个字符。所以匹配汉字的时候需要两个下横线。</li>
</ul>
<p>例子 ： 查询学号为200212121的学生的详细情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Soo <span class="keyword">LIKE</span> <span class="string">'200215121'</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">等价于</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">sql</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno =<span class="string">'200215121'</span></span><br></pre></td></tr></table></figure>
<p>如果like后面的匹配串不含通配符，则可以用 =（等于）运算符取代like谓词，用！=或&lt;&gt; 运算符取代NOT LIKE</p>
<p>如果用户查询的字符串本身就含有通配符 % 或 _ ,这时候就要用escape ‘&lt;换码字符&gt;’短语，对通配符进行转义了。</p>
<p>例子</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Cno,Ceredit</span><br><span class="line"><span class="keyword">FROM</span> Course</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="keyword">LIKE</span> <span class="string">'DB\_Design'</span> ESCAPE <span class="string">'\' ;</span></span><br></pre></td></tr></table></figure>
<p>这里就是escape ‘\’表示把’\’表示为转码字符，这样匹配串中紧跟在 ‘\’ 后面的字符 ‘_’ 不在具有通配符的含义<br>转义为普通的  ‘_’ 字符</p>
<p>（5）涉及空值的查询<br>例：某些学生选修课程后没有参加考试，所以有选课记录没有考试成绩，查询缺少成绩的学生的学号和相应的课程号</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno , Cno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="keyword">IS</span> NULLL  <span class="comment">/*  分数是grade是空值*/</span></span><br></pre></td></tr></table></figure>
<p>这里的IS不能用 = 来代替</p>
<p>（6）多重条件查询<br>逻辑运算符AND 和OR可用联结多个查询条件，AND 的优先级高于OR，但用户可以用括号来改变优先级</p>
<p>例  查询计算机科学系年龄在20岁以下的学生姓名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept = <span class="string">'CS'</span> <span class="keyword">AND</span> Sage &lt;<span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>三、 ORDER BY子句</p>
<p>用户可以用ORDER BY子句对查询结果按照一个或者多个属性的升序（ASC）或降序（DESC）排列，缺省值为升序</p>
<p>例 查询小选修了3号课程的学生的学号和成绩，查询结果按分数的降序排列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Grade</span><br><span class="line"><span class="keyword">FROM</span> SC </span><br><span class="line"><span class="keyword">WHERE</span> Cno=<span class="string">'3'</span></span><br><span class="line">RODER <span class="keyword">BY</span> Grade <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>对于空值，若按升序排，含空值的元组将最后显示，若按降序排，空值的元组将最先显示。</p>
<p>四、 聚集函数 （aggregate functions）</p>
<p>为了增强检索功能，sql提供许多聚集函数</p>
<p>1 count : 行数</p>
<p>2 sum : 总和 （求总和）</p>
<p>3 avg : 平均值 </p>
<p>4 max 最大值</p>
<p>5 min : 最小值</p>
<p>例： 查询选修了课程的学生人数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span> (<span class="keyword">DISTINCT</span> Sno)</span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br></pre></td></tr></table></figure>
<p>学生每选修一门课，在sc中都有一条相应的记录，一个学生要选修多门课程，为避免重复计算学生人数，必须在count函数中用distinct短语</p>
<p>例：计算1号课程的学生平均成绩</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span> (Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno= <span class="string">'1'</span>;</span><br></pre></td></tr></table></figure>
<p>例： 查询学生200215012选修课程的总分数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(Ceredit)</span><br><span class="line"><span class="keyword">FROM</span> SC ,Course</span><br><span class="line"><span class="keyword">WHERE</span> Sno= <span class="string">'200215012'</span> <span class="keyword">AND</span> SC.Cno=Course.Cno</span><br></pre></td></tr></table></figure>
<p>在聚集函数遇到空值时，除COUNT(*)外，都跳过空值而处理非空值</p>
<p>五、GROUP BY子句</p>
<p>GROUP BY 子句将查询结果按某一列或多列的值分组，值相等的为一组<br>对查询结果分组的目的是为了细化聚集函数的作用对象，如果未对查询结果分组，聚集函数将作用于整个查询结果。</p>
<p>例子 查询各个课程号及其相应的选课人数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Cno ,<span class="keyword">COUNT</span> (Sno)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Cno;</span><br></pre></td></tr></table></figure>
<p>该语句是对查询结果按Cno的值分组，所有具有相同Cno值的元组为一组，对每一组进行聚集函数count计算，以求得该组的学生人数</p>
<p>查询结果可能为</p>
<p>Cno　　　　　　　　COUNT(Sno)<br>————————————————————————————<br> 　1　　　　　　　　　　22<br>　 2　　　　　　　　　　34<br>　 3　　　　　　　　　　44<br>　 4　　　　　　　　　　33<br>　 5　　　　　　　　　　48<br>————————————————————————————</p>
<p>如果分组后还要按照一定的条件去进行筛选，最终只输出满足指定条件的组，则可以使用HAVING 短语指定筛选条件</p>
<p>查询选修了3门以上的课程的学生学号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno</span><br><span class="line">FROM SC</span><br><span class="line">GROUP BY Sno</span><br><span class="line">HAVING COUNT (*) &gt;3;</span><br></pre></td></tr></table></figure>
<p>先用group by按Sno进行分组，再用聚集函数COUNT对每一组计算。HAVING短语给出了选择组的条件，且只有满足条件（即元组个数&gt;3），表示此学生选修的课超过3门的才会选出来</p>
<p>WHERE子句与HAVING子句区别在于作用对用不同，WHRE子句作用于基本表或视图，从中选择满足条件的与阿奴，HAVING短语作用于组，从中选择满足条件的组。</p>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>若查询同时设计到两个以上的表，则称之为连接查询</p>
<p>连接查询是关系数据库中最主要的查询，包括了等值连接查询，自然连接查询，非等值连接查询，自身连接查询，外连接查询和符合条件连接查询等</p>
<p>一、 等值与非等值连接查询</p>
<p>连接查询的WHERE子句用来连接两个表的条件称为 连接条件 或 连接谓词，起一般格式为：</p>
<p>[&lt;表名1&gt;] &lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;]&lt;列名2&gt;</p>
<p>其中比较运算符主要有： =、&gt;、&lt; 、 &gt;= 、&lt;=、 != (或&lt;&gt;)</p>
<p>还可以用以下格式：<br>[&lt;表名1&gt;] &lt;列名1&gt; BETWEEN [&lt;表名2&gt;]&lt;列名2&gt; AND [&lt;表名2&gt;]&lt;列名3&gt;</p>
<p>当连接运算符为 = 时，称为等值连接，使用其他运算符时为非等值连接</p>
<p>连接谓词中的列名称为连接字段，连接条件中的各连接字段类型必须是可比的，但名字不必相同。</p>
<p>例子 查询每个学生及其选修课程的情况</p>
<p>学生情况存放在Student表中，学生选课情况存在SChema表中，所以本查询实际上涉及Student和SC两个表， 这两个表之间的联系是通过公共属性Sno实现的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student *  , SC . *  </span><br><span class="line"><span class="keyword">FROM</span>  Student ,SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno =SC.Sno;     <span class="comment">/* 将Student和SC中同一个学生的元组连接起来*/</span></span><br></pre></td></tr></table></figure>
<p>假设 Student表和SC表的数据如上面 学生-课程数据库的表一样</p>
<p>那么执行结果如下：</p>
<p>Student.Sno 　Sname　Ssex 　Sage 　Sdept　　SC.Sno　　Cno　Grade<br>————————————————————————————————————<br>200215121　　李勇　    男　　　20　　CS　　200215121 　 1　　92<br>200215121　　李勇　 男　　　20　　CS　　200215121 　 2　　85<br>200215121　　李勇　    男　　　20　　CS　　200215121 　 3　　88<br>200215122　　刘晨　    女　　　19　　CS　　200215122 　 2　　90<br>200215122　　刘晨　    女　　　19　　CS　　200215122 　 3　　80<br>————————————————————————————————————</p>
<p>在本例中中，select子句与where子句中的属性名前都加上了表名前缀，为了避免混淆，如果属性名在参加连接的各表中是唯一的，则可以省略表名前缀。</p>
<p>RDBMS执行该连接操作的一种可能过程是：<br>首先在表Student中找第一个元组，就开始扫描SC表，查找与Student第一个元组的Sno相等的SC元组，找到后将Student中第一个元组与该元组拼接起来，形成结果表中的一个元组，SC中全部查找完后，再找Student中第二个元组，不断的重复上述操作。这是嵌套循环算法的基本思想。</p>
<p>如果在SC表Sno上建立索引的话，就不用每次全表扫描SC表了，二十根据Sno值通过索引找到相应的SC元组，用索引查询SC中满足条件的元组一般比全表扫描快。</p>
<p>若在等值连接中把目标列中重复的属性列去掉则为自然连接。</p>
<p>对上例子用自然连接完成。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student Sno,Sname,Ssex,Sage,Sdept,Cno,Grade</span><br><span class="line"><span class="keyword">FROM</span> Student ,SC</span><br><span class="line"><span class="keyword">WHERE</span> Student , Sno = SC.Sno;</span><br></pre></td></tr></table></figure>
<p>二、自身连接</p>
<p>连接操作不仅可以在两个表之间进行，<br>也可以是一个表与其自己进行连接，称为表的自身连接<br>需要给表</p>
<p>例 查询每一门课的间接先修课（即先修课的先修课）</p>
<p>在Course表中，只有每门课的直接先修课信息，而没有先修课的先修课。要得到这个信息，必须对一门课找到其先修课，再按此先修课的课程号，查找它的先修课程。这就要将Course表与其自身连接。</p>
<p>为此，要为Course表取两个别名，一个是FIRST，另一个是SECOND</p>
<p>FIRST表（Course表）<br>——————————————————————————————————————<br>Cno　　　　　Cname　　　　　　Cpno　　　　　　Ccredit<br>　 1　　　　　数据库　　　　　　　 5 　　　 　　 　　4<br>　 2　　　　　　数学　　　　　 　　 　 　　 　  　  　　2<br>　 3　　　　　信息系统　　　　 　　1 　　　 　　 　　4<br>　 4　　　　　操作系统　　　　 　　6 　　　 　　 　　3<br>　 5　　　　　数据结构　　　　 　　7 　　　 　　 　　4<br>　 6　　　　　数据处理　　　　 　　 　 　　 　  　  　　2<br>　７　　　　　PASCAL　　 　　 　　 6 　　　 　　 　　4<br>——————————————————————————————————————</p>
<p>SECOND表 （Course表）<br>——————————————————————————————————————<br>Cno　　　　　Cname　　　　　　Cpno　　　　　　Ccredit<br>　 1　　　　　数据库　　　　　　　 5 　　　 　　 　　4<br>　 2　　　　　　数学　　　　　　　 　 　　 　  　  　　2<br>　 3　　　　　信息系统　　　　 　　1 　　　 　　 　　4<br>　 4　　　　　操作系统　　　　 　　6 　　　 　　 　　3<br>　 5　　　　　数据结构　　　　 　　7 　　　 　　 　　4<br>　 6　　　　　数据处理　　　　　　 　 　　 　  　  　　2<br>　７　　　　　PASCAL　　 　　 　　 6 　　　 　　 　　4<br>——————————————————————————————————————</p>
<p>完成该查询的SQL语句为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FIRST</span> Cno ,second.Cpno</span><br><span class="line"><span class="keyword">FROM</span> Course <span class="keyword">FIRST</span> , Course <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">FIRST</span> Cpno =SECOND.Cno</span><br></pre></td></tr></table></figure>
<p>结果为</p>
<p>Cno　　　　Pcno<br>————————————<br>1　　　　　　7<br>3　　　　　　5<br>5　　　　　　6</p>
<p>三、外连接</p>
<p>一般来说，只有满足连接条件的元组才会作为结果输出，例如上面的输出结果没有200215123和200215125两个学生的信息，是因为没有选课，在SC中没有相应的元组，在Student这些元组在连接时就被舍弃了。</p>
<p>如果还想以Student表为主体列出每个学生的基本情况及其选课情况，其中某个学生没有选课，仍把舍弃的Student元组保存在结果关系中，而在SC表的属性上填空值（null），这时候就需要外连接。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student ,Sno, Sname,Ssx,Sage,Sdept,Cno,Grade</span><br><span class="line"><span class="keyword">FROM</span> Student <span class="keyword">LEFT</span> <span class="keyword">OUT</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span>(Student.Sno = SC.Sno)</span><br><span class="line"><span class="comment">/*也可以使用USING来去掉结果中的重复值；</span></span><br><span class="line"><span class="comment">	FROM Student LEFT OUT JOIN SC USING （Sno）； */</span></span><br></pre></td></tr></table></figure>
<p>执行结果如下</p>
<p>Student.Sno 　Sname　Ssex 　Sage 　Sdept　　SC.Sno　　　Cno　　Grade<br>————————————————————————————————————————<br>200215121　　李勇　    　男　　　20　　CS　　200215121 　　 1　 　 　92<br>200215121　　李勇　    　男　　　20　　CS　　200215121 　　 2　 　 　85<br>200215121　　李勇　    　男　　　20　　CS　　200215121 　　 3　 　 　88<br>200215122　　刘晨　    　女　　　19　　CS　　200215122 　　 2　 　 　90<br>200215122　　刘晨　    　女　　　19　　CS　　200215122 　　 3　 　 　80<br>200215123　　王敏　    　女　　　18　　MA　　200215122　　NULL　　NULL<br>200215125　　张立　    　男　　　19　　 IS 　　200215122　　NULL　　NULL<br>————————————————————————————————————————</p>
<p>左外连接列出左边关系（如本利Student）中所有的元组，右外连接列出关系中所有的元组。</p>
<p>四、复合条件连接</p>
<p>在上面各个连接查询中，where子句中只有一个条件，即连接谓词，where子句中可以有多个连接条件，称为复合条件连接</p>
<p>例　查询选修２号课程且成绩在90分以上的所有学生</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno,Sname</span><br><span class="line"><span class="keyword">FROM</span> Student.SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno= SC.Sno <span class="keyword">AND</span>      <span class="comment">/* 连接谓词 */</span></span><br><span class="line">	SC.Cno=<span class="string">'2'</span> <span class="keyword">AND</span> SC.Grade&gt;<span class="number">90</span>;      <span class="comment">/* 其他限定条件 */</span></span><br></pre></td></tr></table></figure>
<p>该查询的一种优化（高效）的执行过程是先从SC中挑选出Cno=’2’ 并且 Grade&gt;90的元组形成一个中间关系，再和Student中满足连接条件的元组进行连接得到最终的结果关系。</p>
<p>连接操作除了可以是两表连接，一个表与自身连接外，还可以是两个以上的表进行连接，后者通常称为多表连接。</p>
<p>查询每个学生的学号、姓名、选修的课程号及成绩<br>本查询涉及三个表，查询语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student,Sno , Sname ,Cname ,Grade</span><br><span class="line"><span class="keyword">FROM</span> Student , SC , Course</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno  = SC.Sno <span class="keyword">AND</span> SC.Cno =Course.Cno;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>在SQL语言中， 一个SELECT-FROM -WHERE语句称为一个查询块，将一个查询块嵌套在另一个查询块的where子句或having短语条件中的查询称为嵌套查询。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname             <span class="comment">/*外层查询或者父查询*/</span>             </span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">IN</span> </span><br><span class="line">	(<span class="keyword">SELECT</span> Sno         <span class="comment">/* 内层查询或者子查询 */</span>   </span><br><span class="line">  	 <span class="keyword">FROM</span> SC</span><br><span class="line">  	 <span class="keyword">WHERE</span> Cno=<span class="string">'2'</span>);</span><br></pre></td></tr></table></figure>
<p>SQL语言支持多层嵌套查询，即一个子查询里还可以嵌套其他子查询。<br>但是注意：子查询的select语句中不能使用order by子句，order by子句只能对最终查询结果排序。</p>
<p>以层层嵌套的方式来构造程序正是SQL中“结构化”的含义所在。</p>
<p>一、带有IN谓词的子查询<br>在嵌套查询中，子查询的结果往往是一个集合，所以谓词IN是嵌套查询中最经常使用的谓词。</p>
<p>例：查询与“刘晨”在同一个系的学生。</p>
<p>先分步完成此查询，然后再构造嵌套查询。<br>①确定“刘晨”所在系名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sdept</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sname= <span class="string">'刘晨'</span>；</span><br></pre></td></tr></table></figure>
<p>结果为：CS</p>
<p>②查找所有在CS系学习的学生</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno ,Sname ,Sdept</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept =<span class="string">'CS'</span>;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p>Student.Sno 　Sname 　Sdep<br>——————————————————<br>200215121　　李勇　　CS<br>200215122　　刘晨　　CS<br>——————————————————</p>
<p>将第一步查到嵌入到第二步查询的条件中，构造嵌套查询如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno , Sname ,Sdept</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="keyword">IN</span></span><br><span class="line">	(<span class="keyword">SELECT</span> Sdept</span><br><span class="line">	 <span class="keyword">FROM</span> Student</span><br><span class="line">	 <span class="keyword">WHERE</span> Sname=<span class="string">'刘晨'</span>);</span><br></pre></td></tr></table></figure>
<p>这个例子不依赖父查询，所以称为不相关子查询</p>
<p>二、带有比较运算符的子查询</p>
<p>带有比较运算符的子查询是指父查询与子查询之间用比较运算符进行连接，当用户能确切知道内层查询返回的单值时，可以用 &gt; , &lt; , = , &gt;= ,&lt;= ,!= 或&lt;&gt;等比较运算符。</p>
<p>比如刚刚上面的例子<br>查询与“刘晨”在同一个系的学生。<br>由于一个学生只能在一个系学习，也就是说内查询的结果是一个值，因此可以用‘=’来代替IN</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno , Sname ,Sdept</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept =</span><br><span class="line">	(<span class="keyword">SELECT</span> Sdept</span><br><span class="line">	 <span class="keyword">FROM</span> Student</span><br><span class="line">	 <span class="keyword">WHERE</span> Sname=<span class="string">'刘晨'</span>);</span><br></pre></td></tr></table></figure>
<p>注意的是子查询一定要跟在比较符之后，下面是错误语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno , Sname ,Sdept</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> (<span class="keyword">SELECT</span> Sdept</span><br><span class="line">	 <span class="keyword">FROM</span> Student</span><br><span class="line">	 <span class="keyword">WHERE</span> Sname=<span class="string">'刘晨'</span>)=Sdept;</span><br></pre></td></tr></table></figure>
<p>如果子查询条件依赖于父查询，这类子查询称为相关子查询，整个查询语句称为相关嵌套查询语句。</p>
<p>下面是相关嵌套查询</p>
<p>例： 找出每个学生超过他选修课平均成绩的课程号</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno ,Cno</span><br><span class="line"><span class="keyword">FROM</span> SC x</span><br><span class="line"><span class="keyword">WHERE</span> Grade &gt;= (<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(Grade)   <span class="comment">/* 某学生的平均成绩 */</span></span><br><span class="line">		<span class="keyword">FROM</span> SC y</span><br><span class="line">		<span class="keyword">WHERE</span> y.Sno =x.Sno);</span><br></pre></td></tr></table></figure>
<p>其中x是表SC的表名，又称为元组变量，可以用来表示SC的一个元组，内层查询是求一个学生所有选修课程平均成绩的，至于是哪个学生的平均成绩要看参数x.Sno的值，而该值是与父查询相关的，因此这类查询称为相关子查询。</p>
<p>该语句的一种可能的执行过程是：</p>
<ol>
<li>从外层查询中取出SC的一个元组x,将元组x的Sno值（200215121）传送给内层查询</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC y</span><br><span class="line"><span class="keyword">WHERE</span> y.Sno=<span class="string">'200215121'</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>执行内层查询，得到值88（近似值），用该值替代内层查询，得到外层查询</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Cno</span><br><span class="line"><span class="keyword">FROM</span> SC x</span><br><span class="line"><span class="keyword">WHERE</span> Grade =<span class="string">'200215121'</span></span><br></pre></td></tr></table></figure>
<ol>
<li>执行这个查询，得到<br>（200215121，1）<br>（200215121，3）<br>然后外层查询取出下一个元组重复做上述的操作，知道全部处理完毕。结果为<br>（200215121，1）<br>（200215121，3）<br>（200215122，2）</li>
</ol>
<p>三、带有ANY（SOME）或ALL谓词的子查询</p>
<p>子查询返回单值时可以用比较运算符，但返回多值时要用ANY（有的系统用SOME）或者ALL谓词修饰符，而使用ANY或ALL谓词时必须同时使用比较运算符，其语义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;  ANY 大于子查询结果中的某个值</span><br><span class="line"></span><br><span class="line">&gt; ALL  大于子查询结果中的所有值</span><br><span class="line"></span><br><span class="line">&lt; ANY 小于子查询结果中的某个值</span><br><span class="line"></span><br><span class="line">&lt; ALL 小于子查询结果中的所有值</span><br><span class="line"></span><br><span class="line">&gt;=  ANY  大于等于子查询结果中的某个值</span><br><span class="line"></span><br><span class="line">&gt;= ALL  大于等于子查询结果中的所有值</span><br><span class="line"></span><br><span class="line">&lt;= ANY 小于等于子查询结果中的某个值</span><br><span class="line"></span><br><span class="line">&lt;= ALL 小于等于子查询结果中的所有值</span><br><span class="line"></span><br><span class="line">= ANY 等于子查询结果中的某个值</span><br><span class="line"></span><br><span class="line">= ALL 等于子查询结果中的所有值（通常没有实际意义）</span><br><span class="line"></span><br><span class="line">!=(或&lt;&gt;) ANY 不等于子查询结果中的某个值</span><br><span class="line"></span><br><span class="line">!=(或&lt;&gt;) ALL 不等于子查询结果中的任何一个值</span><br></pre></td></tr></table></figure>
<p>例 ： 查询其他系中比计算机科学系某一学生年龄小的学生姓名和年龄</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage </span><br><span class="line"><span class="keyword">FROM</span> Student </span><br><span class="line"><span class="keyword">WHERE</span> Sage &lt; <span class="keyword">ANY</span> ( <span class="keyword">SELECT</span> Sage </span><br><span class="line">		   <span class="keyword">FROM</span> Student</span><br><span class="line">		   <span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span> ) </span><br><span class="line"><span class="keyword">AND</span> Sdept &lt;&gt; <span class="string">'CS'</span>;     <span class="comment">/* 这是父查询块中的条件 */</span></span><br></pre></td></tr></table></figure>
<p>结果如下：<br>Sname 　　Sage<br>——————————<br> 王敏　　　　18<br> 张立　　　　19</p>
<p>RDBMS 执行此查询时，首先处理子查询，找出CS系中所有学生的年龄，构成一个（20，19）集合，然后处理父查询，找所有不是CS系且年龄小于该集合中年龄的学生。</p>
<p>这个例子也可以用聚集函数实现，SQL如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname ,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage &lt;</span><br><span class="line">	    (<span class="keyword">SELECT</span> <span class="keyword">MIN</span> (Sage)</span><br><span class="line">	     <span class="keyword">FROM</span> Student</span><br><span class="line">	     <span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span>)</span><br><span class="line"><span class="keyword">AND</span> Sdept &lt;&gt; <span class="string">'CS'</span>;</span><br></pre></td></tr></table></figure>
<p>事实上，用聚集函数实现子查询通常比直接用ANY或ALL查询效率高。ANY，ALL与聚集函数的对应关系如表</p>
<img src="/posts/486c9009/54.png">
<p>四、带有EXISTS谓词的子查询<br>EXISTS代表存在量词 ，带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值‘true’或逻辑假值‘FALSE’</p>
<p>可以利用EXISTS来判断 x∈S ，S⊆R， S=R ，S∩R 非空等是否成立</p>
<p>例  查询所有选修了 1 号课程的学生姓名<br>该查询设计了Student表和SC表，可以在Student中依次取每个元组的Sno值，用此值去检查SC表，若SC中存在这一的元组，其Sno值等与此Student.Sno值，并且其Cno=‘1’，则取此Student.Sname送入结果表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">	(<span class="keyword">SELECT</span> *</span><br><span class="line">	 <span class="keyword">FROM</span> SC</span><br><span class="line">	 <span class="keyword">WHERE</span> Sno = Student.Sno <span class="keyword">AND</span> Cno=<span class="string">'1'</span>);</span><br></pre></td></tr></table></figure>
<p>使用存在量词EXISTS后，若内层查询结果非空，则外层的where子句返回真值，否则返回假值</p>
<p>由EXISTS引出的子查询，起目标列表达式通常用 * 号，因为带EXISTS的子查询只返回真价值，给出列名无实际意义。</p>
<p>本例中的查询条件是依赖于外层父查询的某个属性值（这里是STudent的Sno值）因此也是相关子查询，这个相关子查询的处理过程是：<br>首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值（Sno值）处理内层查询，若where子句返回值为真，则取外层查询中该元组的Sname放入结果表，然后再取（Student）表的下一个元组，重复这一过程，直至外层（Student表）全部检查完为止。</p>
<p>例 ： 查询至少选修了学生200215122选修的全部课程的学生号码<br>本查询可以用逻辑蕴含来表达：查询学号为x的学生，对所有的课程y，只要200215122学生选修了课程y,则x也选修了y，形式化表示如下：<br>用p表示谓词”学生200215122选修了课程“<br>用q表示谓词“学生x选修了课程y”<br>则上述查询为： （ ∀y ）p→q</p>
<p>但是SQL语言没有蕴含逻辑运算，但是可以利用谓词演算将一个逻辑蕴含的谓词等价转换为 p → q ≡ ¬ p ∨ q</p>
<p>该查询可以转换为如下等价形式：<br>（ ∀y ）p→q ≡ ¬（∃y（ ¬（p→q））≡¬（∃y（¬（¬p∨ q）≡ ¬ ∃y（p ∧ ¬q<br>））））</p>
<p>sql语言表达：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC SCX</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">	(<span class="keyword">SELECT</span> *</span><br><span class="line">	<span class="keyword">FROM</span> SC SCY</span><br><span class="line">	<span class="keyword">WHERE</span> SCY.Sno =<span class="string">' 200215122 '</span> <span class="keyword">AND</span></span><br><span class="line">		<span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">		(<span class="keyword">SELECT</span> *</span><br><span class="line">		<span class="keyword">FROM</span> SC SCZ</span><br><span class="line">		<span class="keyword">WHERE</span> SCZ.Sno=SCX.Sno <span class="keyword">AND</span></span><br><span class="line">			SCZ.Cno= SCY.Cno));</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="集合查询"><a href="#集合查询" class="headerlink" title="　集合查询"></a>　集合查询</h3><p>SELECT语句的查询结果是元组的集合，所以多个SELECT语句的结果可进行集合操作。集合操作的主要 并操作UNION、交操作INTERSECT和 差操作EXCEPT。<br>注意，参加集合操作的各查询结果的列数必须相同，对应项的数据类型也必须相同</p>
<p>例 查询计算机科学系的学生及年龄不大于19岁的学生</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept =<span class="string">'CS'</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage &lt;= <span class="number">19</span>;</span><br></pre></td></tr></table></figure>
<p>使用UNION将多个查询结果合并起来时，系统会自动去掉重复元组，如果要保留重复元组则用UNION ALL操作符</p>
<p>例 查询选修课程 1 的学生 或 选修课程2 的学生</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Cno =<span class="string">'1'</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Cno =<span class="string">'2'</span></span><br></pre></td></tr></table></figure>
<p>例 查询计算机科学系的学生与年龄不大于19岁的学生的交集</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept =<span class="string">'CS'</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage &lt;= <span class="number">19</span>;</span><br></pre></td></tr></table></figure>
<p>SELECT 语句的一般格式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  [ ALLDISTINCT ] &lt; 目标列表达式 &gt; [别名] [,&lt;目标列表达式&gt; [别名]] .......</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名或视图名&gt; [ 别名 ] [,&lt; 表名或视图名 &gt; [别名]] ......</span><br><span class="line">[<span class="keyword">WHERE</span> &lt; 条件表达式&gt;]</span><br><span class="line">&#123;<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;列名<span class="number">1</span>&gt; [ <span class="keyword">HAVING</span> &lt;条件表达式&gt;]]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;列名<span class="number">2</span>&gt; [ASCIDESC]];</span><br></pre></td></tr></table></figure>
<ol>
<li><p>目标列表达式有以下可选格式：<br>（1） <em><br>（2） &lt;表名&gt;.</em><br>（3） COUNT ([DISTINCT | ALL]<em>)<br>（4）[&lt;表名&gt;.] &lt;属性列名表达式&gt;[.[&lt;表名&gt;.]&lt;属性列名表达式&gt;]…..<br> 其中&lt;属性列表达式&gt;可以是由属性列，作用于属性列的聚集函数和常量的任意算术运算（+、-、</em>、/）组成的运算公式</p>
</li>
<li><p>聚集函数一般格式为：</p>
</li>
</ol>
<p>COUNT ↘<br> SUM 　　↘<br> AVG 　→→　([DISTINCT|ALL]&lt;列名&gt;)　<br> MAX 　 ↗<br> MIN ↗</p>
<ol>
<li>WHERE子句的条件表达式有以下可选格式</li>
</ol>
<p>（1）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　　 &lt;属性列名&gt;</span><br><span class="line">&lt;属性列名&gt;　θ  &lt; 常量 &gt;</span><br><span class="line">　　　　　 　　[ANY | ALL]（SELECT 语句）</span><br></pre></td></tr></table></figure></p>
<p>（2）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                          &lt;属性列名&gt;　　   &lt;属性列名&gt;</span><br><span class="line">&lt;属性列名&gt; [NOT]  BETWEEN  &lt;常量&gt;　　　AND    &lt;常量&gt;</span><br><span class="line">                          (SELECT语句）   &lt;SELECT语句&gt;</span><br></pre></td></tr></table></figure></p>
<p>（3）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  		     ↗(&lt;值1&gt; [,&lt;值2&gt;]....)　　 </span><br><span class="line">&lt;属性列名&gt; [NOT] IN </span><br><span class="line">  		    ↘ (SELECT 语句)</span><br></pre></td></tr></table></figure>
<p>（4）&lt;属性列名&gt; [NOT] LIKE &lt;匹配串&gt;</p>
<p>（5）&lt;属性列名&gt; IS [NOT] NULL</p>
<p>（6）[NOT] EXISTS (SELECT语句)</p>
<p>（7）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  	    AND                 AND</span><br><span class="line">&lt;条件表达式&gt;     [  &lt;条件表达式&gt;       &lt;条件表达式&gt;].....</span><br><span class="line">  	     OR                  OR</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><p>三种操作：添加，修改，删除</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>SQL插入语句INSERT通常两种形式：插入一个元组，插入子查询结果，其中后者可以一次插入多个元组。</p>
<p>一、 插入元组</p>
<p>格式为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> &lt;表名&gt; [ (&lt;属性列<span class="number">1</span>&gt;[,&lt;属性列<span class="number">2</span>&gt;]...)]</span><br><span class="line"><span class="keyword">VALUES</span> (&lt; 常量<span class="number">1</span> &gt; [,&lt; 常量<span class="number">2</span> &gt;]....);</span><br></pre></td></tr></table></figure>
<p>功能是将新元组插入指定表中，INTO子句中没有出现的属性列，新元组将取空值，但是表定义的时候，说明了NOT NULL的属性列不能取空值，否则会出错。<br>如果INTO子句中没有指明任何属性列名，则新插入的元组必须每个属性列上均有值</p>
<p>例  将一个新学生元组（学号：200215128；姓名：陈冬；性别：男；所在系：IS；年龄：18岁）插入到Student表中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> </span><br><span class="line"><span class="keyword">into</span> student(sno,sname,ssex,sdept,sage)</span><br><span class="line"><span class="keyword">values</span>( <span class="string">'200215128'</span> , <span class="string">'陈冬'</span>,<span class="string">'男'</span> , <span class="string">'is'</span> , <span class="number">18</span> );</span><br></pre></td></tr></table></figure>
<p>属性的顺序可以与CREATE TABLE 中的顺序不一样，VALUES子句对新元组的各属性赋值，字符串常数要用单引号括起来。</p>
<p>例 将学生张成民的信息插入到Student表中信息：‘200215126’ ‘张成民’ ‘男’ 18 ‘CS’</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> </span><br><span class="line"><span class="keyword">into</span> student</span><br><span class="line"><span class="keyword">values</span>( <span class="string">'200115126'</span> , <span class="string">'张成民'</span> , <span class="string">'男'</span> , <span class="string">'cs'</span> , <span class="number">18</span> );</span><br></pre></td></tr></table></figure>
<p>这个与上个例子不同的是没有指明属性名，所以新元组要在所有的属性列上都指定值，并且属性列顺序与CRAETE TABLE上的次序要相同。VALUES子句对新元组的各属性列赋值，一定要注意值与属性列要一一对应，赋值错会造成数据类型不同而出错。</p>
<p>例 插入一条选课记录( ‘200215128’，’1 ‘)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> </span><br><span class="line"><span class="keyword">into</span> SC（Sno,Cno）</span><br><span class="line"><span class="keyword">values</span>(<span class="string">'200215128'</span>,<span class="string">'1'</span>);</span><br></pre></td></tr></table></figure>
<p>RDBMS自动在新插入的记录Grade上赋空值</p>
<p>或者<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> </span><br><span class="line"><span class="keyword">into</span> sc</span><br><span class="line"><span class="keyword">values</span>(<span class="string">'200215128'</span>,<span class="string">'1'</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p>没有指定出SC的属性名，在Grade列上要明确给出空值</p>
<p>二、 插入子查询结果<br>子查询不仅可以嵌套在SELECT语句中，用以构造父查询的条件，也可以 嵌套在INSERT语句中，用以生成要插入的批量数据</p>
<p>插入子查询结果的INSERT语句的格式为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">INTO</span> &lt;表名&gt; [(&lt;属性列<span class="number">1</span>&gt; [,&lt;属性列<span class="number">2</span>&gt;]....) ]</span><br><span class="line">子查询;</span><br></pre></td></tr></table></figure>
<p>例 对每一个系，求学生的平均年龄，并把结果存入数据库。</p>
<p>首先在数据库中建立一个新表，其中一列存放系名，另一列存放相应的学生平均年龄。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept_age</span><br><span class="line">	(sdept <span class="built_in">char</span>(<span class="number">15</span>)</span><br><span class="line">	avg_age smllint);</span><br></pre></td></tr></table></figure></p>
<p>然后对Student表按系分组求平均年龄，再把系名和平均年龄存入新表中</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span></span><br><span class="line"><span class="keyword">into</span> dept_age(sdept,avg_age)</span><br><span class="line"><span class="keyword">select</span> sdept,<span class="keyword">avg</span>(sage)</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sdept;</span><br></pre></td></tr></table></figure>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>又称为更新操作 ，一般格式为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> &lt;表名&gt;</span><br><span class="line"><span class="keyword">SET</span> &lt;列名&gt; = &lt;表达式&gt; [,&lt;列名&gt; = &lt;表达式&gt; ]....</span><br><span class="line">[<span class="keyword">WHERE</span> &lt;&gt;];</span><br></pre></td></tr></table></figure>
<p>其功能是修改指定表中满足 WHERE子句条件的元组，其中set子句给出&lt;表达式&gt;的值用子取代相应的属性列值，如果省略where子句，则表示要修改表中的所有元组。</p>
<p>一、 修改某一个元组的值</p>
<p>例 将学生200215121的年龄改为22岁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> sage=<span class="number">22</span></span><br><span class="line"><span class="keyword">where</span> sno=<span class="string">'200212121'</span>;</span><br></pre></td></tr></table></figure>
<p>二、修改多个元组的值</p>
<p>例 将所有的学生年轻增加1岁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> sage= Sage+<span class="number">1</span>；</span><br></pre></td></tr></table></figure>
<p>三、带子查询的修改语句</p>
<p>子查询也嵌套在UPDATE语句中，用以构造修改的条件。<br>例  将计算机科学系全体学生的成绩置零</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> sc</span><br><span class="line"><span class="keyword">set</span> grade=<span class="number">0</span></span><br><span class="line"><span class="keyword">where</span> <span class="string">'cs'</span>=</span><br><span class="line">       (<span class="keyword">select</span> sdept</span><br><span class="line">        <span class="keyword">from</span> student</span><br><span class="line">        <span class="keyword">where</span> student.sno=sc.sno);</span><br></pre></td></tr></table></figure>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>格式为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> </span><br><span class="line"><span class="keyword">FROM</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">WHERE</span> &lt;条件&gt;];</span><br></pre></td></tr></table></figure>
<p>DELETE语句功能从指定表中删除满足where子句的所有元组，如果没有指定，那么就删除所有元组，但表的定义仍在字典中，delete语句删除的是表中的数据，而不是关于表的定义。</p>
<p>一、删除某一个元组的值</p>
<p>例 删除学号为200215128的学生记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> </span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno = <span class="string">'200215128'</span></span><br></pre></td></tr></table></figure>
<p>二、删除多个元组的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> </span><br><span class="line"><span class="keyword">FROM</span> SC</span><br></pre></td></tr></table></figure>
<p>这条delete语句使SC表变为空表，删除了SC所有元组</p>
<p>三、带子查询的删除语句<br>子查询同样也可以嵌套在delete语句中，用以构造执行删除操作的条件。<br>例：删除计算机科学系所有学生的选课记录。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> </span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> <span class="string">'cs'</span>=</span><br><span class="line">       (<span class="keyword">select</span> sdept</span><br><span class="line">        <span class="keyword">from</span> student</span><br><span class="line">        <span class="keyword">where</span> student.sno=sc.sno);</span><br></pre></td></tr></table></figure>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是从一个或几个基本表(或视图)导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。视图一经定义，就可以和基本表一样被查询、被删除。也可以在一个视图之上再定义新的视图，但对视图的更新（增、删、改）操作则有一定得限制。</p>
<h3 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h3><p>一、建立视图</p>
<p>一般格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span> &lt;视图名&gt; [(&lt;列名&gt; [,&lt;列名&gt;]…)] </span><br><span class="line"><span class="keyword">AS</span> &lt;子查询&gt; </span><br><span class="line">[<span class="keyword">WITH</span>  <span class="keyword">CHECK</span>  <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure>
<p>其中，子查询可以是任意复杂的SELECT语句，但通常不允许有order by子句和DISTINCT短语</p>
<p>with chech option 表示对视图进行update，insert和delete操作时要保证更新，插入，或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）。<br>组成视图的属性列名或者全部省略或全部指定，没有第三选择，如果省略了视图的各个属性列名，则隐含该视图由子查询中select子句目标列中的诸字段组成，但在下列三种情况下必须明确指定组成视图的所有列名：<br>（1）某个目标列不是单纯的属性名，而是聚集函数或列表达式<br>（2）多表连接时选出几个同名列作为视图的字段；<br>（3）需要在视图中为某个列启用新的更合适的名字。</p>
<p>例  建立信息系学生的视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span> IS_Student </span><br><span class="line"><span class="keyword">AS</span>  </span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Sage </span><br><span class="line"><span class="keyword">FROM</span> Student </span><br><span class="line"><span class="keyword">WHERE</span> Sdept= <span class="string">'IS'</span>;</span><br></pre></td></tr></table></figure>
<p>本例中省略了视图 IS_Student的列名，则用select子句目标列中的诸字段来组成属性列名，</p>
<p>RDBMS 执行 CREATE VIEW 语句的结果只是把视图的定义存入了数据字典，并不执行其中的select语句，只是在对视图查询时，才按视图的定义从基本表中将数据查出。</p>
<p>例  建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span> IS_Student </span><br><span class="line"><span class="keyword">AS</span>  </span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Sage </span><br><span class="line"><span class="keyword">FROM</span> Student </span><br><span class="line"><span class="keyword">WHERE</span> Sdept= <span class="string">'IS'</span>  </span><br><span class="line"><span class="keyword">WITH</span>  <span class="keyword">CHECK</span>  <span class="keyword">OPTION</span>;</span><br></pre></td></tr></table></figure>
<p>由于定义视图时加入了WITH  CHECK  OPTION子句，以后对该视图进行插入、修改和删除操作时，RDBMS会自动加上Sdept =‘IS’ 的条件</p>
<p>若一个视图是从单个基本表到处的，并且只是去掉基本表的某些行或者某些列，但保留了主码，我们称这类视图为行列子集视图，IS_Student就是一个行列子集视图。</p>
<p>视图不仅可以建立在单个基本表上，也可以建立在多个基本表上</p>
<p>例 建立信息系选修了1号课程的学生的视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S1(Sno,Sname,Grade)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno ,Sname ,Grade</span><br><span class="line"><span class="keyword">FROM</span> Student ,SC</span><br><span class="line"><span class="keyword">WHERE</span> Sdept =<span class="string">'IS'</span> <span class="keyword">AND</span></span><br><span class="line">	Student.Sno=SC.Sno <span class="keyword">AND</span></span><br><span class="line">	SC.Cno=<span class="string">'1'</span>;</span><br></pre></td></tr></table></figure>
<p>由于视图IS_S1的属性列中包含了Student表与SC表的同名列Sno，所以必须在视图后面明确说明视图的各个属性列名。</p>
<p>视图不仅可以建立在一个或多个基本表，还可以建立在一个或多个已定义好的视图，或建立在视图与视图上。<br>例： 建立信息系选修了1 号课程且成绩在90分以上的学生的视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S2</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Grade</span><br><span class="line"><span class="keyword">FROM</span> IS_S1</span><br><span class="line"><span class="keyword">WHERE</span> Grade&gt;=<span class="number">90</span>;</span><br></pre></td></tr></table></figure>
<p>这个视图IS_S2就是定义在IS_S1之上的。</p>
<p>定义基本表时，为了减少数据库中的冗余数据，表中只存放基本数据，由基本数据经过各种计算派生出的数据一般是不存储的。</p>
<p>但由于视图中的数据并不实际存储，所以定义视图时可以根据应用的需要，设置一些派生属性列。</p>
<p>这些派生属性列由于在基本标中并不实际存在也称他们为 <strong>虚拟列</strong>，带虚拟列的视图也称为 <strong>带表达式的视图</strong> 。</p>
<p>例 定义一个反映学生出生年份的视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span> BT_S(Sno, Sname, Sbirth) <span class="comment">/*BT_S带表达式的视图*/</span></span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> Sno, Sname, <span class="number">2004</span>-Sage</span><br><span class="line"><span class="keyword">FROM</span>  Student;</span><br></pre></td></tr></table></figure>
<p>视图中的出生年份是根据计算得到的</p>
<p>还可以用带有聚集函数和 GROUP BY子句的查询来定义视图，这种视图称为 <strong>分组视图</strong></p>
<p>例  将学生的学号及他的平均成绩定义为一个视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> S_G(Sno, Gavg)</span><br><span class="line"><span class="keyword">AS</span></span><br></pre></td></tr></table></figure>
<p>由于AS子句中select语句的目标列平均成绩是通过作用聚集函数得到的，所以CREATE VIEW 中必须明确定义组成S_G视图的各个属性列名，S_G是一个分组视图</p>
<p>例  将Student表中所有女生记录定义为一个视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span>  F_Student(stdnum, <span class="keyword">name</span>, sex, age, dept)</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> Student </span><br><span class="line"><span class="keyword">WHERE</span> Ssex=<span class="string">'女'</span>;</span><br></pre></td></tr></table></figure>
<p>F_Student是由子查询 ‘select * ’建立起来的。F_Student视图的属性列与Student表的属性列一一对应。如果以后修改了基本表Student的结构，则Student表与F_Student视图的映像关系就被破坏了，该视图不能正常工作</p>
<p>为避免这种情况，最好修改基本表之后删除由该基本表导出的视图。然后重建这个视图。</p>
<p>二、删除视图</p>
<p>格式为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  <span class="keyword">VIEW</span> &lt;视图名&gt; [<span class="keyword">CASCADE</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>该语句从数据字典中删除指定的视图定义</li>
<li>如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除</li>
<li>删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除</li>
</ul>
<p>例 删除视图BT_S：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  <span class="keyword">VIEW</span> BT_S;</span><br></pre></td></tr></table></figure></p>
<p> 删除视图IS_S1：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  <span class="keyword">VIEW</span> IS_S1;</span><br></pre></td></tr></table></figure></p>
<p>其中IS_S1视图上还导出了IS_S2视图，所以该语句被拒绝执行，如果要删除，那么使用级联删除语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IS_S1 <span class="keyword">CASCADE</span> <span class="comment">/* 级联删除IS_S!和它到处的所有视图*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h3><p>视图定义以后，就可以对基本表一样对视图进行查询了</p>
<p>例  信息系学生的视图中找出年龄小于20岁的学生</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sage</span><br><span class="line"><span class="keyword">FROM</span> IS_Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage&lt;<span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>RDBMS 执行对视图查询时，首先进行有效性查询，检查查询中涉及的表、视图等是否存在，如果存在，则从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询，这一转换过程称为视图消解。</p>
<p>取出S_Student视图的定义：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_Student</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> Sno, Sname, Sage</span><br><span class="line">      <span class="keyword">FROM</span> Student</span><br><span class="line">      <span class="keyword">WHERE</span> Sdept= <span class="string">'IS'</span>;</span><br></pre></td></tr></table></figure>
<p>本例转换后的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept=<span class="string">'IS'</span> <span class="keyword">AND</span> Sage&lt;<span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>例  查询选修了 1号课程的信息系学生</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IS_Student.Sno,Sname</span><br><span class="line"><span class="keyword">FROM</span> IS_Student.SC</span><br><span class="line"><span class="keyword">WHERE</span> IS_Student.Sno =SC.Sno <span class="keyword">AND</span> SC.Cno=<span class="string">'1'</span>;</span><br></pre></td></tr></table></figure>
<p>本查询涉及视图IS_Student （虚表）和基本表SC ，通过这两个表的联结来完成用户请求。<br>在一般情况下，视图查询的转换是直接了当的，但有些情况下，这种转换不能直接进行，查询时会出现问题，如下面的例子</p>
<p>例 在上面S_G视图 中查询的平均成绩在90分以上的学生学号和平均成绩。<br>语句为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> S_C</span><br><span class="line"><span class="keyword">WHERE</span> Gavg &gt;= <span class="number">90</span>;</span><br></pre></td></tr></table></figure>
<p>其中S_G 视图的子查询为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, <span class="keyword">AVG</span>(Grade) </span><br><span class="line"><span class="keyword">FROM</span> SC </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></table></figure>
<p>将本例中的查询语句与定义S_G视图的子查询结合，形成下列错误的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno ,<span class="keyword">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">AVG</span>(Grade) &gt;= <span class="number">90</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></table></figure>
<p>因为where子句中是不能用聚集函数作为条件表达式，因此执行此修正后的查询将会出现语法错误，正确的转换的查询语句应该是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,<span class="keyword">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">AVG</span>(Grade) &gt;= <span class="number">90</span>;</span><br></pre></td></tr></table></figure>
<p>目前多数关系数据库系统对行列子集视图的查询均能进行正确转换，但对非行列子集视图的查询就不一定能做转换，这类查询应该直接对基本表进行。</p>
<hr>
<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>更新视图是指通过视图来插入（INSERT）、更新（UPDATE）和删除（DELETE）表中的数据。<br>因为视图是一个虚拟的表，其中没有数据。通过视图更新时，都是转换基本表来更新。<br>从用户角度看，更新视图与更新基本表相同；RDBMS将之转化为对基本表的更新操作。<br>为了防止用户通过视图对数据进行增加、删除、修改时，有意无意的对不属于视图范围内的基本表数据进行操作，可在定义视图时加上with check option子句，这样在视图上增删改数据时，RDBMS会检查视图定义的条件，若不满足条件，则拒绝该操作。<br>更新视图时，只能更新权限范围内的数据。超出了范围，就不能更新。</p>
<p>例 将信息系学生视图IS_Student中学号95002的学生姓名改为“刘辰”</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> IS_Student</span><br><span class="line"><span class="keyword">SET</span> Sname=<span class="string">'刘辰'</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno=<span class="string">'95002'</span>;</span><br></pre></td></tr></table></figure>
<p>转换后的更新语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Student</span><br><span class="line"><span class="keyword">SET</span> Sname=<span class="string">'刘辰'</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno=<span class="string">'95002'</span> <span class="keyword">AND</span> Sdept = <span class="string">'IS'</span>;</span><br></pre></td></tr></table></figure>
<p>例 向信息系学生视图IS_Student中插入一个新的学生记录, 学号为95029,姓名为”赵新”, 年龄为20岁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> IS_Student</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'200215129'</span>,<span class="string">'赵新'</span> , <span class="number">20</span> ，<span class="string">'IS'</span>);</span><br></pre></td></tr></table></figure>
<p>转换后对基本表的更新</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> Student (Sno, Sname ,Sage ,Sdept)</span><br><span class="line"><span class="keyword">VALUES</span>( <span class="string">'200215129'</span> , <span class="string">'赵新'</span>  ,<span class="number">20</span> , <span class="string">'IS'</span>);</span><br></pre></td></tr></table></figure>
<p>这里系统自动将系名 ‘ IS ‘ 放入VALUES子句中，</p>
<p>例 删除信息系学生视图 IS_Student中学号为200215129的记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> IS_Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno= <span class="string">'2OO215129'</span></span><br></pre></td></tr></table></figure>
<p>转换为对基本表的更新：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> </span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno =<span class="string">'200215129'</span> <span class="keyword">AND</span> Sdept =<span class="string">'IS'</span>;</span><br></pre></td></tr></table></figure>
<p>在关系数据库中，并不是所有的视图的都是可更新的，因为有些视图的更新不能唯一的有意义的转换成相应的基本表的更新</p>
<p>例如 视图S_G是由学号和平均成绩两个属性列组成的，其中平均成绩是由Student表中对元组分组后计算平均值得到的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> S_G(Sno,Gavg)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,<span class="keyword">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></table></figure>
<p>但是修改平均成绩是错误的，错误的语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> S_G</span><br><span class="line"><span class="keyword">SET</span> Gvag = <span class="number">90</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno= <span class="string">'200215121'</span>;</span><br></pre></td></tr></table></figure>
<p>这个对视图的更新是无法转换成对基本表SC的更新的，因为系统无法修改各科成绩，以使平均成绩为90，所以S_G视图是不可更新的</p>
<p>一般来说，行列子集视图是可更新的。目前各个关系数据库一般都只允许对行列子集进行更新，而且各个系统对视图的更新还有进一步的规定。</p>
<hr>
<h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><ol>
<li><p>视图能够简化用户的操作<br>视图机制使用户可以将注意力集中在所关心地数据上。如果这些数据不是直接来自基本表，则可以通过定义视图，使数据库看起来结构简单、清晰，并且可以简化用户的的数据查询操作。例如，那些定义了若干张表连接的视图，就将表与表之间的连接操作对用户隐藏起来了。换句话说，用户所作的只是对一个虚表的简单查询，而这个虚表是怎样得来的，用户无需了解。</p>
</li>
<li><p>视图使用户能以多种角度看待同一数据<br>视图机制能使不同的用户以不同的方式看待同一数据，当许多不同种类的用户共享同一个数据库时，这种灵活性是非常必要的。</p>
</li>
<li><p>视图对重构数据库提供了一定程度的逻辑独立性<br>数据的物理独立性是指用户的应用程序不依赖于数据库的物理结构。数据的逻辑独立性是指当数据库重构造时，如增加新的关系或对原有的关系增加新的字段，用户的应用程序不会受影响。层次数据库和网状数据库一般能较好地支持数据的物理独立性，而对于逻辑独立性则不能完全的支持。<br>在关系数据库中，数据库的重构造往往是不可避免的。重构数据库最常见的是将一个基本表“垂直”地分成多个基本表。例如：将学生关系<br>Student（Sno，Sname，Ssex，Sage，Sdept）<br>分为SX（Sno，Sname，Sage）和SY（Sno，Ssex，Sdept）两个关系。这时原表Student为SX表和SY表自然连接的结果。如果建立一个视图Student：</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Student（Sno，Sname，Ssex，Sage，Sdept）</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> SX.Sno，SX.Sname，SY.Ssex，SX.Sage，SY.Sdept</span><br><span class="line"><span class="keyword">FROM</span> SX，SY</span><br><span class="line"><span class="keyword">WHERE</span> SX.Sno=SY.Sno；</span><br></pre></td></tr></table></figure>
<p> 这样尽管数据库的逻辑结构改变了（变为SX和SY两个表了），但应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。</p>
<p> 当然，视图只能在一定程度上提供数据的逻辑独立，比如由于视图的更新是有条件的，因此应用程序中修改数据的语句可能仍会因为基本表构造的改变而改变。</p>
</li>
<li><p>视图能够对机密数据提供安全保护<br>有了视图机制，就可以在设计数据库应用系统时，对不同的用户定义不同的视图，使机密数据不出现在不应该看到这些数据的用户视图上。这样视图机制就自动提供了对机密数据的安全保护功能。例如，Student表涉及全校15个院系学生数据，可以在其上定义15个视图，每个视图只包含一个院系的学生数据，并只允许每个院系的主任查询和修改本原系学生视图。</p>
</li>
<li><p>适当的利用视图可以更清晰地表达查询<br>例如经常需要执行这样的查询“对每个学生找出他获得最高成绩的课程号”。可以先定义一个视图，求出每个同学获得的最高成绩：</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> VMGRADE</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno，<span class="keyword">MAX</span>(Grade) Mgrade</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno；</span><br></pre></td></tr></table></figure>
<p> 然后用如下的查询语句完成查询：</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SC.Sno，Cno </span><br><span class="line"><span class="keyword">FROM</span> SC，VMGRADE </span><br><span class="line"><span class="keyword">WHERE</span> SC.Sno = VMGRADE.Sno <span class="keyword">AND</span> SC.Grade = VMGRADE.Mgrade；</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Just for fun!</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Qsx 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

	<div>
		
			<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------<i class="fa fa-paw"></i> 文章已经到尾 <i class="fa fa-paw"></i>-------------</div>
    
</div>

		
	</div>
	
	
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
            <a href="/tags/学习/" rel="tag"># 学习</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/115b549a.html" rel="next" title="iBatis">
                <i class="fa fa-chevron-left"></i> iBatis
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/a6386957.html" rel="prev" title="数据库学习基础篇②">
                数据库学习基础篇② <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Qsx" />
            
              <p class="site-author-name" itemprop="name">Qsx</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Shelhon" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:ppp00qqq@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://weibo.com/qsxmybaby" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://zhihu.com/people/shelhon" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.kofes.cn/" title="cz" target="_blank">cz</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#绪论"><span class="nav-number">1.</span> <span class="nav-text">绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库系统概述"><span class="nav-number">1.1.</span> <span class="nav-text">数据库系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、基础概念"><span class="nav-number">1.1.1.</span> <span class="nav-text">一、基础概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、-数据库系统的特点"><span class="nav-number">1.1.2.</span> <span class="nav-text">二、 数据库系统的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据模型"><span class="nav-number">1.2.</span> <span class="nav-text">数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据模型的组成要素"><span class="nav-number">1.2.1.</span> <span class="nav-text">数据模型的组成要素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念模型"><span class="nav-number">1.2.2.</span> <span class="nav-text">概念模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本概念"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实体型之间的联系"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">实体型之间的联系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最常用的数据模型"><span class="nav-number">1.2.3.</span> <span class="nav-text">最常用的数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非关系模型"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">非关系模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#层次模型"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">层次模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网状模型"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">网状模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关系模型"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">关系模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库的系统结构"><span class="nav-number">1.3.</span> <span class="nav-text">数据库的系统结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库系统模式的概念"><span class="nav-number">1.3.1.</span> <span class="nav-text">数据库系统模式的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库系统的三级模式结构"><span class="nav-number">1.3.2.</span> <span class="nav-text">数据库系统的三级模式结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式（Schema）"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">模式（Schema）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外模式（External-Schema）"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">外模式（External Schema）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内模式（Internal-Schema）"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">内模式（Internal Schema）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据的二级映像和功能和数据独立性"><span class="nav-number">1.3.3.</span> <span class="nav-text">数据的二级映像和功能和数据独立性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#外模式-模式-映像"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">外模式/模式 映像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模式-内模式映像"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">模式/内模式映像</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库系统的组成"><span class="nav-number">1.4.</span> <span class="nav-text">数据库系统的组成</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关系数据库"><span class="nav-number">2.</span> <span class="nav-text">关系数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#关系数据结构及形式化定义"><span class="nav-number">2.1.</span> <span class="nav-text">关系数据结构及形式化定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关系数据结构"><span class="nav-number">2.1.1.</span> <span class="nav-text">关系数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系模式"><span class="nav-number">2.1.2.</span> <span class="nav-text">关系模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系数据库-1"><span class="nav-number">2.1.3.</span> <span class="nav-text">关系数据库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系操作"><span class="nav-number">2.2.</span> <span class="nav-text">关系操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本的关系操作"><span class="nav-number">2.2.1.</span> <span class="nav-text">基本的关系操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系数据语言分类"><span class="nav-number">2.2.2.</span> <span class="nav-text">关系数据语言分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系的完整性"><span class="nav-number">2.3.</span> <span class="nav-text">关系的完整性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关系的三类完整性约束"><span class="nav-number">2.3.1.</span> <span class="nav-text">关系的三类完整性约束</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实体完整性"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">实体完整性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参照完整性"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">参照完整性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用户定义的完整性"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">用户定义的完整性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系代数"><span class="nav-number">2.4.</span> <span class="nav-text">关系代数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传统的集合运算"><span class="nav-number">2.4.1.</span> <span class="nav-text">传统的集合运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#专门的关系运算"><span class="nav-number">2.4.2.</span> <span class="nav-text">专门的关系运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系演算"><span class="nav-number">2.5.</span> <span class="nav-text">关系演算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#元组关系演算语言ALPHA"><span class="nav-number">2.5.1.</span> <span class="nav-text">元组关系演算语言ALPHA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#域关系语言QBE"><span class="nav-number">2.5.2.</span> <span class="nav-text">域关系语言QBE</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本章小结"><span class="nav-number">2.6.</span> <span class="nav-text">本章小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关系数据库标准语言SQL"><span class="nav-number">3.</span> <span class="nav-text">关系数据库标准语言SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL特点"><span class="nav-number">3.1.</span> <span class="nav-text">SQL特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL基本概念"><span class="nav-number">3.2.</span> <span class="nav-text">SQL基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#学生-课程数据库"><span class="nav-number">3.3.</span> <span class="nav-text">学生-课程数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据定义"><span class="nav-number">3.4.</span> <span class="nav-text">数据定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模式的定义和删除"><span class="nav-number">3.4.1.</span> <span class="nav-text">模式的定义和删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本表的定义、删除与修改"><span class="nav-number">3.4.2.</span> <span class="nav-text">基本表的定义、删除与修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的建立与删除"><span class="nav-number">3.4.3.</span> <span class="nav-text">索引的建立与删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据查询"><span class="nav-number">3.5.</span> <span class="nav-text">数据查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单表查询"><span class="nav-number">3.5.1.</span> <span class="nav-text">单表查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接查询"><span class="nav-number">3.5.2.</span> <span class="nav-text">连接查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套查询"><span class="nav-number">3.5.3.</span> <span class="nav-text">嵌套查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合查询"><span class="nav-number">3.5.4.</span> <span class="nav-text">　集合查询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据更新"><span class="nav-number">3.6.</span> <span class="nav-text">数据更新</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#插入数据"><span class="nav-number">3.6.1.</span> <span class="nav-text">插入数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改数据"><span class="nav-number">3.6.2.</span> <span class="nav-text">修改数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除数据"><span class="nav-number">3.6.3.</span> <span class="nav-text">删除数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#视图"><span class="nav-number">3.7.</span> <span class="nav-text">视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义视图"><span class="nav-number">3.7.1.</span> <span class="nav-text">定义视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查询视图"><span class="nav-number">3.7.2.</span> <span class="nav-text">查询视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新视图"><span class="nav-number">3.7.3.</span> <span class="nav-text">更新视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图的作用"><span class="nav-number">3.7.4.</span> <span class="nav-text">视图的作用</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qsx</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">112.2k</span>
  
</div>










        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
</body>

</html>
