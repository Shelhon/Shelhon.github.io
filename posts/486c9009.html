<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="学习,数据库,"><meta name="description" content="基础篇内容  一、绪论二、关系数据库三、关系数据库标准语言四、数据库安全性五、数据库完整性"><meta name="keywords" content="学习,数据库"><meta property="og:type" content="article"><meta property="og:title" content="数据库学习基础篇"><meta property="og:url" content="https://www.shelhon.cn/posts/486c9009.html"><meta property="og:site_name" content="无问西东"><meta property="og:description" content="基础篇内容  一、绪论二、关系数据库三、关系数据库标准语言四、数据库安全性五、数据库完整性"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/1.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/2.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/3.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/4.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/实体及其属性图.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/实体及其联系图.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/实体-联系图.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/基本层次联系.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/5.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/6.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/7.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/8.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/9.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/10.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/11.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/12.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/13.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/14.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/15.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/16.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/17.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/18.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/19.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/20.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/21.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/22.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/23.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/24.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/25.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/26.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/27.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/28.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/29.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/30.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/31.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/32.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/33.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/34.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/35.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/36.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/37.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/38.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/39.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/40.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/41.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/42.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/43.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/44.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/45.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/46.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/47.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/48.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/49.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/50.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/51.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/52.png"><meta property="og:image" content="https://www.shelhon.cn/posts/486c9009/53.png"><meta property="og:updated_time" content="2018-08-20T06:23:45.145Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据库学习基础篇"><meta name="twitter:description" content="基础篇内容  一、绪论二、关系数据库三、关系数据库标准语言四、数据库安全性五、数据库完整性"><meta name="twitter:image" content="https://www.shelhon.cn/posts/486c9009/1.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://www.shelhon.cn/posts/486c9009.html"><title>数据库学习基础篇 | 无问西东</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3275656b1c327868bf311aa7c5fdabd2";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="https://github.com/Shelhon/Shelhon.github.io" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64ceaa;color:#fff;position:absolute;top:0;border:0;left:0;transform:scale(-1,1)" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">无问西东</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">糊涂脸水聪明枕</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br> 公益404</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.shelhon.cn/posts/486c9009.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Qsx"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="无问西东"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">数据库学习基础篇</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T11:36:43+08:00">2018-08-13</time></span> <span class="post-updated">&nbsp; | &nbsp; 更新于 <time itemprop="dateUpdated" datetime="2018-08-20T14:23:45+08:00" content="2018-08-20">2018-08-20</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span></span> <span class="post-meta-divider">|</span><span class="page-pv"><i class="fa fa-file-o"></i><span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">20,701</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">75</span></div></div></header><div class="post-body" itemprop="articleBody"><center><strong>基础篇内容</strong></center><p>一、绪论<br>二、关系数据库<br>三、关系数据库标准语言<br>四、数据库安全性<br>五、数据库完整性</p><hr><a id="more"></a><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h2><h3 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h3><ol><li><p>数据<br>数据是数据库存储的基本对象，有多种表现形式。数据的表现形式还不能完全表达其内容，需要经过解释，数据的解释是指对数据含义的说明，数据的含义成为数据的语义，数据和他的语义是不可区分的。</p></li><li><p>数据库（database，简称DB）<br>是存放数据的仓库，按照一定的格式存放的。严格来说，数据库是长期存储在计算机内，有组织、可共享的大量数据的集合。数据库中的数据按照一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性、并可为各种用户共享。<br>具有三个基本特点：永久存储、有组织、可共享</p></li><li><p>数据库管理系统（database management system ，DBMS）<br>DBMS的作用就是科学的组织和存储数据，高效的获取和维护数据。<br>主要功能包括了</p><ol><li>数据定义功能：提供数据定义语言来对数据对象进行定义</li><li>数据组织、存储和管理： 基本目标是提供存储空间利用率和方便存取，提供多种方法（如索引查找，hash查找、顺序查找等）来提供存取效率</li><li>数据操纵功能：通过数据操纵语言对数据库进行基本操作，如查询，插入，删除和修改等。</li><li>数据库的事务管理和运行管理：数据库在建立、运用和维护时对数据库管理系统统一管理、控制、以保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。</li><li>数据库的建立和维护功能：包括了数据库初始数据的输入，转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。</li><li>其他功能：DBMS与网络中其他软件系统的通信功能；一个DBMS与另一个DBMS或文件系统的数据转换功能；异构数据库之间的互访和互操作功能等。</li></ol></li><li><p>数据库系统（database system，DBS）<br>数据库系统是指计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、应用系统、数据库管理员构成。</p></li></ol> <img src="/posts/486c9009/1.png"><hr><h3 id="二、-数据库系统的特点"><a href="#二、-数据库系统的特点" class="headerlink" title="二、 数据库系统的特点"></a>二、 数据库系统的特点</h3><ol><li><p>数据结构化<br>这是一个主要特征之一。所谓的“整体”结构化是指数据库的数据不再仅仅针对某一个应用，而是面向全组织；不仅数据内部是结构化的，而且整体也是结构化的，数据之间是具有联系的。在数据库系统中，不仅数据是整体结构化，而且存取数据的方式也很灵活，可以存取数据库中的某一个数据项、一组数据项、一个记录或一组记录。</p></li><li><p>数据的共享性高，冗余度低，易扩充<br>数据是面向整个系统，可以被多个用户多个应用共享使用，数据共享可以大大减少数据冗余，还能避免数据之间的不相容性和不一致性。<br>数据不一致性是指同一数据由于人工管理或者文件系统管理时，重复存储，导致不同拷贝的值不一样。</p></li><li><p>数据独立性高<br>数据的物理独立性：是指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。即，数据在磁盘上怎样存储由DBMS管理，用户程序不需要了解，应用程序要处理的只是数据的逻辑结构，这样当数据的物理存储改变了，应用程序不用改变。<br>逻辑独立性：是指用户的应用程序与数据库的逻辑结构是相互独立的，即，当数据的逻辑结构改变时，用户程序也可以不变。<br>数据独立性由DBMS的二级映像功能来保证。</p></li><li><p>数据由DBMS统一管理和控制<br>数据库的共享是并发共享，即多个用户可以同时存取数据库中的数据甚至同时存储同一个数据。<br>所以DBMS还提供以下几个数据控制功能：<br>（1）数据的安全性保护<br>（2）数据的完整性检查<br>（3）并发控制<br>（4）数据库恢复</p></li></ol><p> 总结：数据库是长期存储在计算机内有组织的大量的共享的数据集合。它可以提供各种用户共享，具有最小冗余度和较高的数据独立性。</p><hr><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>数据模型是现实世界数据特征的抽象</p><p>数据模型应该满足三个方面：比较真实的模拟现实世界；二是容易为人所理解；三是便于在计算机实现。</p><p>根据不同的目的，可以把模型划分两类：</p><ul><li>概念模型：也称为信息模型，按照用户的观点来对数据和信息建模，主要用于数据库设计</li><li>逻辑模型和物理模型：逻辑模型主要包括层次模型，网状模型，关系模型，面向对象模型和对象关系模型等。是按照计算机系统的观点对数据建模。主要用于DBMS的实现。物理模型是对数据最底层的抽象，描述数据在系统内部的表示方法和存取方法，是面向计算机系统的。物理模型的具体实现是DBMS的任务，数据库设计人员要了解和选择物理模型，一般用户则不需要考虑物理级的细节。</li></ul><hr><h3 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h3><p>一般来说，数据模型是严格定义一组概念的集合，这些概念精确地描述了系统的静态特性，动态特性和完整性约束条件。因此数据模型通常由数据结构，数据操作和完整性约束三部分来组成。</p><hr><p>一、 数据结构<br>数据结构描述数据库的组成对象以及对象之间的联系。有两类：</p><ol><li>是与对象的类型，内容，性质有关的，例如网状模型中的数据项，记录，关系模型中的域，属性，关系等。</li><li>是与数据之间的联系有关的对象，例如网状模型中的系型。</li></ol><hr><p>二、 数据操作</p><p>数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。</p><p>数据库的主要有查询和更新（包括插入，删除、修改）两大类操作。数据模型必须定义这些操作的确切含义，操作符号，操作规则（如优先级）以及实现操作的语言。</p><p>数据操作是对系统动态特性的描述。</p><hr><p>三、 数据的完整性约束条件</p><p>数据的完整性约束条件是一组完整性规则。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态和状态的变化，以保证数据的正确，有效，相容。</p><p>数据模型应该反映和规定本数据模型必须遵守的基本的通用的基本的通用的完整性约束条件。</p><p>数据模型还应该提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。</p><hr><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><p>概念模型一方面应该具有较强的语义表达能力，能够方便、直接的表达应用中的各种语义知识、另一方面应该简单，清晰，易于用户理解。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>（1） 实体：客观存在并可相互区别的事物成为实体。可以是具体的人事物，也可以是抽象的概念或者联系，比如老师和学校的工作关系。</p><p>（2）属性：实体所具有的某一特性称为属性。一个实体可以由若干的属性来刻画，比如学生这个实体可以由学号姓名性别出生年月等信息组成。</p><p>（3）码:唯一标识实体的属性集称为码。比如学号是学生实体的码。</p><p>（4）域：属性的取值范围称为该属性的域，比如学号的域为8位整数，姓名的域为字符串集合，学生年龄的域为整数，性别的域为（男，女）</p><p>（5）实体型：具有相同属性的实体必然具有共同的特征和性质。用实体名以及属性名称集合来抽象和刻画同类实体，称为实体型。比如学生（学号，姓名，性别，出生年月，所在院系，入学时间）就是一个实体型。</p><p>（6）实体集：同一类型实体的集合称为实体集，例如全体学生就是一个实体集</p><p>（7）联系：实体内部的联系通常是指组成实体的各属性之间的联系；实体之间的联系通常是指不同的实体集之间的联系。</p><hr><h4 id="实体型之间的联系"><a href="#实体型之间的联系" class="headerlink" title="实体型之间的联系"></a>实体型之间的联系</h4><p>一、两个实体型的联系分为三种：</p><ol><li><p>一对一联系（1：1）<br>如果对于实体集A中每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，则称为一对一联系。比如电影院座位和观众实体之间的联系</p></li><li><p>一对多联系（1：n）<br>如果对于实体集A中每一个实体，实体集B中有n个实体（n&gt;=0）与之联系，比如部门和员工两个实体集之间的联系。</p></li><li><p>多对多联系（n:n）<br>表示实体集A中多个实体可与实体集B中多个实体相联系。例如一门课程可以同时有若干学生选修，而一个学生也可以同时选修多门课程，这就是多对多联系。<br>实际上，一对一联系是一对多联系的特例，而一对多联系又是多对多联系的特例。</p><hr></li></ol><p>二、 两个以上的实体型之间的联系</p><p>一般来说，两个以上的实体型也存在一对一，一对多，多对多的联系<br>比如 课程，老师，参考书 。一个课程可以由若干个老师讲授，也可以使用若干本参考书，这就是一对多。<br>供应商与项目，零件的联系，一个供应商可以供给多个项目多种零件，而且每个项目可以使用多个供应商供应的零件，每种零件可由不同的供应商攻击。所以是多对多联系。</p> <img src="/posts/486c9009/2.png"><hr><p>三、 单个实体型内的联系</p><p>同一个实体集内的各实体之间也可以存在一对一，一对多，多对多的联系。<br>比如职工内部也存在领导与被领导的关系，而一个职工仅被另一个职工直接领导，这是一对多的联系</p><hr><p>四、概念模型的一种表示方法：实体–联系方法</p><p>概念模型的方法挺多，最著名的是实体-联系方法（entity-relationship Approach）。该方法用E-R图来描述现实世界的概念模型，也称为E-R模型</p><p>E-R图提供表示实体型、属性和联系的方法：</p><ul><li>实体型 ：用矩阵表示，矩形框内写明实体名</li><li>属性：用椭圆表示，并用无向边将其相应的实体型连接起来</li></ul><p>例如 ：学生实体具有学号、姓名、性别、出生年份、系、入学时间等属性，用E_R图表示如下</p> <img src="/posts/486c9009/3.png"><ul><li>联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁边表上联系的类型（1:1,1:n或m:n）</li></ul><p>如果联系具有属性，那么这些属性也需要用无向边和该联系连接起来</p> <img src="/posts/486c9009/4.png"><hr><p>五、 一个实例</p><p>下面用E-R图来表示某个工厂物资管理的概念模型</p><p>物资管理设计的实体有：</p><ul><li>仓库 —属性有仓库号，面积，电话号码</li><li>零件 —属性有零件号，名称，规格，单价，描述</li><li>供应商—属性有供应商号，姓名，地址，电话号码，账号</li><li>项目 —属性有项目号，预算，开工日期</li><li>职工 —属性有职工号，姓名，年龄，职称</li></ul><p>这些实体的联系如下：<br>（1）一个仓库可以存放多种零件，一种零件可以存放在多个仓库中，因此仓库和零件具有多对多的联系。用库存量来表示某种零件在某个仓库中的数量<br>（2）一个额仓库有多个职工当仓库保管员，一个职工只能在一个仓库工作，因此仓库和职工之间是一对多的联系。<br>（3）职工之间具有领导和被领导关系，即仓库主任领导若干保管员，因此职工实体型中具有一对多的联系。<br>（4）供应商、项目和零件三者之间具有多对多的联系。即一个供应商可以供给若干项目多种零件，每个项目可以使用不同供应商供应的零件，每种零件可由不同的供应商供给。</p> <img src="/posts/486c9009/实体及其属性图.png" title="实体及其属性图"> <img src="/posts/486c9009/实体及其联系图.png" title="实体及其联系图"> <img src="/posts/486c9009/实体-联系图.png" title="完整的实体-联系图"><hr><h3 id="最常用的数据模型"><a href="#最常用的数据模型" class="headerlink" title="最常用的数据模型"></a>最常用的数据模型</h3><p>目前最常用的逻辑数据模型有：</p><ul><li>层次模型</li><li>网状模型</li><li>关系模型</li><li>面向对象模型</li><li>对象关系模型</li></ul><p>其中层次模型和网状模型称为非关系模型，在非关系模型中，实体用记录表示，实体的属性对应记录的数据项（或字段）。实体之间的联系在非关系模型中转换成记录之间的两两联系。</p><h4 id="非关系模型"><a href="#非关系模型" class="headerlink" title="非关系模型"></a>非关系模型</h4><p>非关系模型中的数据结构的单位是基本层次联系，就是指两个记录及他们之间的一对多（包括一对一）的联系。<br>如图</p> <img src="/posts/486c9009/基本层次联系.png" title="基本层次联系"><p>Ri位于联系Lij的始点，称为双亲节点，Rj位于联系Lij的终点，称为子女节点</p><hr><h4 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h4><p>层次模型用树形来表示各类实体以及实体间的联系。现实世界中许多实体之间的联系本来就呈现出一种很自然的的层次关系，如行政机构，家族关系等。</p><p>一、层次数据模型的数据结构</p><p>满足下面两个条件的集合为层次模型</p><p>（1）有且只有一个节点，没有双亲节点，这个节点称为根节点<br>（2）根以外的其他节点有且只有一个双亲节点。</p><p>在层次模型中，每个节点表示一个记录模型，记录（类型）之间的联系用节点之间的连线（有向边）表示，这种联系是父子之间的一对多的联系。</p><p>每个记录模型可包含若干个字段，记录类型描述的是实体，字段描述实体的属性，各个记录类型及其字段都必须命名。各个记录类型、同一个记录类型里的各个字段不能同名。</p><p>下图是一个教员学生层次模型，有4个记录型，其中记录型– 系 是根节点，由系编号，系名，办公地点三个字段组成。两个子女节点教研室和学生。记录型– 教研室 是系的子女节点，同时又是教员的双亲节点。由教研室编号，教研室名两个字段组成。记录型– 学生 由学号，姓名，成绩三个字段组成。记录型– 教员由职工号，姓名，研究方向三个字段组成。学生和教员是叶节点，他们没有子女节点。由系到教研室，由教研室到教员，由系到学生均是一对多的联系。</p> <img src="/posts/486c9009/5.png" title="教员学生层次模型"><p>下图是上图对应的一个值，该值是D02系记录值及其所有后代记录值组成的一棵树。</p> <img src="/posts/486c9009/6.png"><hr><p>二、 多对多联系在层次模型中的表示</p><p>如果用层次模型表示多对多联系，必须首先将多对多联系分解成一对多联系。分解方法两种：冗余节点法和虚拟节点法</p><p>下图是简单的多对多，一个学生可以选修多门课程，一门课程可由多个学生选修，学生由学号，姓名，成绩三个字段组成。课程由课程号两个字段组成。</p> <img src="/posts/486c9009/7.png" title="简单的多对多联系"><p>下图是采用冗余节点法，通过增加两个冗余节点将多对多联系转换成两个一对多联系</p> <img src="/posts/486c9009/8.png" title="冗余节点法"><p>下图是采用虚拟节点的分解方法，将冗余节点换成虚拟节点，所谓虚拟节点就是一个指针，指向所代替的节点。</p> <img src="/posts/486c9009/9.png" title="虚拟节点法"><p>冗余节点法的优点是结构清晰，允许节点改变存储位置，缺点需要额外空间，并有潜在的不一致性问题。虚拟节点的优点在减伤空间的浪费吗，避免产生潜在不一致性，缺点是节点改变了存储位置可能引起虚拟节点中指针的修改。</p><hr><p>三、层次模型的数据操纵与完整性约束</p><p>层次模型的数据操纵主要有查询，插入，删除和更新，进行插入，删除，更新操作时要满足层次模型的完整性约束条件。</p><p>在进行插入操作的时候，如果没有相应的双亲节点就不能插入它的子女节点值，比如在上面的教员学生层次模型中，若新加入一名教员，但是还没分配教研室，这就就不能插入到数据库中。</p><p>在进行删除操作时，如果删除双亲节点，那么双亲节点下的子女节点值也被同时删除。在教员学生层次模型中，删除教研室，那么该教研室的教员的数据也会全部丢失。</p><p>四、层次数据模型的存储结构</p><p>层次数据库中不仅要存储数据本身，还要存储数据之间的层次联系。层次模型数据的储存常常是和数据之间的储存结合在一起的，常用方法有两种</p><ol><li>邻接法<br>按照层次树穿越的顺序把素有记录值依次邻接存放，即通过物理空间的位置相邻来体现（或隐含）层次顺序。</li></ol> <img src="/posts/486c9009/10.png"><ol start="2"><li>链接法<br>用指针来反映数据之间的层次联系。</li></ol><p>子女-兄弟链接法：每个记录设两类指针，分别指向最左边的子女（每个记录型对应一个）和最新的兄弟。</p> <img src="/posts/486c9009/11.png" title="子女-兄弟链接法"><p>层次序列链接法：按照树的前序穿越链接各记录值</p> <img src="/posts/486c9009/12.png" title="层次序列链接法"><p>五、层次模型的优缺点</p><p>优点：</p><ol><li>层次模型的数据结构比较简单清晰</li><li>层次数据库的查询效率高<br>层次数据库的性能优于关系数据库，不低于网状数据库</li><li>层次数据模型提供了良好的完整性支持</li></ol><p>缺点：</p><ol><li>现实世界很多是非层次性的，如节点之间具有多对多联系</li><li>一个节点如果具有多个双亲等，层次模型表示这类联系方法就很笨拙。</li><li>查询子女节点必须通过双亲节点</li><li>由于结构严密，层次命令趋于程序化</li></ol><hr><h4 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h4><p>由于很多联系是非层次的，用层次模型表示非树形结构是很不直接的，而网状模型则可以克服这个问题。</p><p>一、 网状数据模型的数据结构<br>满足以下两个条件则称为网状模型：<br>（1）允许一个以上的节点无双亲<br>（2）一个节点可以有多余一个的双亲</p><p>网状模型是一种比层次模型更具有普遍性的结构，去掉了层次模型的两个限制，允许多个节点没有双亲节点，允许节点可以有多个双亲节点。还允许两个节点之间有多重联系（称为符合联系）。网状模型可以更直接的去描述现实世界，而层次模型实际上是网状模型的一个特例。</p><p>网状模型中每一个节点表示一个记录类型（实体），每个记录类型可包含若干个字段（字体的属性），节点间的连线表示记录类型（实体）之间的一对多的父子联系。在层次模型中，子女节点和双亲节点的联系是唯一的，而在网状模型中的是可以不唯一的。</p><p>下面是网状模型的例子</p> <img src="/posts/486c9009/13.png" title="网状模型"><p>以学生选课为例：</p><ul><li>一个学生可以选修若干门课程，某一课程可以被多个学生选修，因此学生与课程之前是多对多联系。为了表示多对多的联系，引入了一个学生选课的联结记录，由三个数据项组成，即学号，课程号，成绩，表示某个学生选修某一门课程及其成绩。</li><li>学生选课就包含了三个记录，学生、课程、选课</li><li>每个学生可以选多门课程，即对学生记录中的一个值，选课记录中可以多个值相联系，而选课记录中的一个值，只能和学生记录中的一个值联系。学生和选课之间的联系是一对多的联系。联系名为S-SC。同样课程与选课的联系也是一对多的联系。联系名为C-SC 。</li></ul> <img src="/posts/486c9009/14.png"><p>下图是一个学生，选课，课程的网状数据库的一个值</p> <img src="/posts/486c9009/15.png"><hr><p>二、 网状数据模型的操纵和完整性约束</p><p>DBTG在模式DDL中提供了定义DBTG数据库完整性的若干概念和语句：<br>（1）支持记录码的概念，码即唯一表示记录的数据项的集合。例如学生记录中的学号是码，因此不允许学生记录中出现重复的学号。<br>（2）保证一个联系中双亲记录和子女记录之间是一对多的联系。<br>（3）可以直接双亲记录和子女记录的某些约束条件。比如有些子女记录要双亲记录存在才可以插入，双亲记录删除也会连同删除。</p><p>三、网状数据模型的存储结构</p><p>最常用的是链接法，包括单向链接，双向链接，环状链接和向首链接，此外还有其他方法：引元阵列法，二进制阵列法，索引法，根据具体情况来使用。</p><p>设一个网状数据库的实例：</p><ul><li>学生记录：S1 , S2 , S3;</li><li>课程记录：C1 , C2 , C3;</li><li>S1的选课记录: S1C1A 、S1C2A;</li><li>S2的选课记录: S2C1A 、S2C3B;</li><li>S3的选课记录: S3C1B 、S3C2B</li><li>S4的选课记录: S4C1A 、S4C2A 、S4C3B</li></ul> <img src="/posts/486c9009/16.png" title="学生、选课、课程的网状数据库实例"><ul><li><p>学生选课数据库中 学生、课程、选课三个记录的值可以分别按某种文件组织方式存储，记录之间的联系用单向链接实现</p></li><li><p>图中的实线链表示S-SC联系，即把S1学生和他的选课记录（选修的C1，C2两门课程的选课记录）链接起来，同样把S2,S3,S4学生和他们的选课记录链接起来；</p></li><li>虚线表示C-SC联系，把C1课程和选修了C1课程的学生记录（有S1,S2,S3,W4学生选修了C1）链接起来，同样把C2,C3课程和选修了这些课程的学生记录链接起来。</li></ul><p>四、网状数据模型的优缺点</p><p>优点：</p><ol><li>能够更直接的描述现实世界，比如一个节点可以有多个双亲，节点之间可以有多重联系</li><li>具有良好的性能，存取效率较高</li></ol><p>缺点：</p><ol><li>结构比较复杂，随着应用环境的阔达，数据库的结构变得越来越负责，不利于最终用户掌握。</li><li>网状模型的DDL，DML复杂，并且要嵌入某一种高级语言（COBOL ，C）。用户不容易掌握，不容易使用。</li><li>由于记录之间的联系是通过存取路径实现的，应用程序在访问在访问数据时必须选择适当的存取路径，因此用户必须了解系统结构的细节，家中了编写应用程序的负担。</li></ol><hr><h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>关系模型是目前最重要的一种数据模型。关系数据莫系统采用关系模型作为数据的组织方式。</p><p>一、 关系数据模型的数据结构</p><p>关系模型与上面的模型不同，是建立在严格的数学概念的基础上的。<br>从用户观点上看，关系模型是由一组关系组成，每个关系的数据结构是一张规范化的二维表。以下图学生登记表为例</p> <img src="/posts/486c9009/17.png" title="关系模型的数据结构"><ul><li>关系（relation）：一个关系对应通常说的一张表，如学生登记表</li><li>元祖（tuple）: 表中的一行即为一个元祖；</li><li>属性（Attribute）：表中的一列即为一个属性，给每一个属性起一个名称即为属性名。如这张表有6列，对应六个属性（学号，姓名，年龄，性别，系名，年级）</li><li>码（key）：也称为码键。表中某个属性组，它可以唯一确定一个元祖，如表中的学号可以确定一个学生，也就称为本关系的码</li><li>域（domain）：属性的取值范围，如人的年龄一般在1~150岁之间，大学生年龄属性域是（14~38），性别的域是（男，女），系名的域是一个学校所有系名的集合；</li><li>分量：元祖中的一个属性值</li><li>关系模式：对关系的描述，一般表示为<ul><li>关系名（属性1，属性2，…… ，属性n）</li></ul></li></ul><p>上面的关系可以描述为</p><ul><li>学生（学号，姓名，年龄，性别，系名，年级）</li></ul><p>在关系模型中，实体以及实体间的联系都是用关系来表示。例如，学生，课程，学生与课程之间的多对多联系在关系模型中可以如下表示：</p><ul><li>学生（学号，姓名，年龄，性别，系名，年级）</li><li>课程（课程号，课程名，学分）</li><li>选修（学号，课程号，成绩）</li></ul><p>关系模型要求关系必须是规范化的，即要求关系必须满足一定的规范条件：关系的每一个分量必须是一个不可分的数据项，也就是说不允许表中还有表。</p> <img src="/posts/486c9009/18.png" title="不符合关系模型的表"><p>下图是一个术语的粗略对比</p> <img src="/posts/486c9009/19.png" title="术语对比"><hr><p>二、 关系数据模型的操纵和完整性约束</p><p>主要操作：查询，插入，删除和更新数据。</p><p>完整性约束包含三大类：实体完整性，参照完整性，用户定义完整性</p><p>关系模型中的的数据操作都是集合操作，操作对象和操作结果都是关系，即若干元祖的集合，而不像非关系模型中国那样是单记录的操作方式。另一方面，关系模型把存取路径隐藏起来，用户只需要指出“干什么”、“找什么”，不必详细说明“怎么干”或“怎么找”，从而大大的提高了数据的独立性，提高了用户生产率。</p><p>三、关系数据模型的存储结构</p><p>在关系数据模型中，实体及实体间的联系都用表来表示，在关系数据库的物理组织中，有的DBMS 一个表对应一个操作系统文件，有的DBMS从操作系统获得若干大的文件，自己设计表、索引等存储结构。</p><p>四、关系数据模型的优缺点<br>优点：</p><ol><li>关系模型与非关系模型不同，是建立在严格的数学概念的基础上</li><li>关系模型的概念单一，无论实体还是实体之间的联系都用关系来表示。对数据的检索和更新结果也是关系（即表）所以其数据结果简单、清晰、用户易懂易用。</li><li>关系模型的存取路径对用户透明，从而更有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作。</li></ol><p>缺点：</p><ol><li>由于存取路径透明，查询效率往往不如非关系数据模型。</li></ol><hr><h2 id="数据库的系统结构"><a href="#数据库的系统结构" class="headerlink" title="数据库的系统结构"></a>数据库的系统结构</h2><blockquote><p>本章学习的是数据库系统的模式结构</p></blockquote><h3 id="数据库系统模式的概念"><a href="#数据库系统模式的概念" class="headerlink" title="数据库系统模式的概念"></a>数据库系统模式的概念</h3><p>在数据模型中有“型”（T）和“值（value）”的概念。型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。例如学生记录定义为（学号，姓名，性别，系别，年龄，籍贯）这样的记录型，而（900201,李明，男，计算机，22,江苏）则是该记录型的一个记录值</p><p>模式是数据库中全体数据的逻辑结构和特征的描述，仅仅涉及到型的描述，不涉及到具体的值。模式的一个具体值称为模式的一个实例。同一个模式可以有很多实例。</p><p>模式是相对稳定的，而实例是相对变动的，因为数据库的数据是不断更新的，模式反应的是数据的结构和联系，而实例反映的是数据库某一时刻的状态。</p><h3 id="数据库系统的三级模式结构"><a href="#数据库系统的三级模式结构" class="headerlink" title="数据库系统的三级模式结构"></a>数据库系统的三级模式结构</h3><p>三级模式是指数据库系统由外模式，模式和内模式构成。</p> <img src="/posts/486c9009/20.png" title="层次结构图"><h4 id="模式（Schema）"><a href="#模式（Schema）" class="headerlink" title="模式（Schema）"></a>模式（Schema）</h4><ol><li><p>模式也叫逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。属于数据库系统模式结构的中间层，既不涉及数据的物理存储细节和硬件环境，也与具体的应用无关。</p></li><li><p>模式实际上是数据库数据在逻辑级上的视图。一个数据库只有一个模式。数据库模式以某一种数据模型为基础，考虑所有用户的需求，结合成一个逻辑整体。</p></li><li>定义模式时要定义数据的逻辑结构，比如数据记录是由哪些数据项构成，数据项的名字、类型、取值范围等，而且要定义数据之间的联系，定义与数据有关的安全性、完整性要求。</li></ol><h4 id="外模式（External-Schema）"><a href="#外模式（External-Schema）" class="headerlink" title="外模式（External Schema）"></a>外模式（External Schema）</h4><ol><li><p>外模式也称为子模式或者用户模式，是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p></li><li><p>外模式通常是模式的子集。一个数据库可以有多个外模式，。对模式中的同一数据，在外模式中的结构、类型、长度、保密级别都可以不同。同一个外模式可以被某一个用户的多个应用系统使用，但是一个应用程序只能使用一个外模式。</p></li><li><p>外模式是保证数据库安全性的一个有力措施，每个用户只能看见和访问所对应的外模式中的数据，数据中的其余数据是不可见的。</p></li></ol><h4 id="内模式（Internal-Schema）"><a href="#内模式（Internal-Schema）" class="headerlink" title="内模式（Internal Schema）"></a>内模式（Internal Schema）</h4><p>内模式也称为存储模式（Storage Schema），一个数据库只有一个内模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。例如，记录的存储方式是顺序结构存储还是B树结构存储；索引按什么方式组织；数据是否压缩，是否加密；数据的存储记录结构有何规定等。</p><p>粗略的表达：内模式就是存储如表在哪个表空间在哪里有索引，表空间的数据文件放在哪里，在哪个磁盘。</p><hr><h3 id="数据的二级映像和功能和数据独立性"><a href="#数据的二级映像和功能和数据独立性" class="headerlink" title="数据的二级映像和功能和数据独立性"></a>数据的二级映像和功能和数据独立性</h3><p>数据库系统的三级模式是对数据的三个抽象级别，为了在系统内部实现这三个抽象层次的联系和转换，提供了两层映像：</p><ul><li>外模式/模式 映像</li><li>模式 / 内模式 映像</li></ul><p>这两层映像保证了数据库系统的数据能够具有较高的逻辑独立性和物理独立性。</p><h4 id="外模式-模式-映像"><a href="#外模式-模式-映像" class="headerlink" title="外模式/模式 映像"></a>外模式/模式 映像</h4><ol><li>模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。</li><li>同一个模式可以有任意多个外模式，。</li><li>每一个外模式，数据库系统都有一个外模式/模式映像，定了了外模式与模式之间的对应关系，这些映像的定义通常包含在各自的外模式的描述中。</li></ol><p>当模式改变时，由数据库管理员对每个 外模式/模式映像进行改变，可以使外模式不变，从而不必修改应用程序。保证了数据与程序的逻辑独立性。</p><h4 id="模式-内模式映像"><a href="#模式-内模式映像" class="headerlink" title="模式/内模式映像"></a>模式/内模式映像</h4><p>数据库只有一个模式，也只有一个内模式，所以模式/内模式映像是唯一的，定义了数据全局逻辑结构与存储结构之间的对应关系。例如说明逻辑记录和字段在内部是如何表示的。该映像定义一般包含在模式描述中。</p><p>当数据库的存储结构改变了，数据库管理员对模式/内模式映像作相应改变，就可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性。</p><p>三种模式的归纳：</p><ol><li><p>在三级模式中，模式即全局逻辑结构是数据库的中心和关键，独立于数据库的其他层次，设计数据库模式结构时应首先确定数据库的逻辑模式。</p></li><li><p>数据库的内模式依赖于全局逻辑结构，独立于外模式，也独立于存储设备。它是将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率。</p></li><li><p>数据库的外模式面向具体的应用程序，定义在逻辑模式之上，独立于存储模式和存储设备。当应用需求发生较大变化，相应外模式不能满足其视图要求时，外模式就得做改动。因此设计外模式需要充分考虑应用的扩充性。</p></li></ol><hr><h2 id="数据库系统的组成"><a href="#数据库系统的组成" class="headerlink" title="数据库系统的组成"></a>数据库系统的组成</h2><p>大概分为</p><ol><li>硬件平台及数据库：<ul><li>大内存</li><li>大磁盘</li><li>系统具有较高的通道能力</li></ul></li><li>软件：<ul><li>DBMS</li><li>支持DBMS的操作系统</li><li>具有数据库接口的高级语言</li><li>以DBMS为核心的应用开发工具</li><li>为特定应用环境开发的数据库应用系统</li></ul></li><li>人员<ul><li>数据库管理员</li><li>系统分析员和数据库设计人员</li><li>应用程序员</li><li>用户</li></ul></li></ol><hr><h1 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h1><h2 id="关系数据结构及形式化定义"><a href="#关系数据结构及形式化定义" class="headerlink" title="关系数据结构及形式化定义"></a>关系数据结构及形式化定义</h2><h3 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h3><p>关系模型的数据结构只包含单一的数据结构—–关系<br>在用户看来，关系模型中的数据的逻辑结构是一张扁平的二维表</p><ol><li><p>域（domain）<br>域是一组具有相同数据类型的集合</p></li><li><p>笛卡儿积（Cartesian product）<br>给定一组域D1，D2, … … ，Dn，这些域可以相同</p></li></ol> <img src="/posts/486c9009/21.png"> <img src="/posts/486c9009/22.png"><ol start="3"><li>关系（relation）</li></ol> <img src="/posts/486c9009/23.png"><p>当n=1时，称该关系为单元关系<br>当n=2时，称为二元关系</p><p>关系是笛卡尔积的有限子集，所以关系也是二维表。<br>每行对应一个元祖，每列对应一个域，由于域可以相同，为了加以区分，必须对每列起一个名字，称为属性（attribute），n目的关系必有n个属性。</p><ul><li>候选码（Candidate Key）： 关系中可以唯一地标识一个元组的 属性 或 属性组。</li><li>主码（Primary Key）： 若一个关系又多个候选码，则选定其中一个为主码。</li><li>主属性（Non-Key attribute）：包含在任何候选码中的诸属性称为主属性。不包含在任何候选码中的属性称为非码属性。</li><li>外码（Froregin Key）： 如果关系模式 <strong>R</strong> 中的属性或者属性组非该关系的码，但是它是其他关系的码，那么该属性集对关系模式 <strong>R</strong>而言是外码。</li><li>全码（All-Key）：关系模型的所有属性组是这个关系模式的候选码，称为全码。</li></ul><p>一般来说，D1,D2,D3,D4…..Dn的笛卡尔积是没有实际语义的，只有它的某个子集才有实际含义。</p><p>关系有三种类型：基本关系（基本表或基表）、查询表、视图表</p><ul><li>基本表是实际存在的表，是实际存储数据的逻辑表示。</li><li>查询表是查询结果对应的表</li><li>视图表是由基本表或者其他视图表到处的表，是虚表，不对应实际存储的数据</li></ul><p>基本关系具有六条性质：</p><ul><li>列的同质性</li><li>列名唯一性</li><li>列序无关性</li><li>元祖相异性</li><li>行序无关性</li><li>分量原子性</li></ul><p>在实际关系数据库产品中，不一定完全会具备这几条性质</p><h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p>关系模式是型，关系是值</p><p>关系的描述称为关系模式 ，形式化表示为R(U,D,DOM,F)<br>其中R为关系名，U为组成该关系的属性名集合，D为属性组U中的属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合</p><h3 id="关系数据库-1"><a href="#关系数据库-1" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>关系数据库的型也称为关系数据库模式，是对关系数据库的描述。<br>关系数据库模式包括：</p><ul><li>若干域的定义</li><li>在这里域上定义的若干关系模式</li></ul><hr><h2 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h2><p>关系模型给出了关系操作能力的说明，但不对RDBMS给出具体的语法要求，也就是说不通的RDBMS可以定义和开发不通的语言来实现这些操作。</p><h3 id="基本的关系操作"><a href="#基本的关系操作" class="headerlink" title="基本的关系操作"></a>基本的关系操作</h3><p>通常分为两大操作：</p><ul><li>查询（query）</li><li>插入（insert）、删除（delete）、修改（update）</li></ul><p>关系的查询表达能力很强，是关系操作中最主要的部分。</p><p>查询操作又可以分为：选择（select）、投影（project）、链接（join）、除（divide）、并（union）、交（intersection）、笛卡尔积等<br>其中选择，投影，并，差，笛卡尔积是5种基本操作，其他操作可以由基本操作来定义和导出的。</p><p>关系操作的特点就是集合操作方式，即操作的对象和结果都是集合。也称为一次一集合（set-at-a-time）的方式，而非关系数据库模型的数据操作方式则为一次一记录（record-at-a-time）的方式。</p><h3 id="关系数据语言分类"><a href="#关系数据语言分类" class="headerlink" title="关系数据语言分类"></a>关系数据语言分类</h3><p>早期是用代数方式或逻辑方式表示，称为关系代数和关系演算</p><p>关系代数，元祖关系演算和域关系演算均为抽象的查询语言，跟具体的RDBMS中实现的语言不完全一样。</p><p>一种介乎于关系代数和关系演算之间的语言SQL，具有丰富的查询功能，还具有数据定义和数据控制功能，是集合了查询、DDL、DML和DCL于一体的关系数据语言。</p> <img src="/posts/486c9009/24.png"><hr><h2 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h2><p>关系模型的完整性规则是对关系的某种约束条件，也就是说关系的值随着时间变化时应该满足一些约束条件，这些条件实际上是现实世界的要求，任何关系都是需要时刻满足这些语义约束。</p><h3 id="关系的三类完整性约束"><a href="#关系的三类完整性约束" class="headerlink" title="关系的三类完整性约束"></a>关系的三类完整性约束</h3><h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><p>规则：若属性（一个或一组属性）A是基本关系R的主属性，那么A不能取空值</p><p>所谓空值就是“不知道”或“不存在”的值</p><p>规则说明：</p><ul><li>实体完整性是针对基本关系而言的</li><li>现实世界的实体是可区分的，即他们具有某种唯一标识</li><li>关系模型中以主码作为唯一标识</li><li>主码中的属性即主属性不能取空值。</li></ul><h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><ol><li><p>关系间的引用：在关系模型中实体及实体间的联系都是用关系来描述的，因此可能存在关系与关系间的引用。</p></li><li><p>外码</p><ul><li>设FALSE是基本关系R 的一个或一组属性，但不是关系R 的码。如果F与基本关系s的主码Ks相对应，则称F为基本关系R的外码</li><li>基本关系R称为参照关系</li><li>基本关系S称为被参照关系或目标关系</li><li>关系R和关系S不一定是不同的关系</li></ul> <img src="/posts/486c9009/25.png"></li></ol><ul><li><p>显然目标关系S的主码Ks和参照关系R的外码F必须定义在同一个（或同一组）域上。</p></li><li><p>注意的是，外码不一定要和相应的主码同名，不过在实际中，为了便于识别，尽量取相同的名字。</p></li></ul><p>所以参照完整性规则就是定义外码和主码之间的引用规则</p><p>参照完整性规则： 若属性（属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同关系），则对于R中每一个元祖在F上的值必须为</p><ul><li>或者取空值（F的每个属性值均为空值）</li><li>或者等于S中某个元祖的主码值</li></ul><p>具体如图</p> <img src="/posts/486c9009/26.png"><h4 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h4><p>不同的数据库系统根据应用环境的不同，还需要特殊的约束条件，而用户定义的完整性就是针对某一具体关系数据库的约束条件。</p><ul><li>针对某一具体关系数据库的约束条件，反应某一具体应用的所涉及的数据必须满足的语义要求</li><li>关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法去处理它们，而不要用程序来承担这一个功能</li></ul><hr><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><p>关系代数是一种抽象的查询语言，<br>运算对象，运算符，运算结果是运算的三大要素<br>关系代数的运算对象是关系，运算结果也是关系<br>运算符包括四类：集合运算符，专门的关系运算符，算术比较符，逻辑运算符。</p> <img src="/posts/486c9009/27.png" title="关系代数运算符"><p>关系代数的运算按运算符的不同可分为传统的集合运算符和专门的关系运算符。其中集合运算符是把关系看成元祖的集合。专门的关系运算符不仅涉及行还涉及列。比较运算符和逻辑运算符是用来辅助专门的关系运算符进行操作的。</p><h3 id="传统的集合运算"><a href="#传统的集合运算" class="headerlink" title="传统的集合运算"></a>传统的集合运算</h3><ol><li><p>并（Union）<br>关系 R 与 S 具有相同的关系模式，即 R 与 S 的元数相同（结构相同），R 与 S 的并是属于 R 或者属于 S 的元组构成的集合，记作 R ∪ S，定义如下：</p><center>R∪S = {t | t∈R ∨ t∈S}</center></li><li><p>差（Difference）<br>关系 R 与 S 具有相同的关系模式，关系 R 与 S 的差是属于 R 但不属于 S 的元组构成的集合，记作 R − S，定义如下</p><center>R−S = {t | t∈R∨t∉S}</center></li><li><p>交（Intersection）<br>关系R和关系S交由即属于R又属于S的元组组成， 其结果仍为n目关系</p><center>R∩S = {t | t∈R ∧ t∈S }</center></li><li><p>笛卡尔积（cartesian product）<br>两个无数分别为 n 目和 m 目的关系 R 和 S 的 笛卡尔积是一个 (n+m) 列的元组的集合。组的前 n 列是关系 R 的一个元组，后 m 列是关系 S 的一个元组，记作 R × S，定义如下：</p><center>R×S = { t | t =&lt; (tn,tm) ∧ tn∈R ∧ tm∈S}</center></li></ol> <img src="/posts/486c9009/28.png" title="并"> <img src="/posts/486c9009/29.png" title="差"> <img src="/posts/486c9009/30.png" title="交"> <img src="/posts/486c9009/31.png" title="笛卡尔积"><h3 id="专门的关系运算"><a href="#专门的关系运算" class="headerlink" title="专门的关系运算"></a>专门的关系运算</h3><p>专门的运算关系包括 选择、 投影、连接 、 除运算等。</p><p>先做几个记号</p> <img src="/posts/486c9009/32.png"> <img src="/posts/486c9009/33.png"> <img src="/posts/486c9009/34.png"><blockquote><p> 目=列数，n目或者n度指的是关系表有n个属性，也就是有n列</p></blockquote> <img src="/posts/486c9009/35.png"><ol><li><p>选择(selection)<br>定义：在关系R中选出满足指定条件F的元组(行操作)<br>表达式：σF(R) = {t | t∈R ∧ F(t)=’真’},<br>逻辑表达式F的基本形式为：X1 θ Y1<br>其中 θ 表示比较运算符或者逻辑运算符，X1、Y1等是属性名或常量或简单函数，而属性名也可以用它的序号来代替<br>比较运算符:<br>① ： &gt; 大于<br>② ： ≥ 大于等于<br>③ ： &lt; 小于<br>④ ： ≤ 小于等于<br>⑤ ： = 等于<br>⑥ ： &lt;&gt; 不等于</p><p>逻辑运算符：<br>┐ 非<br>∧ 与<br>∨ 或</p></li></ol><p>下图查询信息系（is系）全体学生</p> <img src="/posts/486c9009/36.png"><p>其中下角标 5 为Sdept的属性序号</p><ol start="2"><li>投影(projection)<br>定义：从关系R中选出若干属性A组成新关系(列操作)<br>表达式：πA(R) = { t[A] | t∈R}<br>其中A为R中的属性列<br>投影操作是从列的角度进行和运算的<br>投影之后不仅取消了原关系的某些列，还可能取消了某些元组，因为取消了某些属性后，就可能出现重复行，所以应该取消这些完全相同的行。</li></ol> <img src="/posts/486c9009/37.png"><ol start="3"><li><p>连接(join)<br>定义：从两个关系R和S的笛卡尔积中选取属性间满足指定条件AθB的元组<br>表达式：R∞S(AθB) = {t(r)t(s)|t(r)∈R∧t(s)∈S∧t(r)[A]θt(s)[B]}</p> <img src="/posts/486c9009/38.png"></li></ol> <img src="/posts/486c9009/39.png"> <img src="/posts/486c9009/40.png"> <img src="/posts/486c9009/41.png"> <img src="/posts/486c9009/42.png"><p>普通连接</p><center><br>关系R：<br>A　B　C<br><br>a　b　c<br>b　a　c<br>c　a　b<br><br>关系S:<br>A　B　C<br><br>b　a　 c<br>a　b　 c<br>c　a　 b<br><br>连接起来：<br>RA RB RC　SA SB SC<br><br>a　b　c 　 a　b　c<br>a　b　c 　 b　a　c<br>a　b　c 　 c　a　b<br>b　a　c 　 a　b　c<br>b　a　c 　 b　a　c<br>b　a　c 　 c　a　b<br>c　a　b 　 a　b　c<br>c　a　b 　 b　a　c<br>c　a　b 　 c　a　b<br><br></center><br>就是R的第一行不断的加S的第一行，第二行，第三行，<br>R的第二行不断的加以S的第一行，第二行，第三行<br>一直加下去<br><br>拓展关系：<br>连接分两种：等值连接与自然连接<br>①等值连接：指定条件AθB的θ为’= ‘时<br>那么就把上面普通连接里面RA和SB相同的保留，其他去掉，而且重复的两行也去掉一行<br><center><br>RA RB RC　SA SB SC<br>a　b　c 　 b　a　c<br>a　b　c 　 c　a　b<br>b　a　c 　 a　b　c<br></center><br>②自然连接：在等值连接的基础上去除重复的属性<br><center><br><br>A　B　C<br>a　b　c<br>a　b　c<br>b　a　c<br><br></center><ol start="4"><li>除运算(division)<br>定义：设关系R除以关系S的结果为关系T,则T包含所有在R但不在S中的属性及值,且T的元组与S的元组的所有组合都在R中.<br>表达式：<br>R÷S = {t(r)[X]|t(r)∈R∧π(Y)(S)属于Y(x)},其中Y(x)为x在R中的象集,x=t(r)[X]</li></ol> <img src="/posts/486c9009/43.png"> <img src="/posts/486c9009/44.png"><p>上面的演算经过有限次复合后形成的式子称为关系代数表达式</p><hr><h2 id="关系演算"><a href="#关系演算" class="headerlink" title="关系演算"></a>关系演算</h2><p>分为元组关系演算和域关系演算</p><h3 id="元组关系演算语言ALPHA"><a href="#元组关系演算语言ALPHA" class="headerlink" title="元组关系演算语言ALPHA"></a>元组关系演算语言ALPHA</h3><p>元组关系演算以元组变量作为谓词变元的基本对象。典型的元组关系演算语言是E.F.Codd提出的ALPHA语言，但这一语言并没有实际实现。现在关系库管理系统INGRES所用的QUEL语言是参会照ALPHA语言研制的，与ALPHA十分相似</p><p>基本格式中:操作语句主要有GET、PUT、HOLD、UPDATE、DELETE和DROP六条语句</p><p>ALPHA语言语句的基本格式是:</p><p>操作语句 工作空间名(表达式):操作条件</p><p>工作空间是用户与系统的通信区，它可以用一个字母表示，通常用W表示；表达式用于指定语句的操作对象，它可以是关系名和属性名，一条语句可以同时操作多个关系或多个属性；操作条件是一个逻辑表达式，它用于将操作结果限定在满足条件的元组中，操作条件可以为空；呆以在基本格式的基础上加上排序要求，定额要求等。</p><p>一、 检索操作</p><p>(1) 简单检索(即不带条件的检索)</p><p>格式： GET 工作空间名 （表达式1） 查询所有被选修的课程号码。<br>GET W (SC.Cno)</p><p>(2) 限定的检索(即带条件的检索)</p><p>格式： GET 工作空间名（表达式1） ：<br>操作条件 查询信息系(IS)中年龄小于20岁的学生的学号和年龄。<br> GET W (Student.Sno， Student.Sage):Student.Sdept=’IS’∧Student.Sage&lt;20</p><p>(3) 带排序的检索</p><p>格式： GET 工作空间名（表达式1） [：操作条件] DOWN/UP 表达式2<br>查询计算机科学系(CS)学生的学号、 年龄， 结果按年龄降序排序。<br> GET W (Student.Sno， Student.Sage): Student.Sdept=‘CS’DOWN Student.Sage</p><p>(4) 带定额的检索</p><p>格式 : GET 工作空间名（定额）（表达式1）[：操作条件] DOWN/UP 表达式2<br>取出一个信息系学生的学号。<br> GET W (1) (Student.Sno): Student.Sdept=’IS’</p><p>(5) 用元组变量的检索</p><ol><li>元组变量的含义<br>表示可以在某一关系范围内变化（也称为范围变量Range Variable）</li><li>元组变量的用途<br>简化关系名：设一个较短名字的元组变量来代替较长的关系名。<br>操作条件中使用量词时必须用元组变量。</li><li>定义元组变量<br>格式： RANGE 关系名 变量名</li></ol><p>一个关系可以设多个元组变量 查询信息系学生的名字<br>RANGE Student X<br>GET W (X.Sname):X.Sdept=‘IS’</p><p>(6) 用存在量词的检索</p><p>查询选修2号课程的学生名字。</p><p>RANGE SC X GET W (Student.Sname): ΕX(X.Sno=Student.Sno∧X.Cno=’2’)</p><p>查询至少选修一门其先行课为6号课程的学生名字<br>RANGE Course CX<br>　　　　SC　 SCX<br>GET W (Student.Sname):<br>∃ SCX (SCX.Sno=Student.Sno∧<br>∃ CX (CX.Cno=SCX.Cno∧CX.Pcno=’6’))</p><p>(7) 带有多个关系的表达式的检索</p><p>查询成绩为90分以上的学生名字与课程名字</p><p>RANGE SC SCX<br>GET W (Student.Sname， Course.Cname): ∃SCX (SCX.Grade≥90∧SCX.Sno=Student.Sno∧Course.Cno=SCX.Cno)</p><p>(8) 用全称量词的检索</p><p>查询不选1号课程的学生名字。<br> RANGE SC SCX<br>GET W (Student.Sname): ∀SCX(SCX.Sno≠Student.Sno∨SCX.Cno≠’1’)</p><p>(9) 用两种量词的检索</p><p>查询选修了全部课程的学生姓名。</p><p>RANGE Course 　CX<br>　　　　SC　　SCX<br>GET W (Student.Sname) : ∀ CX ∃ SCX (SCX.Sno=Student.Sno ∧ SCX.Cno = CX.Cno)</p><p>(10) 用蕴函（Implication） 的检索</p><p>查询最少选修了95002学生所选的课程的学生的学号</p><p>思路：依次检查每一门课程，看95002是否选了这门课，如果选了，再看看有没有其他学生选了这么课，遍历完后。看看是否存在学生把95002选了的课都选了，如果存在即符合。</p><p>RANGE Course CX<br>　　　　SC　SCX<br>　　　　SC　SCY<br>GET W(Student Sno):∀ CX ( ∃ SCX (SCX.Sno=’95002 ∧ SCX.Cno=CX.Cno)<br>　　　　　　　　　　→ ∃ SCY（SCY.Sno=Student.Sno ∧ SCY.Cno=CX.Cno))</p><p>(11) 聚集函数</p> <img src="/posts/486c9009/45.png"><p>查询学生所在系的数目。</p><p>GET W (COUNT(Student.Sdept))<br>COUNT函数在计数时会自动排除重复值。</p><p>二、更新操作</p><p>（1）修改操作<br>修改操作用UPDATE语句实现，步骤是：</p><ul><li>用HOLD语句将要修改的元组从数据库中读到工作空间中 HOLD 工作空间名（表达式1） [：操作条件 ]</li><li>用宿主语言修改工作空间中元组的属性</li><li>用UPDATE语句将修改后的元组送回数据库中</li></ul><p>把95007学生从计算机科学系转到信息系</p><p>HOLD W (Student.Sno， Student.Sdetp): Student.Sno=’95007 （从Student关系中读出95007学生的数据）<br>MOVE ‘IS’ TO W.Sdept （用宿主语言进行修改）<br>UPDATE W （把修改后的元组送回Student关系）</p><p>（2）插入操作</p><ul><li>用宿主语言在工作空间中建立新元组</li><li>用PUT语句把该元组存入指定关系中 PUT 工作空间名 （关系名）</li></ul><p>学校新开设了一门2学分的课程‚计算机组织与结构‛ ， 其课程号为8， 直接先行课为6号课程。 插入该课程元组</p><p>MOVE ‘8’ TO W.Cno<br>MOVE ‘计算机组织与结构’ TO W.Cname<br>MOVE ‘6’ TO W.Cpno<br>MOVE ‘2’ TO W.Ccredit<br>PUT W (Course)　　　　(把w中的元组插入到制定关系course中)</p><p>put语句只对一个关系操作，表达式必须为单个关系名</p><p>（3）删除</p><ul><li>用HOLD语句把要删除的元组从数据库中读到工作空间中</li><li>用DELETE语句删除该元组 DELETE 工作空间名</li></ul><p>95110学生因故退学， 删除该学生元组。</p><p>HOLD W (Student):Student.Sno=’95110’<br>DELETE W</p><hr><h3 id="域关系语言QBE"><a href="#域关系语言QBE" class="headerlink" title="域关系语言QBE"></a>域关系语言QBE</h3><p>域关系演算以元组变量的分量（即域变量）作为谓词变元的基本对象。最突出的特点是操作方式，它是一种高度非过程化的基于屏幕表格的查询语言，用户通过终端屏幕编辑程序，以填写表格的方式构造查询要求，而查询的结果也是以表格形式显示。</p><p>QEB中用示例元素来表示查询结构可能的情况，示例元素实际上就是域变量。以下就是QEB的操作框架：</p> <img src="/posts/486c9009/46.png"> <img src="/posts/486c9009/47.png"><hr><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>关系数据库是目前使用最广泛的数据库系统。<br>关系数据库与非关系数据库的区别：关系系统只有“表”这一种数据结构，而非关系数据库系统还有其他数据结构，以及对这些数据结构的操作。</p><hr><h1 id="关系数据库标准语言SQL"><a href="#关系数据库标准语言SQL" class="headerlink" title="关系数据库标准语言SQL"></a>关系数据库标准语言SQL</h1><blockquote><p>SQL—结构化查询语言，是关系数据库的标准语言，SQL是一个通用的，功能极强的关系数据库语言。</p></blockquote> <img src="/posts/486c9009/48.png"><h2 id="SQL特点"><a href="#SQL特点" class="headerlink" title="SQL特点"></a>SQL特点</h2><p>SQL语言之所以能够为用户和业界所接受，并成为国际标准，是因为它是一个综合的、功能极强同时又简捷易学的语言。SQL语言集数据查询、数据操纵、数据定义和数据控制功能于一体，主要特点包括：</p><ol><li><p>综合统一<br>SQL集合数据定义、数据操纵、数据控制于一体，语言风格统一。可以独立完成数据库生命周期中的全部活动</p><ul><li>定义关系模式，插入数据，建立数据库</li><li>对数据库中的数据进行查询和更新</li><li>数据库重构和维护</li><li><p>数据库安全性、完整性控制</p><p>在关系模型中实体和实体间的联系均用关系表示，这种数据结构的单一性带来了数据操作符的统一性，查找、插入、删除、更新等每一种操作都只需要一种操作符</p></li></ul></li></ol><ol start="2"><li><p>高度非过程化</p></li><li><p>面向集合的操作方式<br>SQL采用集合操作方式，不仅操作对象、查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合。</p></li><li><p>以同一种语法结构提供多种使用方式<br>SQL即使独立的语言，也是嵌入式语言。既可以在终端键盘直接输入SQL命令进行数据库操作，也可以嵌入到高级语言，如C、Java程序中提供给程序员使用。这种统一的语法提供多种不同的使用方式的做法，提供了极大的灵活性与方便性。</p></li><li><p>语言简洁，易学易用<br>核心功能只有九个动词，如下图所示</p> <img src="/posts/486c9009/49.png"></li></ol><h2 id="SQL基本概念"><a href="#SQL基本概念" class="headerlink" title="SQL基本概念"></a>SQL基本概念</h2><p>SQL语言支持关系数据库三级模式结构。其中外模式对应于视图和部分基本表，模式对应于基本表，内模式对应于存储文件。</p><p>SQL支持关系数据库三级模式结构，如下：</p> <img src="/posts/486c9009/50.png"><ul><li>基本表：独立存储于数据库中的数据表（关系），可有若干个索引。</li><li>索引：对表中的属性组进行逻辑上排序，可以加快检索速度。</li><li>视图：由基表导出的虚表，数据库中只保存视图的定义。</li><li>存储文件：以OS文件的形式保存数据库的表、视图、索引等数据库对象。</li></ul><hr><h2 id="学生-课程数据库"><a href="#学生-课程数据库" class="headerlink" title="学生-课程数据库"></a>学生-课程数据库</h2><p>学生-课程模式 S-T :</p><ul><li>学生表：Student(Sno,Sname,Ssex,Sage,Sdept)</li><li>课程表：Course(Cno,Cname,Cpno,Ccredit)</li><li>学生选课表：SC(Sno,Cno,Grade)</li></ul> <img src="/posts/486c9009/51.png" title="Student表"> <img src="/posts/486c9009/52.png" title="Course表"> <img src="/posts/486c9009/53.png" title="SC表"><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>SQL的数据定义功能包括了：</p><hr><p>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一<br>｜　　　　　　｜　　　　　　　操作方式　　　　　　　　　　　　　｜<br>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一<br>｜　操作对象　｜　　 创建　　 　 　｜　　删除　　　 ｜ 　 　 修改 　｜<br>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一<br>｜　　模式　　｜CREATE SCHEMA ｜DROP SCHEMA　｜　ｘｘｘ　　　｜<br>｜　　表　　　｜CREATE TABLE　 ｜DROP TABLE 　　｜ALTER TABLE ｜<br>｜　　视图　　｜CREATE VIEW 　 ｜ DROP VIEW　 　｜　ｘｘｘ 　 　｜<br>｜　　索引　　｜CREATE INDEX 　｜DROP INDEX　　｜　ｘｘｘ　　　｜<br>一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一</p><hr><p>SQL通常不提供修改模式定义、修改视图定义和修改索引定义的操作，如有要修改，只能先删除再重建。</p><h3 id="模式的定义和删除"><a href="#模式的定义和删除" class="headerlink" title="模式的定义和删除"></a>模式的定义和删除</h3><p>一、定义模式<br>“模式”是一个数据库的命名空间，一个框架，打个比方：在java中，创建模式相当于创建一个包，而创建表相当于创建一个类，一个类是在某一个包下面进行管理的。在mysql中，创建模式与创建数据库是一样的，也就是create schema &lt;模式名&gt;与 create database &lt;数据库名&gt;是等效的。所以模式的定义与删除语句如下：</p><blockquote><p>create schema &lt;模式名&gt; authorization &lt;用户名&gt;</p></blockquote><p>例如创建一个学生-课程的模式S-T<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create schema &quot;S-T&quot; authorization wang;//为用户wang创建一个模式S-T</span><br></pre></td></tr></table></figure><p></p><p>删除模式语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop schema &lt;模式名&gt; &lt;cascade|restrict&gt;</span><br></pre></td></tr></table></figure><p>其中cascade与restrict两者必选其一。</p><p>cascade(级联)，表示删除模式的同时，把该模式中的所有数据库对象（例如表等）也全部删除。</p><p>restrict（限制），表示如果该模式下已经定义了下属的数据库对象（如表、视图等），则拒绝执行该删除语句的执行<br>还可以在创建模式的时候同时在这个模式定义中进一步创建基本表，视图，定义授权，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create schema &lt;模式名&gt; authorization &lt;用户名&gt; [&lt;表定义子句&gt; | &lt;视图定义子句&gt; |&lt;授权定义子句&gt;]</span><br></pre></td></tr></table></figure><p>例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE SCHEMA TEST AUTHORIZATION ZHANG</span><br><span class="line">	 CREATE TABLE TAB1(COL1 SMALLINT,</span><br><span class="line">			   COL2 INT,</span><br><span class="line">			   COL3 CHAR(20),</span><br><span class="line">			   COL4 NUMERIC(10,3),</span><br><span class="line">			   COL5 DECIMAL(5,2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该语句为用户ZHANG创建了一个模式TEST，并且定义了一个表TAB1</p><p>二、删除模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP SCHEMA　&lt;模式名&gt; &lt; CASCADE | RESTRICT &gt;</span><br></pre></td></tr></table></figure><p>其中CASCADE ：级联删除。即：删除模式的同时把模式中所有的数据库对象（模式中定义的下属数据库对象）全部删除</p><p>RESTRICT：限制删除。即：删除模式时，如果模式中已定义下属数据库对象，则拒绝删除。</p><p>这两个必须二选一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP SCHEMA ZHANG CASCADE</span><br></pre></td></tr></table></figure><p>该语句删除了模式ZHANG，同时定义的TAB1也被删除了</p><h3 id="基本表的定义、删除与修改"><a href="#基本表的定义、删除与修改" class="headerlink" title="基本表的定义、删除与修改"></a>基本表的定义、删除与修改</h3><p>一、定义基本表</p><p>基本格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;表名&gt;(&lt;列名&gt; &lt;数据类型&gt;[列级完整性约束条件] </span><br><span class="line">                   [,&lt;列名&gt; &lt;数据类型&gt;[列级完整性约束条件]]  </span><br><span class="line">                    .......</span><br><span class="line">                   [,&lt;表级完整性约束条件&gt; ])；</span><br></pre></td></tr></table></figure><p>例子：执行完语句后，会在数据库中建立一个新的空的“学生”表Student，并将有关“学生”表的定义及有关约束条件存放到数据字典中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">	( sno <span class="built_in">CHAR</span>(<span class="number">9</span>) PRIMARY <span class="keyword">KEY</span>,  <span class="comment">/* 列级完整性约束条件，Sno是主码*/</span></span><br><span class="line">	 Sname <span class="built_in">CHAR</span>(<span class="number">20</span>)  <span class="keyword">UNIQUE</span> ,    <span class="comment">/* Sname取唯一值*/</span></span><br><span class="line">	 Ssex <span class="built_in">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">	 Sage SMALINT,</span><br><span class="line">	 Sdept <span class="built_in">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">	);</span><br></pre></td></tr></table></figure><p>二、数据类型<br> 关系模型中重要的概念是域，每一个属性来自一个域，它的取值必须是域中的值。在SQL中域的概念用数据类型来实现，不同的RDBMS在支持的数据类型不完全相同。<br>一个属性选用哪种数据类型要根据实际情况来决定，一般考虑两个方面，一是取值范围，二是要什么什么运算。<br>下面是MySQL 数据类型：：文本、数字和日期/时间类型。<br> Text 类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CHAR(size):保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符.</span><br><span class="line"></span><br><span class="line">VARCHAR(size):保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。</span><br><span class="line">注释：如果值的长度大于 255，则被转换为 TEXT 类型。</span><br><span class="line"></span><br><span class="line">TINYTEXT:存放最大长度为 255 个字符的字符串。</span><br><span class="line"></span><br><span class="line">TEXT:存放最大长度为 65,535 个字符的字符串。 </span><br><span class="line"></span><br><span class="line">BLOB:用于 BLOBs (Binary Large OBjects)。存放最多 65,535 字节的数据。</span><br><span class="line"></span><br><span class="line">MEDIUMTEXT:存放最大长度为 16,777,215 个字符的字符串。</span><br><span class="line"></span><br><span class="line">MEDIUMBLOB:用于 BLOBs (Binary Large OBjects)。存放最多 16,777,215 字节的数据。</span><br><span class="line"></span><br><span class="line">LONGTEXT:存放最大长度为 4,294,967,295 个字符的字符串。</span><br><span class="line"></span><br><span class="line">LONGBLOB:用于 BLOBs (Binary Large OBjects)。存放最多4,294,967,295 字节的数据</span><br><span class="line"></span><br><span class="line">ENUM(x,y,z,etc.)：允许你输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。</span><br><span class="line">注释：这些值是按照你输入的顺序存储的。</span><br><span class="line">可以按照此格式输入可能的值：ENUM(&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;)</span><br><span class="line"></span><br><span class="line">SET：与 ENUM 类似，SET 最多只能包含 64 个列表项，不过 SET 可存储一个以上的值。 |</span><br></pre></td></tr></table></figure><p> Number 类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TINYINT(size)：-128 到 127 常规。0 到 255 无符号*。在括号中规定最大位数。</span><br><span class="line"></span><br><span class="line">SMALLINT(size)：-32768 到 32767 常规。0 到 65535 无符号*。在括号中规定最大位数。</span><br><span class="line"></span><br><span class="line">MEDIUMINT(size)：-8388608 到 8388607 普通。0 to 16777215 无符号*。在括号中规定最大位数。</span><br><span class="line"></span><br><span class="line">INT(size)：-2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数。</span><br><span class="line"></span><br><span class="line">BIGINT(size)：-9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。</span><br><span class="line"></span><br><span class="line">FLOAT(size,d)：带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。</span><br><span class="line"></span><br><span class="line">DOUBLE(size,d)：带有浮动小数点的大数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。</span><br><span class="line"></span><br><span class="line">DECIMAL(size,d)：作为字符串存储的 DOUBLE 类型，允许固定的小数点。</span><br></pre></td></tr></table></figure><ul><li>这些整数类型拥有额外的选项 UNSIGNED。通常，整数可以是负数或正数。如果添加 UNSIGNED 属性，那么范围将从 0 开始，而不是某个负数。</li></ul><p>Date 类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATE() : 日期。格式：YYYY-MM-DD</span><br><span class="line">注释：支持的范围是从 &apos;1000-01-01&apos; 到 &apos;9999-12-31&apos;</span><br><span class="line"></span><br><span class="line">DATETIME() : *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS</span><br><span class="line">注释：支持的范围是从 &apos;1000-01-01 00:00:00&apos; 到 &apos;9999-12-31 23:59:59&apos;</span><br><span class="line"></span><br><span class="line">TIMESTAMP() : *时间戳。TIMESTAMP 值使用 Unix 纪元(&apos;1970-01-01 00:00:00&apos; UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS</span><br><span class="line">注释：支持的范围是从 &apos;1970-01-01 00:00:01&apos; UTC 到 &apos;2038-01-09 03:14:07&apos; UTC</span><br><span class="line"></span><br><span class="line">TIME() : 时间。格式：HH:MM:SS 注释：支持的范围是从 &apos;-838:59:59&apos; 到 &apos;838:59:59&apos; </span><br><span class="line"></span><br><span class="line">YEAR() : 2 位或 4 位格式的年。</span><br><span class="line">注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。</span><br></pre></td></tr></table></figure><p>三、模式与表</p><p>每一个基本表都属于某一个模式，一个模式包含多个基本表<br>定义表所属的模式，有三种方法</p><ul><li><p>方法一：在表明中给出模式名<br>CREATE table “S-T”.Student(…..); 　　　/ <em>Student所属的模式是S-T</em>/<br>CREATE table “S-T”.Course(……); 　　　/ <em>Course所属的模式是S-T</em>/<br>CREATE table “S-T”.SC(…….); 　　　　 / <em>SC所属的模式是S-T</em> /</p></li><li><p>方法二：在创建模式语句中同时创建表，在定义模式的例子里可以看到</p></li><li><p>方法三：设置所属的模式，这样创建表时不用给出模式名</p></li></ul><p>当用户创建基本表的时候没指定模式，那么系统会搜索路径来确定所属模式，如果路径包含一组模式列表，则使用第一个存在的模式作为对象的模式名。如果路径中的模式名都不存在，系统就给出错误。</p><p>四、修改基本表</p><p>SQL语言用ALTER TABLE来修改基本表，一般格式为：<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">ADD</span> &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]];</span><br><span class="line">[<span class="keyword">DROP</span> &lt;完整性约束名&gt;];</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span>&lt;列名&gt; &lt;数据类型&gt;];</span><br></pre></td></tr></table></figure><p></p><p>&lt;表名&gt;是要修改的基本表，ADD子句用于增加新列和新的完整性约束，DROP子句用于删除指定的完整性约束条件，ALTER COLUMN 子句用于修改原有的列定义，包括列名和数据类型</p><p>例子：向Student表中增加“入学时间”列，其数据类型为日期型</p><p>ALETER TABLE Student ADD_S_ENTRANCE DATE;</p><p>不论基本表是否原来有数据，新增加的一列均为日期型</p><p>五、删除基本表</p><p>当某个表不再需要时，用DROP TABLE语句删除它，格式为</p><p>DROP TABLE &lt;表名&gt; [ RESTRICT | CASCADE ];</p><p>若选择RESTRICT，则该表的删除是有限制条件,不能被其他表的约束所引用，也不能有视图，触发器，存储过程或函数等</p><p>若选择CASCADE，则没有限制条件，删除基本表的时候，相关的依赖对象也会一起删除，例如视图等</p><p>缺省的情况的是RESTRICT。</p><p>例子：删除Student表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> Student <span class="keyword">CASCADE</span>；</span><br></pre></td></tr></table></figure><p>基本表定义一旦被删除，不仅表中数据和定义被删除，而且表上建立的索引、视图、触发器等有关对象也一般会被删除。所以执行该操作需要特别小心</p><hr><h3 id="索引的建立与删除"><a href="#索引的建立与删除" class="headerlink" title="索引的建立与删除"></a>索引的建立与删除</h3><p>建立索引是加快查询速度的有效手段，根据需要，在基本表上建议一个或者多个的索引，以提供多种存取路径，加快查找速度。<br>但是索引也有不适宜的情况，原因是建立索引后，更新索引上的数据时会导致表中记录的物理顺序的变更，代价较大，且会占用一定的系统资源，因此对于经常更新的列不宜建立索引。</p><p>建议建立索引的情况：</p><ul><li>主码和外码一般会建立索引</li><li>以读为主或只读的表，只要空间允许可以建立多个索引</li><li>等值查询，且满足条件的元组数小于总元组数的5%，可以考虑在相关属性上建立索引</li><li>范围查询</li></ul><p>不建议建立索引的情况：</p><ul><li>不出现或很少出现查询的属性</li><li>属性值很少的属性</li><li>属性值分布严重不均的属性</li><li>经常更新的属性或表</li><li>过长的属性</li><li>太小的表</li></ul><p>一般建立与删除索引是有数据库管理员或者表的属主（owner），即建立表的人完成。系统存取数据时自动选择合适的索引作为存取路径，用户不必也不能显式的选择索引 。</p><p>一、建立索引</p><p>建立索引的一般格式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>][cluster]<span class="keyword">index</span>&lt;索引名&gt;</span><br><span class="line"><span class="keyword">on</span> &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]...);</span><br></pre></td></tr></table></figure><p>其中，表名是要建立索引的基本表的名字。索引可以建立在一列或多列上，每个&lt;列名&gt;后面还可以用&lt;次序&gt;指定索引值的排列次序，可选ASC（升序）或DESC（降序），缺省值为ASC。<br>unique表示此索引的每一个索引值只对应唯一的数据记录。<br>cluster表示要建立的索引是聚簇索引。所谓聚簇索引是指索引项的数据与表中记录的物理顺序一致的索引组织。</p><p>例：在Student表上的姓名列建立一个聚簇索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> cluster <span class="keyword">index</span> Stusname</span><br><span class="line"><span class="keyword">on</span> Student(Sname);</span><br></pre></td></tr></table></figure><p>例：在sc表的Sno(升序), Cno(升序)和grade (降序)三列上建立一个普通索引SCno。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> SCno</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">table</span> SC(Sno,Cno,Grade <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure><p>二、删除索引</p><p>索引一旦建立，就由系统使用和维护它，不需要用户干预。建立索引是为了减少查询操作的时间。但如果数据增删改查频繁，就会浪费很多时间来维护索引，从而降低了查询效率，可以通过删除一些不必要的索引。</p><p>删除索引的一般格式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span>&lt;索引名&gt;;</span><br></pre></td></tr></table></figure><p>例：删除Student表上的Stusname索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> Stusname;</span><br></pre></td></tr></table></figure><p>删除索引时，系统会同时从数据字典中删去有关该索引的描述。</p><p>在RDBMS中索引一般采用B+树，HASH索引来实现，B+树索引具有动态平衡的优点。HSAH索引具有查找速度快的特点。索引是关系数据库的内部实现技术，属于内模式的范畴。</p><p>用户使用CREATE INDEX 语句定义索引的时候，可以定义索引是唯一索引、非唯一索引或者聚簇索引。至于某一个索引是采用B+树还是HASH索引则由具体的RDBMS来决定。</p><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p>数据库查询是数据库的核心操作</p><p>一般格式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [ALL | <span class="keyword">DISTINCT</span>] &lt;目标列表达式&gt;  [，&lt;目标列表达式&gt;]  ...</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名或者视图名&gt; [，&lt;表名或者视图名&gt;] ....</span><br><span class="line">[<span class="keyword">WHERE</span> &lt;条件表达式&gt;] </span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;列名<span class="number">1</span>&gt;[<span class="keyword">HAVING</span> &lt;条件表达式&gt;] ]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;列名<span class="number">2</span>&gt; [ <span class="keyword">ASC</span> | <span class="keyword">DESC</span> ] ]；</span><br></pre></td></tr></table></figure><p>根据where子句的条件表达式，从from子句指定基本表或者视图找出满足条件的元组，再按select子句中的目标列表达式，选出元组的属性值形成结果表</p><p>如果有group by子句，则将结果按&lt;列名1&gt;的值进行分组，该属性列值相等的元组为一个组。通常用在每组中作用聚集函数。如果group by子句滴啊有having短语，则只有满足指定条件的组才予以输出。</p><p>如果有order by子句，则结果表还要按照&lt;列名2&gt;的值升序或者降序排序。</p><hr><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>单表查询是指仅涉及一个表的查询</p><p>一、选择表中的若干列</p><p>选择表中的全部列或者部分列，就是关系代数的投影运算</p><ol><li><p>查询制定列<br>在很多情况下，用户只需要一部分属性列，通过在select子句&lt;目标列表达式&gt;中指定要查询的属性列。<br>例子1 查询全体学生的学号和姓名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno ,Sname</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure></li></ol><pre><code>该语句的执行过程：从Student表中取出一个元组，在该元组属性Sno和Sname上取值，形成一个新的元组走位输出。对表中所有元组做相同的处理，最后形成一个结果关系作为输出。

例子2

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname ,Sno ,Sdept</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure> &lt;目标列表达式&gt;中各个列的先后顺序可以与表中的顺序不一致，根据需要改变列的显示顺序。</code></pre><ol start="2"><li><p>查询全部列<br>将表中所有属性列出来，两种方法<br>第一种是在关键字后面把所有列都列出来<br>第二种就是指定为 * 这个符号。<br>例子：查询全体学生详细记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br></pre></td></tr></table></figure><p> 等价于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">SELECT</span> Sno ,Sname,Ssex ,Sage, Sdept</span><br><span class="line"><span class="keyword">FROM</span> Studetn;</span><br></pre></td></tr></table></figure></li><li><p>查询经过计算的量<br>SELECT 子句的&lt;目标列表达式&gt;不仅可以是表中的属性列，也可以是表达式</p><p> 例子：查询全体学生的姓名及其出生年份</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname ,<span class="number">2004</span>- Sage        <span class="comment">/*查询结果的第二列是一个算术表达式*/</span></span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure><p> 例子 查询全体学生的姓名、出生年份和所在院系，要求用小写字母表示所有系名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname ,<span class="string">'Year of Birth:'</span>  <span class="number">2004</span>-Sage ,<span class="keyword">LOWER</span> (Sdept)</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure><p> 结果为</p><p> Sname 　　　‘Year of Birth:’　　 　2004-Sage　　　　　LOWER (Sdept)<br> ————————————————————————————————————<br> 刘勇　　　　‘Year of Birth:’　　　　　1984　　　　　　　　cs<br> 刘晨　　　　‘Year of Birth:’　　　　　1985　　　　　　　　cs<br> 王敏　　　　‘Year of Birth:’　　　　　1986　　　　　　　　ma<br> 张立　　　　‘Year of Birth:’　　　　　1985　　　　　　　　is<br> ————————————————————————————————————</p><p> 还可以通过指定别名来改变查询结果的列标题<br> 修改如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname ,<span class="string">'Year of Birth:'</span> BIRTH ,<span class="number">2004</span>-Sage BIRTHDAY,<span class="keyword">LOWER</span> (Sdept) DEPARTMENT</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure><p> 结果为</p><p> Sname 　　 　BIRTH　　 　 　　　BIRTHDAY　　　　　DEPATMENT<br> ————————————————————————————————————<br> 刘勇　　　　‘Year of Birth:’　　　　　1984　　　　　　　　cs<br> 刘晨　　　　‘Year of Birth:’　　　　　1985　　　　　　　　cs<br> 王敏　　　　‘Year of Birth:’　　　　　1986　　　　　　　　ma<br> 张立　　　　‘Year of Birth:’　　　　　1985　　　　　　　　is<br> ————————————————————————————————————</p></li></ol><p>二、选择表中的若干元组</p><ol><li>消除取值重复的行<br>两个本来并不完全相同的元组，投影到制定的某些列上后，就可能变成了相同的行了，可以用DISTINCT取消他们。</li></ol><p>例子 查询选修了课程的学生学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br></pre></td></tr></table></figure><p>输出结果为：<br>　　Sno<br>——————<br>200215121<br>200215121<br>200215121<br>200215122<br>200215122</p><p>如果为了去掉重复的行，必须制定DISTINCT关键词</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br></pre></td></tr></table></figure><p>输出结果为<br>　　Sno<br>——————<br>200215121<br>200215122</p><p>如果没有指定DISTINCT关键词，那么缺省为ALL，则保留结果中重复的行</p><ol start="2"><li>查询满足条件的元组<br>查询满足指定条件的元组可以通过where子句实现，</li></ol><p>　　　　　　　　　　　　　　　　常用的查询条件<br>——————————————————————————————————————<br>查询条件　　　　　　　　　　　　　谓词　　　　　　　　　　　　　　　<br>——————————————————————————————————————<br>比较　　　　　　　　=，&gt;，&lt;,&lt;=,&gt;=,!=,&lt;&gt;,!&gt;,!&lt;;NOT + 上述比较运算符<br>确定范围　　　　　　BETWEEN AND,NOT BETWWEN AND<br>确定集合　　　　　　IN, NOT IN<br>字符匹配　　　　　　LIKE , NOT LIKE<br>空值　　　　　　　　IS NULL , IS NOT NULL<br>多重条件（逻辑运算） AND, OR , NOT<br>——————————————————————————————————————</p><p>（1）比较大小<br>用于进行比较的运算符一般包括<br>=（等于），&gt;（大于），&lt;（小于）, &lt;=（小于等于）, &gt;=（大于等于）,!=（不等于）或 &lt;&gt;（不等于）, !&gt;（不大于）, !&lt;（不小于）;</p><p>（2）确定范围<br>谓词BETWEEN…AND….相对谓词是NOT BETWEEN …ADN….</p><p>例子 查询年龄不在20~23之间的学生姓名、系别和年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname ,Sdept,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">23</span>;</span><br></pre></td></tr></table></figure><p>（3）确定集合<br>谓词IN可以用来查找属性值属于指定集合的元组</p><p>例子 查询计算机科学系（CS）、数学系（MA）和信息系（IS）学生的姓名和性别<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname ,Ssex</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="keyword">IN</span>(<span class="string">'CS'</span> , <span class="string">'MA'</span> , <span class="string">'IS'</span>);</span><br></pre></td></tr></table></figure><p></p><p>（4）字符匹配<br>谓词LIKE可以用来进行字符串的匹配，一般格式为：<br>[NOT] LIKE ‘&lt;匹配符&gt;’ [ESCAPE’ &lt;换码字符&gt;’]<br>其含义是查找指定的属性列值与&lt;匹配串&gt;相匹配的元组。&lt;匹配串&gt;可以是一个完整的字符串，也可以是含有通配符%和 _ 其中：</p><ul><li>% (百分号)代表任意长度的字符串,例如a%b表示以a开头，以b结尾的任意长度的字符串，如acb、addgb、ab等都满足该匹配</li><li>_ (下横线)代表任意单个字符，例如 a_b表示以a开头，以b结尾的的长度为3的任意字符串，如acb、adb、asb等都满足。注意的是一个汉字占用两个字符。所以匹配汉字的时候需要两个下横线。</li></ul><p>例子 ： 查询学号为200212121的学生的详细情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Soo <span class="keyword">LIKE</span> <span class="string">'200215121'</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">等价于</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">sql</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno =<span class="string">'200215121'</span></span><br></pre></td></tr></table></figure><p>如果like后面的匹配串不含通配符，则可以用 =（等于）运算符取代like谓词，用！=或&lt;&gt; 运算符取代NOT LIKE</p><p>如果用户查询的字符串本身就含有通配符 % 或 _ ,这时候就要用escape ‘&lt;换码字符&gt;’短语，对通配符进行转义了。</p><p>例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Cno,Ceredit</span><br><span class="line"><span class="keyword">FROM</span> Course</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="keyword">LIKE</span> <span class="string">'DB\_Design'</span> ESCAPE <span class="string">'\' ;</span></span><br></pre></td></tr></table></figure><p>这里就是escape ‘\’表示把’\’表示为转码字符，这样匹配串中紧跟在 ‘\’ 后面的字符 ‘<em>‘ 不在具有通配符的含义<br>转义为普通的 ‘</em>‘ 字符</p><p>（5）涉及空值的查询<br>例：某些学生选修课程后没有参加考试，所以有选课记录没有考试成绩，查询缺少成绩的学生的学号和相应的课程号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno , Cno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="keyword">IS</span> NULLL  <span class="comment">/*  分数是grade是空值*/</span></span><br></pre></td></tr></table></figure><p>这里的IS不能用 = 来代替</p><p>（6）多重条件查询<br>逻辑运算符AND 和OR可用联结多个查询条件，AND 的优先级高于OR，但用户可以用括号来改变优先级</p><p>例 查询计算机科学系年龄在20岁以下的学生姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept = <span class="string">'CS'</span> <span class="keyword">AND</span> Sage &lt;<span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>三、 ORDER BY子句</p><p>用户可以用ORDER BY子句对查询结果按照一个或者多个属性的升序（ASC）或降序（DESC）排列，缺省值为升序</p><p>例 查询小选修了3号课程的学生的学号和成绩，查询结果按分数的降序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Grade</span><br><span class="line"><span class="keyword">FROM</span> SC </span><br><span class="line"><span class="keyword">WHERE</span> Cno=<span class="string">'3'</span></span><br><span class="line">RODER <span class="keyword">BY</span> Grade <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>对于空值，若按升序排，含空值的元组将最后显示，若按降序排，空值的元组将最先显示。</p><p>四、 聚集函数 （aggregate functions）</p><p>为了增强检索功能，sql提供许多聚集函数</p><p>1 count : 行数</p><p>2 sum : 总和 （求总和）</p><p>3 avg : 平均值</p><p>4 max 最大值</p><p>5 min : 最小值</p><p>例： 查询选修了课程的学生人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span> (<span class="keyword">DISTINCT</span> Sno)</span><br><span class="line"><span class="keyword">FROM</span> SC;</span><br></pre></td></tr></table></figure><p>学生每选修一门课，在sc中都有一条相应的记录，一个学生要选修多门课程，为避免重复计算学生人数，必须在count函数中用distinct短语</p><p>例：计算1号课程的学生平均成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span> (Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno= <span class="string">'1'</span>;</span><br></pre></td></tr></table></figure><p>例： 查询学生200215012选修课程的总分数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(Ceredit)</span><br><span class="line"><span class="keyword">FROM</span> SC ,Course</span><br><span class="line"><span class="keyword">WHERE</span> Sno= <span class="string">'200215012'</span> <span class="keyword">AND</span> SC.Cno=Course.Cno</span><br></pre></td></tr></table></figure><p>在聚集函数遇到空值时，除COUNT(*)外，都跳过空值而处理非空值</p><p>五、GROUP BY子句</p><p>GROUP BY 子句将查询结果按某一列或多列的值分组，值相等的为一组<br>对查询结果分组的目的是为了细化聚集函数的作用对象，如果未对查询结果分组，聚集函数将作用于整个查询结果。</p><p>例子 查询各个课程号及其相应的选课人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Cno ,<span class="keyword">COUNT</span> (Sno)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Cno;</span><br></pre></td></tr></table></figure><p>该语句是对查询结果按Cno的值分组，所有具有相同Cno值的元组为一组，对每一组进行聚集函数count计算，以求得该组的学生人数</p><p>查询结果可能为</p><p>Cno　　　　　　　　COUNT(Sno)<br>————————————————————————————<br> 　1　　　　　　　　　　22<br>　 2　　　　　　　　　　34<br>　 3　　　　　　　　　　44<br>　 4　　　　　　　　　　33<br>　 5　　　　　　　　　　48<br>————————————————————————————</p><p>如果分组后还要按照一定的条件去进行筛选，最终只输出满足指定条件的组，则可以使用HAVING 短语指定筛选条件</p><p>查询选修了3门以上的课程的学生学号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno</span><br><span class="line">FROM SC</span><br><span class="line">GROUP BY Sno</span><br><span class="line">HAVING COUNT (*) &gt;3;</span><br></pre></td></tr></table></figure><p>先用group by按Sno进行分组，再用聚集函数COUNT对每一组计算。HAVING短语给出了选择组的条件，且只有满足条件（即元组个数&gt;3），表示此学生选修的课超过3门的才会选出来</p><p>WHERE子句与HAVING子句区别在于作用对用不同，WHRE子句作用于基本表或视图，从中选择满足条件的与阿奴，HAVING短语作用于组，从中选择满足条件的组。</p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>若查询同时设计到两个以上的表，则称之为连接查询</p><p>连接查询是关系数据库中最主要的查询，包括了等值连接查询，自然连接查询，非等值连接查询，自身连接查询，外连接查询和符合条件连接查询等</p><p>一、 等值与非等值连接查询</p><p>连接查询的WHERE子句用来连接两个表的条件称为 连接条件 或 连接谓词，起一般格式为：</p><p>[&lt;表名1&gt;] &lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;]&lt;列名2&gt;</p><p>其中比较运算符主要有： =、&gt;、&lt; 、 &gt;= 、&lt;=、 != (或&lt;&gt;)</p><p>还可以用以下格式：<br>[&lt;表名1&gt;] &lt;列名1&gt; BETWEEN [&lt;表名2&gt;]&lt;列名2&gt; AND [&lt;表名2&gt;]&lt;列名3&gt;</p><p>当连接运算符为 = 时，称为等值连接，使用其他运算符时为非等值连接</p><p>连接谓词中的列名称为连接字段，连接条件中的各连接字段类型必须是可比的，但名字不必相同。</p><p>例子 查询每个学生及其选修课程的情况</p><p>学生情况存放在Student表中，学生选课情况存在SChema表中，所以本查询实际上涉及Student和SC两个表， 这两个表之间的联系是通过公共属性Sno实现的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student *  , SC . *  </span><br><span class="line"><span class="keyword">FROM</span>  Student ,SC</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno =SC.Sno;     <span class="comment">/* 将Student和SC中同一个学生的元组连接起来*/</span></span><br></pre></td></tr></table></figure><p>假设 Student表和SC表的数据如上面 学生-课程数据库的表一样</p><p>那么执行结果如下：</p><p>Student.Sno 　Sname　Ssex 　Sage 　Sdept　SC.Sno　Cno　Grade<br>————————————————————————————————————<br>200215121　　李勇　 男　　　20　　CS　200215121 　 1　　92<br>200215121　　李勇　　男　　　20　　CS　200215121 　 2　　85<br>200215121　　李勇　 男　　　20　　CS　200215121 　 3　　88<br>200215122　　刘晨　 女　　　19　　CS　200215122 　 2　　90<br>200215122　　刘晨　 女　　　19　　CS　200215122 　 3　　80<br>————————————————————————————————————</p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>Just for fun!</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Qsx 微信支付"><p>微信支付</p></div></div></div></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-paw"></i> 文章已经到尾<i class="fa fa-paw"></i> -------------</div></div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/学习/" rel="tag"># 学习</a> <a href="/tags/数据库/" rel="tag"># 数据库</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/115b549a.html" rel="next" title="iBatis"><i class="fa fa-chevron-left"></i> iBatis</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Qsx"><p class="site-author-name" itemprop="name">Qsx</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">11</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Shelhon" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:ppp00qqq@163.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="http://weibo.com/qsxmybaby" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i> 微博</a></span><span class="links-of-author-item"><a href="https://zhihu.com/people/shelhon" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i> 知乎</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://www.kofes.cn/" title="cz" target="_blank">cz</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#绪论"><span class="nav-number">1.</span> <span class="nav-text">绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库系统概述"><span class="nav-number">1.1.</span> <span class="nav-text">数据库系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、基础概念"><span class="nav-number">1.1.1.</span> <span class="nav-text">一、基础概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、-数据库系统的特点"><span class="nav-number">1.1.2.</span> <span class="nav-text">二、 数据库系统的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据模型"><span class="nav-number">1.2.</span> <span class="nav-text">数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据模型的组成要素"><span class="nav-number">1.2.1.</span> <span class="nav-text">数据模型的组成要素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念模型"><span class="nav-number">1.2.2.</span> <span class="nav-text">概念模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本概念"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实体型之间的联系"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">实体型之间的联系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最常用的数据模型"><span class="nav-number">1.2.3.</span> <span class="nav-text">最常用的数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非关系模型"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">非关系模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#层次模型"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">层次模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网状模型"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">网状模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关系模型"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">关系模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库的系统结构"><span class="nav-number">1.3.</span> <span class="nav-text">数据库的系统结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库系统模式的概念"><span class="nav-number">1.3.1.</span> <span class="nav-text">数据库系统模式的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库系统的三级模式结构"><span class="nav-number">1.3.2.</span> <span class="nav-text">数据库系统的三级模式结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式（Schema）"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">模式（Schema）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外模式（External-Schema）"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">外模式（External Schema）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内模式（Internal-Schema）"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">内模式（Internal Schema）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据的二级映像和功能和数据独立性"><span class="nav-number">1.3.3.</span> <span class="nav-text">数据的二级映像和功能和数据独立性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#外模式-模式-映像"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">外模式/模式 映像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模式-内模式映像"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">模式/内模式映像</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库系统的组成"><span class="nav-number">1.4.</span> <span class="nav-text">数据库系统的组成</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关系数据库"><span class="nav-number">2.</span> <span class="nav-text">关系数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#关系数据结构及形式化定义"><span class="nav-number">2.1.</span> <span class="nav-text">关系数据结构及形式化定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关系数据结构"><span class="nav-number">2.1.1.</span> <span class="nav-text">关系数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系模式"><span class="nav-number">2.1.2.</span> <span class="nav-text">关系模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系数据库-1"><span class="nav-number">2.1.3.</span> <span class="nav-text">关系数据库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系操作"><span class="nav-number">2.2.</span> <span class="nav-text">关系操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本的关系操作"><span class="nav-number">2.2.1.</span> <span class="nav-text">基本的关系操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系数据语言分类"><span class="nav-number">2.2.2.</span> <span class="nav-text">关系数据语言分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系的完整性"><span class="nav-number">2.3.</span> <span class="nav-text">关系的完整性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关系的三类完整性约束"><span class="nav-number">2.3.1.</span> <span class="nav-text">关系的三类完整性约束</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实体完整性"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">实体完整性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参照完整性"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">参照完整性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用户定义的完整性"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">用户定义的完整性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系代数"><span class="nav-number">2.4.</span> <span class="nav-text">关系代数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传统的集合运算"><span class="nav-number">2.4.1.</span> <span class="nav-text">传统的集合运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#专门的关系运算"><span class="nav-number">2.4.2.</span> <span class="nav-text">专门的关系运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系演算"><span class="nav-number">2.5.</span> <span class="nav-text">关系演算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#元组关系演算语言ALPHA"><span class="nav-number">2.5.1.</span> <span class="nav-text">元组关系演算语言ALPHA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#域关系语言QBE"><span class="nav-number">2.5.2.</span> <span class="nav-text">域关系语言QBE</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本章小结"><span class="nav-number">2.6.</span> <span class="nav-text">本章小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关系数据库标准语言SQL"><span class="nav-number">3.</span> <span class="nav-text">关系数据库标准语言SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL特点"><span class="nav-number">3.1.</span> <span class="nav-text">SQL特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL基本概念"><span class="nav-number">3.2.</span> <span class="nav-text">SQL基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#学生-课程数据库"><span class="nav-number">3.3.</span> <span class="nav-text">学生-课程数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据定义"><span class="nav-number">3.4.</span> <span class="nav-text">数据定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模式的定义和删除"><span class="nav-number">3.4.1.</span> <span class="nav-text">模式的定义和删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本表的定义、删除与修改"><span class="nav-number">3.4.2.</span> <span class="nav-text">基本表的定义、删除与修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的建立与删除"><span class="nav-number">3.4.3.</span> <span class="nav-text">索引的建立与删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据查询"><span class="nav-number">3.5.</span> <span class="nav-text">数据查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单表查询"><span class="nav-number">3.5.1.</span> <span class="nav-text">单表查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接查询"><span class="nav-number">3.5.2.</span> <span class="nav-text">连接查询</span></a></li></ol></li></ol></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Qsx</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">42.3k</span></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span><span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/love.js"></script></body></html>