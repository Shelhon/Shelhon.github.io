<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="数据库,学习,"><meta name="description" content="基础篇内容  一、数据库安全性 二、数据库完整性"><meta name="keywords" content="数据库,学习"><meta property="og:type" content="article"><meta property="og:title" content="数据库学习基础篇②"><meta property="og:url" content="https://www.shelhon.cn/posts/a6386957.html"><meta property="og:site_name" content="无问西东"><meta property="og:description" content="基础篇内容  一、数据库安全性 二、数据库完整性"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://www.shelhon.cn/posts/a6386957/1.png"><meta property="og:image" content="https://www.shelhon.cn/posts/a6386957/2.png"><meta property="og:image" content="https://www.shelhon.cn/posts/a6386957/3.png"><meta property="og:image" content="https://www.shelhon.cn/posts/a6386957/4.png"><meta property="og:image" content="https://www.shelhon.cn/posts/a6386957/5.png"><meta property="og:image" content="https://www.shelhon.cn/posts/a6386957/6.png"><meta property="og:image" content="https://www.shelhon.cn/posts/a6386957/7.png"><meta property="og:updated_time" content="2018-08-24T02:51:36.071Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据库学习基础篇②"><meta name="twitter:description" content="基础篇内容  一、数据库安全性 二、数据库完整性"><meta name="twitter:image" content="https://www.shelhon.cn/posts/a6386957/1.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://www.shelhon.cn/posts/a6386957.html"><title>数据库学习基础篇② | 无问西东</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3275656b1c327868bf311aa7c5fdabd2";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="https://github.com/Shelhon/Shelhon.github.io" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64ceaa;color:#fff;position:absolute;top:0;border:0;left:0;transform:scale(-1,1)" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">无问西东</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">糊涂脸水聪明枕</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br> 公益404</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.shelhon.cn/posts/a6386957.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Qsx"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="无问西东"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">数据库学习基础篇②</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-22T20:24:43+08:00">2018-08-22</time></span> <span class="post-updated">&nbsp; | &nbsp; 更新于 <time itemprop="dateUpdated" datetime="2018-08-24T10:51:36+08:00" content="2018-08-24">2018-08-24</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span></span> <span class="post-meta-divider">|</span><span class="page-pv"><i class="fa fa-file-o"></i><span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">10,599</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">40</span></div></div></header><div class="post-body" itemprop="articleBody"><center><strong>基础篇内容</strong></center><p>一、数据库安全性</p><p>二、数据库完整性</p><hr><a id="more"></a><h1 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h1><h2 id="计算机安全性概述"><a href="#计算机安全性概述" class="headerlink" title="计算机安全性概述"></a>计算机安全性概述</h2><p>　数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏。<br>　　安全性问题不是数据库系统所独有的，所有计算机系统都有这个问题。只是在数据库系统中大量数据集中存放，而且为许多最终用户直接共享，从而使安全性问题更为突出。 系统安全保护措施是否有效是数据库系统的主要指标之一。 数据库的安全性和计算机系统的安全性，包括操作系统、网络系统的安全性是紧密联系、相互支持的。</p><h3 id="计算机系统的三类安全性问题"><a href="#计算机系统的三类安全性问题" class="headerlink" title="计算机系统的三类安全性问题"></a>计算机系统的三类安全性问题</h3><p>所谓计算机系统安全性，是指为计算机系统建立和采取的各种安全保护措施，以保护计算机系统中的硬件、软件及数据，防止其因偶然或恶意的原因使系统遭到破坏，数据遭到更改或泄露等。</p><p>计算机系统安全性问题可以分成三大类：</p><ul><li><p>技术安全类： 指计算机系统中采用具有一定安全性的硬件、软件来实现对计算机系统及其所存数据的安全保护，当计算机系统受到无意或恶意的攻击时仍能保证系统正常运行，保证系统内的数据不增加、不丢失、不泄露。</p></li><li><p>管理安全类： 软硬件意外故障、场地的意外事故、管理不善导致的计算机设备和数据介质的物理破坏、丢失等安全问题。</p></li><li><p>政策法律类 ： 政府部门建立的有关计算机犯罪、数据安全保密的法律道德准则和政策法规、法令。</p></li></ul><p>该笔记只包含技术安全</p><h2 id="数据库安全性控制"><a href="#数据库安全性控制" class="headerlink" title="数据库安全性控制"></a>数据库安全性控制</h2><h3 id="用户标识与鉴别"><a href="#用户标识与鉴别" class="headerlink" title="用户标识与鉴别"></a>用户标识与鉴别</h3><p>系统提供的最外层安全保护措施。</p><p>基本方法是：<br>系统提供一定的方式让用户标识自己的名字或身份；<br>系统内部记录着所有合法用户的标识；<br>每次用户要求进入系统时，由系统核对用户提供的身份标识；<br>通过鉴定后才提供机器使用权。<br>用户标识和鉴定可以重复多次。</p><p>常用的方法有：</p><ul><li>用户标识（User Identification）：<br>用一个用户名（User Name）或用户标识号（UID）来标明用户身份。</li><li>口令（Password）：<br>系统核对口令以鉴别用户身份。<br>通过用户名和口令的方法简单易行，但这些信息容易被人窃取。可以采取更复杂的方法 —— 每个用户预先约定好一个计算过程或者函数。<br>系统提供一个随机数<br>用户根据自己预先约定的计算过程或者函数进行计算<br>系统根据用户计算结果是否正确鉴定用户身份</li></ul><hr><h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><p>数据库安全性所关心的主要是DBMS的存取控制机制。</p><p>数据库安全最重要的一点就是确保只授权给有资格的用户访问数据库的权限，同时令所有未授权的人员无法接近数据，这主要通过数据库系统的存取控制机制实现。<br>存取控制机制主要包括两部分：</p><ul><li>定义用户权限</li><li>合法权限检查</li></ul><p>用户权限定义和合法权检查机制一起组成了DBMS的安全子系统</p><p>常用存取控制方法有：</p><ul><li>自主存取控制（Discretionary Access Control，简称DAC）<br>同一用户对于不同的数据对象有不同的存取权限<br>不同的用户对同一对象也有不同的权限<br>用户还可将其拥有的存取权限转授给其他用户</li><li>强制存取控制（Mandatory Access Control，简称 MAC）<br>每一个数据对象被标以一定的密级<br>每一个用户也被授予某一个级别的许可证<br>对于任意一个对象，只有具有合法许可证的用户才可以存取</li></ul><hr><h4 id="自主存取控制（DAC）方法"><a href="#自主存取控制（DAC）方法" class="headerlink" title="自主存取控制（DAC）方法"></a>自主存取控制（DAC）方法</h4><p>主要通过 SQL 的 GRANT 语句和 REVOKE 语句实现自主存取控制。</p><p>用户权限由两个要素组成：</p><ul><li>数据库对象</li><li>操作类型</li></ul><p>定义用户存取权限，是指定义用户可以在哪些数据库对象上进行哪些类型的操作。定义存取权限称为授权。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	        关系数据库系统中的存取权限</span><br><span class="line">———————————————————————————————————————————————————————</span><br><span class="line">对象类型    对象        操作类型</span><br><span class="line"></span><br><span class="line">———————————————————————————————————————————————————————</span><br><span class="line">数据库      模式         CREATE SCHEMA</span><br><span class="line">	   基本表         CREATE  TABLE ,ALTERTABLE</span><br><span class="line">模式        视图         CREATE VIEW</span><br><span class="line">	    索引         CREATE  INDEX</span><br><span class="line">数据      基本表和视图      SELECT ,INSERT,UPDATE,DELETE ,REFERENCES,ALL PRIVILEGES</span><br><span class="line">数据       属性列        SELECT,INSERT,UPDATE,REFERENCES,ALL PRIVILEGES</span><br><span class="line">———————————————————————————————————————————————————————</span><br></pre></td></tr></table></figure><p>自主存取控制的缺点是：</p><ul><li>可能存在数据的“无意泄露”。</li></ul><p>原因在于：</p><ul><li>这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记。</li></ul><p>解决方法：<br>对系统控制下的所有主客体实施强制存取控制策略。</p><hr><h4 id="授权与回收"><a href="#授权与回收" class="headerlink" title="授权与回收"></a>授权与回收</h4><p>授权<br>SQL中用GRANT语句向用户授权。GRANT语句的一般格式为：<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;权限&gt; [,&lt;权限&gt;]... </span><br><span class="line">[ <span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt; ]</span><br><span class="line"><span class="keyword">TO</span> &lt;用户&gt;[,&lt;用户&gt;]...</span><br><span class="line">[ <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span> ];</span><br></pre></td></tr></table></figure><p></p><p>语义：将对指定操作对象的指定操作权限授予指定的用户</p><p>一 、GRANT<br>发出GRANT的可以是：</p><ul><li>DBA</li><li>数据库对象创建者（即属主Owner）</li><li>拥有该权限的用户<br>接受权限的用户可以是：</li><li>一个或多个具体用户</li><li>PUBLIC（全体用户）</li></ul><p>如果指定了WITH GRANT OPTION 子句，则获得某种权限的用户还可以把这种权限再授予其他用户，没有指定WITH GRANT OPTION子句，则获得某种权限的用户只能使用该权限，不能传播该权限。不允许循环授权。</p><p>例 把查询Student表的权限授给U1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">TO</span> u1;</span><br></pre></td></tr></table></figure><p>例 把对Student表和Course表的全部操作权授予用户U2和U3</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">PRIVILEGES</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student ,Course</span><br><span class="line"><span class="keyword">TO</span> U2 U3;</span><br></pre></td></tr></table></figure><p>例 把对表SC 和查询权限授予所有用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">TO</span> <span class="keyword">PUBLIC</span>;</span><br></pre></td></tr></table></figure><p>例 把查询Student表和修改学生学号的权限授给用户U4</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">UPDATE</span>(SNO),<span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">TO</span> U4;</span><br></pre></td></tr></table></figure><p>对属性列的授权时必须明确指出相应属性列名</p><p>例 把对表SC的INSERT权限授予U5 用户，并允许将此权限授予给其他用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">TO</span> U5</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br></pre></td></tr></table></figure><p>执行此sql语句后，u5不仅拥有了对表SC的insert权限，还能传播此权限。<br>例如U5还可以将权限授予U6</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">TO</span> U6</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br></pre></td></tr></table></figure><p>U6还可以授予给U7<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">TO</span> U7;</span><br></pre></td></tr></table></figure><p></p><p>因为U6未给U7传播的权限，所以U7不能再传播此权限。</p> <img src="/posts/a6386957/1.png"><p>二、 回收REVOKE<br>授予的权限可以由DBA或其他授权者用REVOKE语句收回<br>REVOKE语句的一般格式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;权限&gt;[,&lt;权限&gt;]... </span><br><span class="line">[<span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;]</span><br><span class="line"><span class="keyword">FROM</span> &lt;用户&gt;[,&lt;用户&gt;]...;</span><br></pre></td></tr></table></figure><p>例： 把用户U4修改学生学号的权限收回</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">UPDATE</span>(Sno)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">FROM</span> U4;</span><br></pre></td></tr></table></figure><p>例 ：回收所有用户对表SC的查询权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">PUBLIC</span>;</span><br></pre></td></tr></table></figure><p>例： 把用户U5对SC表的INSERT权限收回<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> SC</span><br><span class="line"><span class="keyword">FROM</span> U5 <span class="keyword">CASCADE</span></span><br></pre></td></tr></table></figure><p></p><p>将用户U5的insert权限收回的时候，必须级联（CASCADE）收回，不然系统将拒绝（restrict）执行该命令，因为在上面授权的例子中，U5将对SC表的insert权限授予了U6，而U6又授予给了U7</p><p>注意：这里缺省值为restrict，有的DBMS缺省值为CASCADE，会自动执行级联操作而不必明显的写出CASCADE，如果U6或者U7还从其他用户处获得对SC表的insert权限，那么他们仍然具有此权限。系统只回收直接或间接从U5处获得的权限</p> <img src="/posts/a6386957/2.png"><p>SQL灵活的授权机制：</p><ul><li>DBA：<br>拥有所有对象的所有权限<br>不同的权限授予不同的对象</li><li>用户 ：<br>拥有自己建立的对象的全部的操作权限<br>GRANT 授予其他用户</li><li>被授权的用户<br>继续授权许可：再授予</li><li>所有授予出去的权利在必要时都可以用revoke语句收回。</li></ul><p>三、 创建数据库模式的权限</p><p>对数据库模式的授权，DBA 在创建用户时实现<br>一般CREATE USER格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> &lt;username&gt;</span><br><span class="line">[<span class="keyword">WITH</span>] [ DBA | <span class="keyword">RESOURCE</span> | <span class="keyword">CONNECT</span>]</span><br></pre></td></tr></table></figure><p>对该语句的说明:</p><ul><li>只有系统的超级用户才有权创建一个新的数据库用户</li><li>新创建的数据库用户有三种权限：CONNECT , RESOURCE ,DBA</li><li>CREATE USER命令中没有指定权限的话，默认创建的是CONNECT权限。拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登陆数据库。然后由DBA或者其他用户授予他应有的权限，根据获得的授权权限他可以对数据库对象进行权限范围内的操作。</li><li>拥有RESOURCE权限的用户能创建基本表和视图，称为所创建对象的属主，但是不能创建模式，不能创建新的用户。数据库对象的属主可以使用GRANT语句把对象上的权限授予其他用户。</li><li>拥有DBA的用户是系统中的超级用户，可以创建新的用户，创建模式，创建基本表和视图等，DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户。</li></ul> <img src="/posts/a6386957/3.png"><p>一个DBA用户可以拥有CREATE USER, CREATE SCHEMA和CREATE TABLE 权限，一个RESOURCE用户可以拥有CREATE TABLE权限。</p><blockquote><p>1个数据库下，可以有多个模式。<br>1个模式下，可以有0个或多个表　。<br>首先我来做一个比喻，什么是User，什么是Database，什么是Schema，什么是Table，什么是列，什么是行，？<br>我们可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间，Table可以看作是每个Schema中的床，Table就被放入每个房间中，不能放置在房间之外。然后床上可以放置很多物品，就好比Table上可以放置很多列和行一样。所以Schema包含的是Object，而不是User。<br>User是每个对应数据库的主人，既然有操作数据库的权利，就肯定有操作数据库中每个Schema（房间）的权利。换句话说，如果他是某个仓库的主人，那么这个仓库的使用权和仓库中的所有东西都是他的，他有完全的操作权，。我们还可以给User分配具体的权限，也就是他到某一个房间能做些什么，是只能看（Read-Only），还是可以像主人一样有所有的控制权（R/W），这个就要看这个User所对应的角色Role了.<br>在SQL Server2005中，当我们用Create User创建数据库用户时，我们可以为该用户指定一个已经存在的Schema作为默认Schema，如果我们不指定，则该用户所默认的Schema即为dbo 模式，dbo 房间（Schema）好比一个大的公共房间，在当前登录用户没有默认Schema的前提下，如果你在大仓库中进行一些操作，比如Create Tabe，如果没有指定特定的房间（Schema），那么你的物品就只好放进公共的dbo房间（Schema）了。但是如果当前登录用户有默认的Schema，那么所做的一切操作都是在默认Schema上进行（比如当前登录用户为login1。<br>在SQL Server2005中创建一个数据库的时候，会有一些Schema包括进去，被包括进去的Schema有：dbo，INFORMATION_SCHEMA,guest，sys等等。</p></blockquote><hr><h4 id="数据库角色"><a href="#数据库角色" class="headerlink" title="数据库角色"></a>数据库角色</h4><p>数据库角色是被命令的一组与数据库操作相关的权限，角色是权限的集合。<br>因此可以为一组具有相同权限的用户创建一个角色，使用角色来管理数据库权限可以简化授权 。</p><p>首先用CREATE ROLE语句创建角色，然后用GRANT语句给角色授权</p><p>一、角色的创建<br>格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> &lt;角色名&gt;</span><br></pre></td></tr></table></figure><p>刚刚创建的角色是空的，没有任何内容，可以用GRANT为角色授权</p><p>二、给角色授权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;权限&gt; [,&lt;权限&gt;].....</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt;对象名 </span><br><span class="line"><span class="keyword">TO</span> &lt;角色&gt; [,&lt;角色&gt;]....</span><br></pre></td></tr></table></figure><p>DBA和用户可以利用GRANT语句将权限授予给一个或几个角色</p><p>三、将一个角色授予其他角色或用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;角色<span class="number">1</span> &gt; [,&lt;角色<span class="number">2</span>&gt;]....</span><br><span class="line"><span class="keyword">ON</span> &lt;角色<span class="number">3</span>&gt; [&lt;用户<span class="number">1</span>&gt;]....</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">ADMIN</span> <span class="keyword">OPTION</span>]</span><br></pre></td></tr></table></figure><p>该语句把橘色授予某个用户或另一个角色，这样一个角色（例如角色3）所拥有的权限就是授予它的全部角色（角色1和角色2）所包含的权限的总和。</p><p>授予者或者是角色的创建者，或者拥有在这个角色上的ADMIN OPTION。</p><p>如果指定了WITH ADMIN OPTION 子句，则获得某种权限的角色或用户还可以将权限再授予其他角色。</p><p>一个角色包含的权限包括直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限。</p><p>四、角色权限的收回</p><p>授予的权限可以由DBA或其他授权者用REVOKE语句收回<br>REVOKE语句的一般格式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;权限&gt;[,&lt;权限&gt;]... </span><br><span class="line">[<span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;]</span><br><span class="line"><span class="keyword">FROM</span> &lt;用户&gt;[,&lt;用户&gt;]...;</span><br></pre></td></tr></table></figure><p>用户可以回收角色的权限，从而修改角色拥有的权限</p><p>REVOKE动作的执行者或者是角色的创建者，或者拥有这个角色上的ADMIN OPTION</p><p>例 通过角色来实现将一组权限授予一个用户</p><p>步骤：</p><ol><li><p>首先创建一个角色R1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> R1;</span><br></pre></td></tr></table></figure></li><li><p>然后使用GRANT语句，使角色R1拥有Student表的SELECT ,UPDATE ,INSERT权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> ,<span class="keyword">UPDATE</span>,<span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Stdent</span><br><span class="line"><span class="keyword">TO</span> R1;</span><br></pre></td></tr></table></figure></li><li><p>将这个角色授予王平，张明，赵玲，使他们具有角色R1包含的全部权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> R1 </span><br><span class="line"><span class="keyword">TO</span> 王平，张明，赵玲;</span><br></pre></td></tr></table></figure></li><li><p>当然也可以一次性的通过R1来回收王平的三个权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> R1</span><br><span class="line"><span class="keyword">FROM</span> 王平；</span><br></pre></td></tr></table></figure></li></ol><p>例 ： 角色的权限修改</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">TO</span> R1;</span><br></pre></td></tr></table></figure><p>使角色R1在原来的基础上增加了Student表的DELETE权限</p><p>例<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">FROM</span> R1;</span><br></pre></td></tr></table></figure><p></p><p>使R1减少了select权限</p><hr><h4 id="强制存取控制（MAC）方法"><a href="#强制存取控制（MAC）方法" class="headerlink" title="强制存取控制（MAC）方法"></a>强制存取控制（MAC）方法</h4><ul><li>MAC是系统为保证更高程度的安全性，按照TDI/TCSEC标准中安全策略的要求，所采取的强制存取检查手段。</li><li>MAC不是用户能直接感知或进行控制的。</li><li>MAC适用于对数据有严格而固定密级分类的部门，例如军事部门或政府部门。</li></ul><p>在MAC中，DBMS所管理的全部实体被分为两大类：</p><ol><li>主体 —— 系统中的活动实体，包括：<ul><li>DBMS所管理的实际用户</li><li>代表用户的各进程</li></ul></li><li>客体 —— 系统中的被动实体，是受主体操纵的，包括：<ul><li>文件</li><li>基表</li><li>索引</li><li>视图 等</li></ul></li></ol><p>对于主体和客体，DBMS为它们的每个实例（值）指派一个敏感度标记（Label）。敏感度标记被分为若干级别，例如：</p><ul><li>绝密（Top Secret）</li><li>机密（Secret）</li><li>可信（Confidential）</li><li>公开（Public） 等<br>主体的敏感度标记称为许可证级别（Clearance Level）；<br>客体的敏感度标记称为密级（Classification Level）。<br>MAC机制就是通过对比主体的Label和客体的Label，最终确定主体是否能够存取客体。</li></ul><p>强制存取控制规则：<br>当某一用户（或某一主体）以标记Label注册入系统时，系统要求他对任何客体的存取必须遵循下面两条规则：</p><ol><li>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体。</li><li>仅当主体的许可证级别等于客体的密级时，该主体才能写相应的客体。</li></ol><p>某些系统将第（2）条修正为：<br>仅当主体的许可证级别小于或等于客体的密级时，主体才能写客体。<br>也就是说，用户可为写入的数据对象赋予高于自己的许可证级别的密级<br>这样，一旦数据被写入，该用户自己也不能再读该数据对象了。<br>这两种规则的共同点是：禁止了拥有高许可证级别的主体更新低密级的数据对象，从而防止了敏感数据的泄露。</p><p>强制存取控制（MAC）是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记的用户才可以操纵数据，从而提供了更高级别的安全性。</p><h4 id="DAC与MAC共同构成DBMS的安全机制"><a href="#DAC与MAC共同构成DBMS的安全机制" class="headerlink" title="DAC与MAC共同构成DBMS的安全机制"></a>DAC与MAC共同构成DBMS的安全机制</h4><p>实现MAC时要首先实现DAC<br>原因是：较高安全性级别提供的安全保护要包含较低级别的所有保护。</p><p>DAC + MAC安全检查：<br>先进行DAC检查<br>通过DAC检查的数据对象再由系统进行MAC检查<br>只有通过MAC检查的数据对象方可存取。</p> <img src="/posts/a6386957/4.png" title="安全检查示意图"><hr><h2 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h2><p>可以通过视图机制把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护。<br>视图机制的主要功能在于提供数据独立性，其安全保护功能太不精细，往往远不能达到应用系统的要求。<br>可以将视图机制与授权机制配合使用：</p><ul><li>首先用视图机制屏蔽掉一部分保密数据</li><li>视图上面再进一步定义存取权限</li><li>间接实现了支持存取谓词的用户权限定义</li></ul><p>例 建立计算机系学生的视图，把对该视图的SELECT权限授于王平，把该视图上的所有操作权限授于张明。</p><p>①首先建立计算机系学生的视图CS_Student</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> CS_Student</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span>  *</span><br><span class="line"><span class="keyword">FROM</span>   Student</span><br><span class="line"><span class="keyword">WHERE</span>  Sdept = <span class="string">'CS'</span>；</span><br></pre></td></tr></table></figure><p>② 然后在视图上进一步定义存取权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span>  <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span>  CS_Student </span><br><span class="line"><span class="keyword">TO</span> 王平 ；</span><br><span class="line"><span class="keyword">GRANT</span> ALL PRIVILIGES</span><br><span class="line"><span class="keyword">ON</span>  CS_Student </span><br><span class="line"><span class="keyword">TO</span>  张明；</span><br></pre></td></tr></table></figure><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>什么是审计？</p><ul><li>启用一个专用的审计日志（Audit Log），将用户对数据库的所有操作记录在上面；</li><li>DBA可以利用审计日志中的追踪信息，找出非法存取数据的人、时间和内容。</li></ul><p>C2以上安全级别的DBMS必须具有审计功能</p><p>审计是很费时间和空间的，所以DBMS往往将其作为可选特征，允许DBA根据应用对安全性的要求，灵活地打开或关闭审计功能。<br>审计功能一般主要用于安全性要求较高的部门。</p><p>审计一般可以分为：<br>用户级审计：</p><ul><li>任何用户都可设置的审计，主要针对用户自己创建的数据库表或视图进行审计，记录所有用户对这些表或视图的一切成功和（或）不成功的访问要求以及各种类型的SQL操作。</li></ul><p>系统级审计 ：</p><ul><li>只能由DBA设置，用以监测成功或失败的登录要求、监测GRANT和REVOKE操作以及其他数据库级权限下的操作。</li></ul><p>AUDIT语句：设置审计功能<br>NOAUDIT语句：取消审计功能</p><p>例 对修改SC表结构或修改SC表数据的操作进行审计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AUDIT <span class="keyword">ALTER</span>，<span class="keyword">UPDATE</span>  </span><br><span class="line"><span class="keyword">ON</span>  SC；</span><br></pre></td></tr></table></figure><p>例 取消对SC表的审计</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NOAUDIT <span class="keyword">ALTER</span>，<span class="keyword">UPDATE</span>  </span><br><span class="line"><span class="keyword">ON</span>  SC；</span><br></pre></td></tr></table></figure><h2 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h2><p>数据加密<br>防止数据库中数据在存储和传输中失密的有效手段。</p><p>加密的基本思想<br>根据一定的算法将原始数据（术语为明文，Plain text）<br>变换为不可直接识别的格式（术语为密文，Cipher text）。<br>不知道解密算法的人无法获知数据的内容。</p><p>加密方法主要有：</p><ol><li>替换方法<br> 使用密钥（Encryption Key）将明文中的每一个字符转换为密文中的一个字符。</li><li>置换方法<br> 将明文的字符按不同的顺序重新排列</li><li>混合方法<br> 典型实例：美国1977年制定的官方加密标准——数据加密标准（Data Encryption Standard，简称DES）</li></ol><p>DBMS中的数据加密：</p><ul><li>有些数据库产品提供了数据加密例行程序</li><li>有些数据库产品本身未提供加密程序，但提供了接口</li></ul><p>数据加密功能通常也作为可选特征，允许用户自由选择</p><ul><li>数据加密与解密是比较费时的操作</li><li>数据加密与解密程序会占用大量系统资源</li><li>应该只对高度机密的数据加密</li></ul><h2 id="统计数据库安全性"><a href="#统计数据库安全性" class="headerlink" title="统计数据库安全性"></a>统计数据库安全性</h2><p>统计数据库</p><ul><li>允许用户查询聚集类型的信息（如合计，平均值等）</li><li>不允许查询单个记录信息</li></ul><p>统计数据库中特殊的安全性问题</p><ul><li>隐蔽的信息通道</li><li>能从合法的查询中推导出不合法的信息</li></ul><p>可以制定规则来防范</p><ul><li>规则1：任何查询至少要查询N（N足够大）个以上的记录</li><li>规则2：任意两个查询的相交数据项不能超M个</li><li>规则3：任一用户的查询次数不能超过1+（N-2）/M</li></ul><p>数据库安全机制的设计目标：<br>试图破坏安全的人所花费的代价 &gt;&gt; 得到的利益</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>数据库的安全性<br>是指保护数据库，防止因用户非法使用数据库造成数据泄露、更改或破坏。</p><p>实现数据库系统安全性的技术和方法</p><ol><li>用户标识与鉴别<br>2.存取控制</li></ol><ul><li>自主存取控制方法</li><li>强制存取控制方法</li></ul><ol start="3"><li>视图机制</li><li>审计</li><li>数据加密</li></ol><hr><h1 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h1><blockquote><p>数据库的完整性是指：数据的正确性和相容性。</p></blockquote><p>例如：学生的学号必须存在而且唯一；性别只能是“男”或“女”；学生选修的课程必须是学校开设的课程，等等。</p><p>数据的完整性和安全性是两个不同概念。</p><ul><li>数据的完整性，是指防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据。<br>所防范的对象是：不合语义的、不正确的数据。</li><li>数据的安全性，是指保护数据库防止恶意的破坏和非法的存取<br>所防范的对象是：非法用户和非法操作。</li></ul><p>为维护数据库的完整性，DBMS必须：</p><ul><li>提供定义完整性约束条件的机制<br>DBMS应提供定义数据库完整性约束条件（数据必须满足的语义约束条件）的机制，并把它们作为模式的一部分存入数据库中。</li><li>提供完整性检查的方法<br>检查用户发出的操作请求是否违背了完整性约束条件</li><li>采取违约处理<br>如果发现用户的操作请求使数据违背了完整性约束条件，则采取一定的动作来保证数据的完整性。</li></ul><h2 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h2><h3 id="实体完整性定义"><a href="#实体完整性定义" class="headerlink" title="实体完整性定义"></a>实体完整性定义</h3><p>关系模型的实体完整性<br>在CREATE TABLE中用PRIMARY KEY定义。</p><p>对单属性构成的码有两种说明方法：<br>定义为列级约束条件<br>定义为表级约束条件</p><p>对多个属性构成的码只有一种说明方法：<br>定义为表级约束条件</p><p>例 将Student表中的Sno属性定义为码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">	(Sno <span class="built_in">CHAR</span>(<span class="number">9</span>) PRIMARY <span class="keyword">KEY</span>,  <span class="comment">/* 在列级定义主码*/</span></span><br><span class="line">	Sname <span class="built_in">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	Ssex <span class="built_in">CHAR</span>(<span class="number">2</span>) ,</span><br><span class="line">	Sage <span class="built_in">SMALLINT</span>,</span><br><span class="line">	Sdept <span class="built_in">CHAR</span>(<span class="number">20</span>) </span><br><span class="line">	);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">	(Sno <span class="built_in">CHAR</span>(<span class="number">9</span>),</span><br><span class="line">	Sname <span class="built_in">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,     </span><br><span class="line">	Ssex <span class="built_in">CHAR</span>(<span class="number">2</span>) ,</span><br><span class="line">	Sage <span class="built_in">SMALLINT</span>,</span><br><span class="line">	Sdept <span class="built_in">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span> (Sno)   <span class="comment">/*在表级定义主码*/</span></span><br><span class="line">	);</span><br></pre></td></tr></table></figure><p>例 将SC表中的Sno，Cno属性组定义为码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(Sno <span class="built_in">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>， </span><br><span class="line">Cno <span class="built_in">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>，  </span><br><span class="line">Grade <span class="built_in">SMALLINT</span>，</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (Sno，Cno)    <span class="comment">/* 对于多个属性构成的主码，只能在表级定义*/</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p> ↑一个候选码中有多个属性，候选码可以有多种组合，而主码只是选择了其中一种组合而已，所以主码也可以有多个属性构成，而不是有多个主码</p></blockquote><hr><h3 id="实体完整性检查和违约处理"><a href="#实体完整性检查和违约处理" class="headerlink" title="实体完整性检查和违约处理"></a>实体完整性检查和违约处理</h3><p>用PRIMARY KEY定义了关系的主码之后，每当对基本表插入记录或对码列进行更新操作时，RDBMS按照实体完整性规则自动进行检查。包括：</p><ul><li>检查主码值是否唯一，如果不唯一则拒绝插入或修改</li><li>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改</li></ul><p>从而保证了实体完整性。</p><p>检查记录中的主码值是否唯一的一种方法是进行全表扫描，依次判断中表中的每一条记录的主码值和将插入记录上的主码值（或者修改的新主码值）是否相同，如下图所示</p> <img src="/posts/a6386957/5.png"><p>全表扫描是十分耗时的。为了避免对基本表进行全表扫描，RDBMS核心一般都在主码上自动建立一个索引，如下图的B+树索引。通过索引查找基本表中是否已经存在新的主码值，将大大提高效率。</p> <img src="/posts/a6386957/6.png"><h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><h3 id="参照完整性定义"><a href="#参照完整性定义" class="headerlink" title="参照完整性定义"></a>参照完整性定义</h3><p>关系模型的参照完整性：<br>在CREATE TABLE中用FOREIGN KEY定义外码<br>用REFERENCES指明这些外码参照哪些表的主码。</p><p>例如，关系SC中一个元组表示一个学生选修的某门课程的成绩，（Sno，Cno）是主码。Sno，Cno分别参照引用Student表的主码和Course表的主码。</p><p>例 定义SC中的参照完整性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">	(Sno <span class="built_in">CHAR</span>(<span class="number">9</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>， </span><br><span class="line">	Cno <span class="built_in">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>，  </span><br><span class="line">	Grade <span class="built_in">SMALLINT</span>，</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span> (Sno，Cno)，     <span class="comment">/* 在表级定义实体完整性 */</span> </span><br><span class="line">	FOREIGN <span class="keyword">KEY</span> (Sno) <span class="keyword">REFERENCES</span> Student(Sno)，  <span class="comment">/* 在表级定义参照完整性 */</span> </span><br><span class="line">	FOREIGN <span class="keyword">KEY</span> (Cno) <span class="keyword">REFERENCES</span> Course(Cno)     <span class="comment">/* 在表级定义参照完整性 */</span> </span><br><span class="line">	);</span><br></pre></td></tr></table></figure><h3 id="参照完整性检查和违约处理"><a href="#参照完整性检查和违约处理" class="headerlink" title="参照完整性检查和违约处理"></a>参照完整性检查和违约处理</h3><p>一个参照完整性将两个表中的相应元组联系起来了。因此，对被<br>参照表和参照表进行增删操作时有可能破坏参照完整性，必须进行检查。</p><p>对表SC和Student有四种可能破坏参照完整性的情况：</p><ol><li><p>SC表中增加一个元组，该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。</p></li><li><p>修改SC表中的一个元组，修改后该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。</p></li><li><p>从Student表中删除一个元组，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。</p></li><li><p>修改Student表中的一个元组的Sno属性，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。</p></li></ol> <img src="/posts/a6386957/7.png"><p>当上述的不一致发生时，系统就可以采用以下的策略加以处理。</p><ol><li><p>拒绝（NO ACTION）执行</p></li><li><p>级连（CASCADE）操作</p></li><li><p>设置为空值（SET-NULL）</p></li></ol><p>当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。</p><p>例如，有下面2个关系</p><p>学生（学号，姓名，性别，专业号，年龄）<br>专业（专业号，专业名）</p><p>学生关系的“专业号”是外码，因为专业号是专业关系的主码。</p><p>假设专业表中某个元组被删除，专业号为12，按照设置为了空值策略，就要把学生表中专业号=12的所有元组的专业号设置为空值。这对应了这样的语义：某个专业删除了，该专业的所有学生专业未定，等待重新分配专业。因此对于参照完整性时，除了应该定义外码，还应定义外码列是否允许空值。</p><p>例 显式说明参照完整性的违约处理事例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(Sno <span class="built_in">CHAR</span> (<span class="number">9</span>) <span class="keyword">NOT</span>  <span class="literal">NULL</span>,</span><br><span class="line">Cno <span class="built_in">CHAR</span>(<span class="number">4</span>) <span class="keyword">NOT</span>  <span class="literal">NULL</span>,</span><br><span class="line">Grade <span class="built_in">SMALLINT</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(Sno,Cno),     <span class="comment">/*在表级定义实体完整性*/</span></span><br><span class="line">FOREIGN <span class="keyword">KEY</span>(Sno)<span class="keyword">REFERENCES</span> Student(Sno)    <span class="comment">/*在表级定义参照完整性*/</span></span><br><span class="line">       <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>       <span class="comment">/*当删除Student表中的元组时，级连删除SC表中相应的元组*/</span></span><br><span class="line">       <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span>,      <span class="comment">/*当更新Student表中的Sno时，级连更新SC表中相应的元组*/</span></span><br><span class="line">FOREIGN <span class="keyword">KEY</span>(Cno)<span class="keyword">REFERENCES</span> Course(Cno)     <span class="comment">/*在表级定义参照完整性*/</span></span><br><span class="line">       <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> <span class="keyword">ACTION</span>     <span class="comment">/*当删除course表中的元组造成了与SC表不一致时拒绝删除*/</span></span><br><span class="line">       <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span>      <span class="comment">/*当更新course表中的cno时，级连更新SC表中相应的元组*/</span></span><br><span class="line">      );</span><br></pre></td></tr></table></figure><p>可以对DELETE和UPDATE采用不同的策略，如上面删除被参照表Course表中的元组，造成了不一致时，拒绝删除被参照表的元组，而对更新操作则采取级联更新的策略。</p><p>从上面的讨论看到RSBMS在实现参照完整性时，除了要提供定义主码、外码的机制外，还需要提供不同的策略供用户选择。选择哪种策略，要根据应用环境的要求确定。</p><h2 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h2><p>①用户自定义约束条件<br>是针对某一具体应用的数据必须满足的语义要求。</p><ul><li>RDBMS提供了定义和检验这类完整性的机制，而不必由应用程序承担。</li></ul><p>② 用户自定义的约束条件检查和违约处理</p><p>一、 属性上的约束条件的定义</p><p>在CREATE TABLE中定义属性时，可以定义属性或元组上的约束条件，包括：</p><ul><li>列值非空（NOT NULL）</li><li>列值唯一（UNIQUE）</li><li>检查列值是否满足一个布尔表达式（CHECK）</li></ul><ol><li>不允许空值<br>例 在定义SC表时，说明Sno和Cno属性不允许取空值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">( Sno  <span class="built_in">CHAR</span>(<span class="number">9</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>,	   <span class="comment">/*  Sno属性不允许取空值 */</span></span><br><span class="line">Cno  <span class="built_in">CHAR</span>(<span class="number">4</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>,    <span class="comment">/*  Cno属性不允许取空值 */</span></span><br><span class="line">Grade  <span class="built_in">SMALLINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  <span class="comment">/*Grade属性不允许取空值*/</span></span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (Sno， Cno)，     <span class="comment">/*  如果在表级定义实体完整性，隐含了Sno，Cno不允许取空值，则在列级不允许取空值的定义就不必写了  * /</span></span><br><span class="line"><span class="comment">	..</span></span><br><span class="line"><span class="comment">	..</span></span><br><span class="line"><span class="comment">	..</span></span><br><span class="line"><span class="comment">	）；</span></span><br></pre></td></tr></table></figure><ol start="2"><li>列值唯一<br>例 建立部门表DEPT，要求部门名称Dname列取值唯一，部门编号Deptno列为主码。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> DEPT</span><br><span class="line">	(Deptno <span class="built_in">NUMERIC</span>(<span class="number">2</span>),</span><br><span class="line">	Dname <span class="built_in">CHAR</span>(<span class="number">9</span>) <span class="keyword">UNIQUE</span>,  <span class="comment">/*要求Dname列值唯一*/</span></span><br><span class="line">	Location <span class="built_in">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span> (Deptno)</span><br><span class="line">	 );</span><br></pre></td></tr></table></figure><ol start="3"><li>用check短语指定列值应该满足的条件<br>例 Student表的Ssex只允许取“男”或“女”</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">(Sno <span class="built_in">CHAR</span>(<span class="number">9</span>) PRIMARY <span class="keyword">KEY</span>,       <span class="comment">/*在列级定义主码*/</span></span><br><span class="line">Sname <span class="built_in">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,         <span class="comment">/*Sname属性不允许取空值*/</span></span><br><span class="line">Ssex <span class="built_in">CHAR</span>(<span class="number">2</span>) <span class="keyword">CHECK</span>(Ssex <span class="keyword">in</span> (‘男’或‘女’)),   <span class="comment">/*性别属性Ssex只允许取男或女*/</span></span><br><span class="line">Sage <span class="built_in">SMALLINT</span>,</span><br><span class="line">Sdept <span class="built_in">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>SC表的Grade的值应该在0到100之间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(Sno <span class="built_in">CHAR</span>(<span class="number">9</span>)<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">Cno <span class="built_in">CHAR</span>(<span class="number">4</span>)<span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">Grade <span class="built_in">SMALLINT</span> <span class="keyword">CHECK</span> (Grade&gt;=<span class="number">0</span> <span class="keyword">AND</span> Grade &lt;=<span class="number">100</span>),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (Sno,Cno),</span><br><span class="line">FOREIGN (Sno) PEFERENCES Student(Sno),</span><br><span class="line">FOREIGN (Cno)<span class="keyword">REFERENCES</span> Course(Cno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>二、 属性上的约束条件检查和违约处理</p><p>在往表中插入元组或修改属性的值时，RDBMS会检查属性或元组上的约束条件是否被满足，如果不满足则操作被拒绝执行。</p><p>三、 元组上的约束条件的定义</p><p>与属性上约束条件的定义类似，在CREATE TABLE语句中可以用CHECK短语定义元组上的约束条件，即元组级的限制。同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件。</p><p>例 当学生的性别是男孩时，其名字不能以Ms.打头。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">(Sno <span class="built_in">CHAR</span>(<span class="number">9</span>),</span><br><span class="line">Sname <span class="built_in">CHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">Ssex <span class="built_in">CHAR</span>(<span class="number">2</span>),</span><br><span class="line">Sage <span class="built_in">SMALLINT</span>,</span><br><span class="line">Sdept <span class="built_in">CHAR</span>(<span class="number">20</span>),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (Sno),</span><br><span class="line"><span class="keyword">CHECK</span> (Ssex= ‘女’ <span class="keyword">OR</span> Sname <span class="keyword">NOT</span> <span class="keyword">LIKE</span>‘Ms.%’</span><br><span class="line">       );<span class="comment">/*定义了元组中Sname和Ssex两个属性值之间的约束条件*/</span></span><br></pre></td></tr></table></figure><p>四、元组上的约束条件检查和违约处理</p><p>当往表中插入元组或修改属性的值时，RDBMS就检查元组上的约束条件是否被满足，如果不满足则操作被拒绝执行。</p><h2 id="完整性约束命名子句"><a href="#完整性约束命名子句" class="headerlink" title="完整性约束命名子句"></a>完整性约束命名子句</h2><ol><li>完整性的约束命名子句</li></ol><p>CONSTRAINT〈完整性约束条件名〉[PRIMARY KEY短语 | FOREIGN KEY短语 | CHECK短语]</p><p>例 建立学生登记表Student，要求学号在90000-99999之间，姓名不能取空值，年龄小于30，性别只能是“男”或“女”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student</span><br><span class="line">(Sno <span class="built_in">NUMERIC</span>(<span class="number">6</span>)</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> C1 <span class="keyword">CHECK</span> (Sno <span class="keyword">BETWEEN</span> <span class="number">90000</span> <span class="keyword">AND</span> <span class="number">99999</span>),</span><br><span class="line">Sname <span class="built_in">CHAR</span>(<span class="number">20</span>)</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> C2 <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">Sage <span class="built_in">NUMERIC</span>(<span class="number">3</span>)</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> C3 <span class="keyword">CHECK</span> (Sage&lt;<span class="number">30</span>),</span><br><span class="line">Ssex <span class="built_in">CHAR</span> (<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> C4 <span class="keyword">CHECK</span> (Ssex <span class="keyword">IN</span> （‘男’，‘女’）)，</span><br><span class="line"><span class="keyword">CONSTRAINT</span> StudentKey PRIMARY <span class="keyword">KEY</span>(Sno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在Student表上建立了5个约束条件，包括主码约束（命名为StudentKey）以及C1、C2、C3、C4四个列级约束。</p><p>例 建立教师表TEACHER，要求每个教师的应发工资不低于3000元。应发工资实际上就是实发工资列Sal与扣除项Deduct之和。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEACHER</span><br><span class="line">(Eno <span class="built_in">NUMERIC</span>(<span class="number">4</span>) PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">Ename <span class="built_in">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">Job <span class="built_in">CHAR</span>(<span class="number">8</span>),</span><br><span class="line">Sal <span class="built_in">NUMERIC</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">Deduct <span class="built_in">NUMERIC</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">Deptno <span class="built_in">NUMERIC</span>(<span class="number">2</span>),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> EMPFKey FOREIGN <span class="keyword">KEY</span> (Deptno) <span class="keyword">REFERENCES</span> DEPT(Deptno),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> C1 <span class="keyword">CHECK</span> (Sal + Deduct &gt;=<span class="number">3000</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li>修改表中的完整性限制<br>我们可以使用ALTER TABLE 语句修改表中的完整性限制。</li></ol><p>例 去掉上面student表中对性别的限制。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> C4；</span><br></pre></td></tr></table></figure><p>例 修改表Student中的约束条件，要求学号改为在900000-999999之间，年龄由小于30改为小于40。</p><p>可以先删除原来的约束条件，再增加新的约束条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> C1;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> C1 <span class="keyword">CHECK</span> (Sno <span class="keyword">BETWEEN</span> <span class="number">900000</span> <span class="keyword">AND</span> <span class="number">999999</span>),</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">DROP</span>  <span class="keyword">CONSTRAINT</span> C3;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> C3 <span class="keyword">CHECK</span> (Sage &lt; <span class="number">40</span>)</span><br></pre></td></tr></table></figure><h2 id="域中的完整性限制"><a href="#域中的完整性限制" class="headerlink" title="域中的完整性限制"></a>域中的完整性限制</h2><p> SQL支持域的概念，并可以用CREATE DOMAIN语句建立一个域应该满足的完整性约束条件</p><ol><li>建立一个性别域，并声明性别域的取值范围</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DOMAIN</span> GenderDomain <span class="built_in">CHAR</span>(<span class="number">2</span>)</span><br><span class="line"> <span class="keyword">CHECK</span>(<span class="keyword">VALUE</span> <span class="keyword">IN</span>(‘男’,’女’));</span><br></pre></td></tr></table></figure><ol start="2"><li>对Ssex的说明可以改写为</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ssex GenderDomain</span><br></pre></td></tr></table></figure><ol start="3"><li>建立一个性别域GenderDomain，并对其中的限制命名。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DOMAIN</span> GenderDomain <span class="built_in">CHAR</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">CONSTRAINT</span> GD <span class="keyword">CHECK</span>(<span class="keyword">VALUE</span> <span class="keyword">IN</span>(‘男’,’女’));</span><br></pre></td></tr></table></figure><ol start="4"><li>删除域GenderDomain的限制条件GD。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DOMAIN</span> Genderdomain</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> GD;</span><br></pre></td></tr></table></figure><ol start="5"><li>在域GenderDomain上增加限制条件GDD</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DOMAIN</span> Genderdomain</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> GDD <span class="keyword">CHECK</span> (<span class="keyword">VALUE</span> <span class="keyword">IN</span>(‘<span class="number">1</span>’,’<span class="number">0</span>’));</span><br></pre></td></tr></table></figure><p>这样，通过上面两个例子，就把性别的取值范围由(‘男’,’女’) 改为(‘1’,’0’)。</p><hr><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>用户定义在关系表上的一类由事件驱动的特殊过程，一旦定义，任何用户对表的增加、修改和删除工作均由服务器自动激活相应的触发器，在DBMS核心层进行集中的完整性控制。<br>触发器类似于约束，但是比约束更加灵活，可以进行更为复杂的检查和操作，具有更精细和更强大的数据控制能力。</p><h3 id="定义触发器"><a href="#定义触发器" class="headerlink" title="定义触发器"></a>定义触发器</h3><p>一般格式 ：<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> &lt;触发器名&gt;</span><br><span class="line">	&#123; <span class="keyword">BEFORE</span> | <span class="keyword">AFTER</span> &#125;  &lt;触发事件&gt; <span class="keyword">ON</span> &lt;表名&gt;</span><br><span class="line">	<span class="keyword">FOR</span> <span class="keyword">EACH</span> &#123; <span class="keyword">ROW</span> | <span class="keyword">STATEMENT</span> &#125;</span><br><span class="line">	[ <span class="keyword">WHEN</span> &lt;触发事件&gt;]</span><br><span class="line">	&lt;触发动作体&gt;</span><br></pre></td></tr></table></figure><p></p><p>各部分语法进行详细说明：</p><ol><li><p>表的拥有者即创建表的用户才可以在表上创建触发器，并且一个表上只能创建一定数量的触发器。</p></li><li><p>触发器名：触发器名可以包含模式名，也可以不包含模式名。同一模式下，触发器名必须是唯一的；并且触发器名和&lt;表名&gt;必须在同一模式下。</p></li><li><p>表名：当这个表的数据发生变化时，将激活定义在该表上相应&lt;触发事件&gt;的触发器，因此，该表也称为触发器的目标表。</p></li><li><p>触发事件：触发事件可以是INSERT、DELETE或UPDATE，也可以是这几个事件的组合，如INSERT OR DELETE等。UPDATE后面还可以有OF 〈触发列…….〉，即进一步修改那些列时触发器激活。</p></li><li><p>触发器类型：触发器按照所触发动作的间隔尺寸可以分为行级触发器（FOR EACH ROW）和语句级触发器（FOR EACH STATEMENT）。</p><p> 例如，假设在前面的的TEACHER表上创建了一个AFTER UPDATE触发器。如果表TEACHER有1000行，<br>执行如下语句：UPDATE TEACHER SET Deptone =5;<br>如果该触发器为语句级触发器，那么执行完语句后，触发动作只发生一次。<br>如果是行动级触发器，触发动作将执行1000次。</p></li><li><p>触发条件：触发器被激活时，只有当触发条件为真时触发动作体才执行；否则触发动作体不执行。如果省略WHEN触发条件，则触发动作体在触发器激活后立即执行。</p><p> 触发动作体：触发动作体既可以是一个匿名PL/SQL过程块，也可以是对已创建存储过程的调用。如果是行级触发器，在两种情况下，用户都可以在过程体中使用NEW和OLD引用UPDATE/INSERT事件之后的新值和UPDATE/INSERT事件之前的旧值。如果是语句级触发器，则不能在触发动作体中使用NEW和OLD进行引用。如果触发动作体执行失败，激活触发器的时间就会中止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化。</p></li></ol><p>例 定义一个BEFORE行级触发器，为教师表TEACHER定义完整性规则“接受的工资不得低于4000元，如果低于4000元，自动改为4000元”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Insert_Or_Update_Sal    <span class="comment">/*在教师表Teacher上定义触发器*/</span></span><br><span class="line">    <span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> Teacher <span class="comment">/*触发事件是插入或更新操作*/</span></span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span>               <span class="comment">/*这是行级触发器*/</span></span><br><span class="line">    <span class="keyword">AS</span> <span class="keyword">BEGIN</span>                 <span class="comment">/*定义触发动作体，这是一个PL/SQL过程块*/</span></span><br><span class="line">      <span class="keyword">If</span> (new.job=’教授’) <span class="keyword">AND</span> (new.Sal&lt;<span class="number">4000</span>) <span class="keyword">THEN</span></span><br><span class="line">             New.Sal=<span class="number">4000</span>; <span class="comment">/*因为是行级触发器，可在过程体中使用插入或更新操作后的新值*/</span></span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    <span class="keyword">END</span>;                        <span class="comment">/*触发动作体结束*/</span></span><br></pre></td></tr></table></figure><p>例 定义AFTER行级触发器，当教师表Teacher的工资发生变化以后就自动在工资变化表Sal_log中增加一条相应的记录。<br>首先建立工资变化表Sal_log.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Sal_log</span><br><span class="line">       (Eno <span class="built_in">NUMERIC</span>(<span class="number">4</span>) referencr teacher(eno),</span><br><span class="line">       Sal <span class="built_in">NUMERIC</span>(<span class="number">7</span>,<span class="number">2</span>),</span><br><span class="line">       Username <span class="built_in">char</span>(<span class="number">10</span>),</span><br><span class="line">       <span class="built_in">Date</span> <span class="keyword">TIMESTAMP</span>)</span><br><span class="line">);</span><br><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Insert_Sal          <span class="comment">/*建立了一个触发器*/</span></span><br><span class="line">   <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> Teacher         <span class="comment">/*触发事件是INSERT*/</span></span><br><span class="line">   <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line">      <span class="keyword">AS</span> <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Sal_log <span class="keyword">VALUES</span>(</span><br><span class="line">              New.Eno,new.Sal,<span class="keyword">CURRENT_USER</span>,<span class="keyword">CURRENT_TIMESTAMP</span>);</span><br><span class="line">      <span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> Update_Sal          <span class="comment">/*建立了一个触发器*/</span></span><br><span class="line">   <span class="keyword">AFTER</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> Teacher         <span class="comment">/*触发事件是UPDATE*/</span></span><br><span class="line">   <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line">   <span class="keyword">AS</span> <span class="keyword">BEGIN</span></span><br><span class="line">       <span class="keyword">IF</span>(new.Sal&lt;&gt;old.Sal) <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Sal_log</span><br><span class="line"><span class="keyword">VALUES</span>(New.Eno,new.Sal,<span class="keyword">CURRENT_USER</span>,<span class="keyword">CURRENT_TIMESTAMP</span>)；</span><br><span class="line">       <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>例 建一个avg_sc(Sno, avg_grade)表；<br>为SC表建一个触发器，当为sc表插入、删除、修改记录时，自动修改avg_sc表中的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> set_avg_trg </span><br><span class="line"><span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> SC <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">UPDATE</span> avg_sc  </span><br><span class="line">  	 <span class="keyword">SET</span> avg_grade = ( <span class="keyword">SELECT</span> <span class="keyword">AVG</span>(Grade) <span class="keyword">FROM</span> SC </span><br><span class="line">			<span class="keyword">WHERE</span> SC.Sno = avg_sc.Sno ) </span><br><span class="line">	<span class="keyword">WHERE</span> Sno <span class="keyword">in</span> (<span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> inserted );</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> avg_sc (Sno, avg_grade)</span><br><span class="line">	<span class="keyword">SELECT</span> Sno, <span class="keyword">AVG</span>(Grade) <span class="keyword">FROM</span> SC</span><br><span class="line">	<span class="keyword">WHERE</span>  Sno <span class="keyword">in</span> (<span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> inserted) <span class="keyword">AND</span> </span><br><span class="line">		   Sno <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> avg_sc)</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> sc_delete_trg</span><br><span class="line"><span class="keyword">AFTER</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> SC <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">UPDATE</span> avg_sc  </span><br><span class="line">     <span class="keyword">SET</span> avg_grade =(<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(Grade)  </span><br><span class="line">			<span class="keyword">FROM</span> SC </span><br><span class="line">			<span class="keyword">WHERE</span> SC.Sno=avg_sc.sno ) </span><br><span class="line">	<span class="keyword">WHERE</span> sno <span class="keyword">in</span> ( <span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> deleted );</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> avg_sc </span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">in</span> (<span class="keyword">SELECT</span> Sno  <span class="keyword">FROM</span> deleted</span><br><span class="line">             <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">             ( <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SC</span><br><span class="line">            <span class="keyword">WHERE</span> SC.Sno=deleted.Sno)) </span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h3 id="激活触发器"><a href="#激活触发器" class="headerlink" title="激活触发器"></a>激活触发器</h3><p>触发器的执行，是由触发事件激活的，并由数据库服务器自动执行的。一个数据表上可能定义了多个触发器，比如多个BEFORE触发器，多个AFTER触发器等。同一个表上的多个触发器激活时遵循如下的执行顺序：</p><p>（1） 执行该表上的BEFORE触发器；</p><p>（2） 激活触发器的SQL语句；</p><p>（3） 执行该表上的AFTER触发器。</p><p>对于同一个表上的多个BEFORE（或AFTER）触发器而言，遵循“谁先创建谁先执行”的原则。有些RDBMS是按照触发器的字母排序顺序执行触发器的。</p><p>例 执行修改某个教师工资的SQL语句，激活上述定义的触发器。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Teacher <span class="keyword">SET</span> Sal = <span class="number">800</span> <span class="keyword">WHERE</span> Ename = ‘陈平’；</span><br></pre></td></tr></table></figure><p>执行顺序是：</p><p>（1） 执行触发器Insert_Or_Update_Sal;</p><p>（2） 执行SQL语句“UPDATE Teacher SET Sal = 800 WHERE Ename = ‘陈平’；”</p><p>（3） 执行触发器Insert_Sal;</p><p>（4） 执行触发器Update_Sal。</p><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><p>SQL语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> &lt;触发器名&gt; <span class="keyword">ON</span> &lt;表名&gt;；</span><br></pre></td></tr></table></figure><p>例 删除教师表Teacher上的触发器Insert_Sal.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> Insert_Sal <span class="keyword">ON</span> Teacher;</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>数据库的完整性是为了保证数据库中存储的数据是正确的。</p><p>RDBMS完整性实现的机制</p><ul><li>完整性约束定义机制</li><li>完整性检查机制</li><li>违背完整性约束条件时RDBMS应采取的动作</li></ul><p>实体完整性<br>参照完整性<br>用户定义的完整性<br>触发器</p><p> <strong><font size="8">这样基础篇的内容就到这里了</font></strong></p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>Just for fun!</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Qsx 微信支付"><p>微信支付</p></div></div></div></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-paw"></i> 文章已经到尾<i class="fa fa-paw"></i> -------------</div></div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/数据库/" rel="tag"># 数据库</a> <a href="/tags/学习/" rel="tag"># 学习</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/486c9009.html" rel="next" title="数据库学习基础篇①"><i class="fa fa-chevron-left"></i> 数据库学习基础篇①</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/0.html" rel="prev" title=""><i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Qsx"><p class="site-author-name" itemprop="name">Qsx</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">11</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Shelhon" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:ppp00qqq@163.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="http://weibo.com/qsxmybaby" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i> 微博</a></span><span class="links-of-author-item"><a href="https://zhihu.com/people/shelhon" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i> 知乎</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://www.kofes.cn/" title="cz" target="_blank">cz</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库安全性"><span class="nav-number">1.</span> <span class="nav-text">数据库安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机安全性概述"><span class="nav-number">1.1.</span> <span class="nav-text">计算机安全性概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机系统的三类安全性问题"><span class="nav-number">1.1.1.</span> <span class="nav-text">计算机系统的三类安全性问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库安全性控制"><span class="nav-number">1.2.</span> <span class="nav-text">数据库安全性控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用户标识与鉴别"><span class="nav-number">1.2.1.</span> <span class="nav-text">用户标识与鉴别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存取控制"><span class="nav-number">1.2.2.</span> <span class="nav-text">存取控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自主存取控制（DAC）方法"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">自主存取控制（DAC）方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#授权与回收"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">授权与回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库角色"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">数据库角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#强制存取控制（MAC）方法"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">强制存取控制（MAC）方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DAC与MAC共同构成DBMS的安全机制"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">DAC与MAC共同构成DBMS的安全机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#视图机制"><span class="nav-number">1.3.</span> <span class="nav-text">视图机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#审计"><span class="nav-number">1.4.</span> <span class="nav-text">审计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据加密"><span class="nav-number">1.5.</span> <span class="nav-text">数据加密</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#统计数据库安全性"><span class="nav-number">1.6.</span> <span class="nav-text">统计数据库安全性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">1.7.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库完整性"><span class="nav-number">2.</span> <span class="nav-text">数据库完整性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实体完整性"><span class="nav-number">2.1.</span> <span class="nav-text">实体完整性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实体完整性定义"><span class="nav-number">2.1.1.</span> <span class="nav-text">实体完整性定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实体完整性检查和违约处理"><span class="nav-number">2.1.2.</span> <span class="nav-text">实体完整性检查和违约处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参照完整性"><span class="nav-number">2.2.</span> <span class="nav-text">参照完整性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#参照完整性定义"><span class="nav-number">2.2.1.</span> <span class="nav-text">参照完整性定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参照完整性检查和违约处理"><span class="nav-number">2.2.2.</span> <span class="nav-text">参照完整性检查和违约处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户定义的完整性"><span class="nav-number">2.3.</span> <span class="nav-text">用户定义的完整性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完整性约束命名子句"><span class="nav-number">2.4.</span> <span class="nav-text">完整性约束命名子句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#域中的完整性限制"><span class="nav-number">2.5.</span> <span class="nav-text">域中的完整性限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#触发器"><span class="nav-number">2.6.</span> <span class="nav-text">触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义触发器"><span class="nav-number">2.6.1.</span> <span class="nav-text">定义触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#激活触发器"><span class="nav-number">2.6.2.</span> <span class="nav-text">激活触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除触发器"><span class="nav-number">2.6.3.</span> <span class="nav-text">删除触发器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结-1"><span class="nav-number">2.7.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Qsx</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">65.7k</span></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span><span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/love.js"></script></body></html>