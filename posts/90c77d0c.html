<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="学习,数据库,"><meta name="description" content="设计与应用开发内容  一、关系数据理论二、数据库设计三、数据库编程"><meta name="keywords" content="学习,数据库"><meta property="og:type" content="article"><meta property="og:title" content="数据库开发"><meta property="og:url" content="https://www.shelhon.cn/posts/90c77d0c.html"><meta property="og:site_name" content="无问西东"><meta property="og:description" content="设计与应用开发内容  一、关系数据理论二、数据库设计三、数据库编程"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/1.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/2.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/3.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/4.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/5.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/6.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/7.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/8.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/9.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/10.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/11.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/12.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/13.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/14.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/15.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/18.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/16.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/17.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/19.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/20.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/21.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/22.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/23.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/24.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/25.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/26.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/38.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/39.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/40.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/41.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/42.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/27.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/43.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/28.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/29.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/30.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/31.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/32.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/33.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/34.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/35.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/36.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/37.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/44.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/45.png"><meta property="og:image" content="https://www.shelhon.cn/posts/90c77d0c/46.png"><meta property="og:updated_time" content="2018-09-03T07:59:14.397Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据库开发"><meta name="twitter:description" content="设计与应用开发内容  一、关系数据理论二、数据库设计三、数据库编程"><meta name="twitter:image" content="https://www.shelhon.cn/posts/90c77d0c/1.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://www.shelhon.cn/posts/90c77d0c.html"><title>数据库开发 | 无问西东</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3275656b1c327868bf311aa7c5fdabd2";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="https://github.com/Shelhon/Shelhon.github.io" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64ceaa;color:#fff;position:absolute;top:0;border:0;left:0;transform:scale(-1,1)" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">无问西东</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">糊涂脸水聪明枕</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br> 公益404</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.shelhon.cn/posts/90c77d0c.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Qsx"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="无问西东"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">数据库开发</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-24T19:07:04+08:00">2018-08-24</time></span> <span class="post-updated">&nbsp; | &nbsp; 更新于 <time itemprop="dateUpdated" datetime="2018-09-03T15:59:14+08:00" content="2018-09-03">2018-09-03</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span></span> <span class="post-meta-divider">|</span><span class="page-pv"><i class="fa fa-file-o"></i><span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">20,498</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">73</span></div></div></header><div class="post-body" itemprop="articleBody"><center><strong>设计与应用开发内容</strong></center><p>一、关系数据理论<br>二、数据库设计<br>三、数据库编程</p><hr><a id="more"></a><h1 id="关系数据理论"><a href="#关系数据理论" class="headerlink" title="关系数据理论"></a>关系数据理论</h1><h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><p>一 、关系模式</p><p>关系模式是一个五元组。<br> R &lt; U，D ，dom , F &gt;</p><p>（1）关系名R，它是符号化的元组语义；</p><p>（2）一组属性U；</p><p>（3）属性组U中属性所来自的域D；</p><p>（4）属性到域的映射dom；</p><p>（5）属性组U上的一组数据依赖F。即属性值间的相互关连</p><p>由于（3），（4）对模式设计关系不大，因此在本章中把关系模式看作是一个三元组： R &lt;U，F&gt;</p><p>当且仅当U上的一个关系 r 满足 F 时，r 称为关系模式R&lt;U，F&gt;的一个关系。</p><p>第一范式（1NF）：关系模式中每一个分量必须是不可分的数据项。满足了这个条件的就属于第一范式（1NF）。</p><p>二、 数据依赖</p><p>数据依赖是数据库模式设计的关键，它是一个关系内部属性与属性之间的一种约束关系，这种约束关系是通过属性间的值是否相等体现出来的数据间的相互关系。<br>它是现实世界属性间相互联系的抽象，是数据内在的性质，是语义的体现。<br>数据依赖有很多类型，其中最重要的是：<br>函数依赖（Functional Dependency，简记为FD）<br>多值依赖（Multivalued Dependency，简记为MVD）</p><p>其中，函数依赖起着核心的作用，是模式分解和模式设计的基础，范式是模式分解的标准。</p><blockquote><p>比如描述一个学生的关系，可以有学号（SNO），姓名（SNAME），系名（SDEPT）等几个属性。由于一个学号只对应一个学生，一个学生只在一个系学习。因而当“学号”值确定之后，姓名和该生所在系的值也就被唯一地确定了。就象自变量x确定之后，相应的函数值f(x)也就唯一地确定了一样，称SNO函数决定SNAME和SDEPT，或者说SNAME，SDEPT函数依赖于SNO，记为：SNO→SNAME，SNO→SDEPT。</p></blockquote><p>例 现在要建立一个数据库来描述学生的一些情况，面临的对象有：<br>单一的关系模式<br>Student（U,F）</p><p> U={SNO，SDEPT，MN，CNAME，G}</p><p>SNO 学号，SDEPT 系，MN 系负责人，CNAME 课程名，G 成绩</p><p>由现实世界的已知事实得知：</p><p>①一个系有若干学生，但一个学生只属于一个系；</p><p>②一个系只有一名（正职）负责人；</p><p>③一个学生可以选修多门课程，每门课程有若干学生选修；</p><p>④每个学生学习每一门课程有一个成绩；</p><p>于是得到属性组U上的一组函数依赖：</p><p> F={SNO→SDEPT，SDEPT→MN，（SNO，CNAME）→G}</p><p>这组函数依赖如图</p> <img src="/posts/90c77d0c/1.png"><p>如果只考虑函数依赖这一种数据依赖，就得到了一个描述学校的数据库模式S&lt;U,F&gt;，它由一个单一的关系模式构成。这个模式有下述三个“毛病”：</p><p>（1）<strong>插入异常 :</strong>如果一个系刚成立尚无学生，或者虽然有了学生但尚未安排课程。那么就无法把这个系及其负责人的信息存入数据库。</p><p>（2）<strong>删除异常:</strong> 如果某个系的学生全部毕业了，在删除该系学生选修课程的同时，把这个系及其负责人的信息也丢掉了。</p><p>（3）<strong>冗余太大</strong>。比如，每一个系负责人的姓名要与该系每一个学生的每一门功课的成绩出现的次数一样多。这样，一方面浪费存储，另一方面系统要付出很大的代价来维护数据库的完整性。比如某系负责人更换后，就必须逐一修改有关的每一个元组。</p><p>由于上述三个“毛病”，它是一个“不好”的数据库模式。一个“好”的模式应当不会发生插入异常和删除异常、冗余应尽可能少。</p><p>这个单一的模式改造一下，分成三个关系模式：</p><p>S（SNO，SDEPT，SNO→SDEPT）；</p><p>SG（SNO，CNAME，G，（SNO，CNAME）→G）；</p><p>DEPT（SDEPT，MN，SDEPT→MN）；</p><p>这三个模式就不会发生插入异常、删除异常的毛病，数据的冗余也得到了控制。</p><hr><h2 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h2><p>规范化理论正是用来改造关系模式的，通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题。</p><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>一、定义<br>设R(U)是一个属性集U上的关系模式，X和Y是U的子集。<br> 若对于R(U)的任意一个可能的关系 r，r 中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X函数确定Y” 或 “Y函数依赖于X”，记作X→Y。</p><ul><li>X称为这个函数依赖的决定属性集(Determinant)。</li><li>Y = f(x)</li></ul><p>说明：</p><ul><li>函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的所有关系实例均要满足的约束条件。</li><li>函数依赖是语义范畴的概念，只能根据数据的语义来确定函数依赖。例如：“姓名→年龄”这个函数依赖只有在不允许有同名人的条件下成立。</li><li>数据库设计者可以对现实世界作强制的规定。例如规定不允许同名人出现，函数依赖“姓名→年龄”成立。所插入的元组必须满足规定的函数依赖，若发现有同名人存在， 则拒绝装入该元组。</li></ul><p>例如<br>Student ( Sno, Sname, Ssex, Sage, Sdept ) 中<br> 假设不允许学生重名，则有:<br> Sno → Ssex， Sno → Sage , Sno → Sdept，<br> Sno ← → Sname, Sname → Ssex， Sname → Sage<br> Sname → Sdept<br> 但Ssex ！→ Sage<br> 若X→Y，并且Y→X, 则记为X← →Y。<br> 若Y不函数依赖于X, 则记为X ！→Y。</p><p>二、术语和记号：</p><ul><li><p>X→Y，但Y⊈ X则称X→Y是 <strong>非平凡的函数依赖</strong>。若不特别声明，总是讨论非平凡的函数依赖。</p></li><li><p>X→Y，但Y⊆X则称X→Y是 <strong>平凡的函数依赖</strong>。</p></li><li><p>若X→Y，则X叫做<strong>决定因素</strong>（Determinant）。</p></li><li><p>若X→Y，Y→X，则记作X←→Y。</p></li><li><p>若Y函数不依赖于X，则记作X ！→Y。</p></li></ul><p>例：在关系SC（Sno, Cno, Grade）中，</p><p> 非平凡函数依赖： (Sno, Cno) → Grade<br> 平凡函数依赖：　 (Sno, Cno) → Sno<br>　　　　　　　　 (Sno, Cno) → Cno</p><p>三、完全依赖和部分依赖</p> <img src="/posts/90c77d0c/2.png"><p>　<br> 　 　　 　 　 ｐ<br>而(Sno ,Cno )→Sdept是部分函数依赖，因为Sno→Sdept成立，而Sno是(Sno ,Cno )真子集</p><p>四、传递函数依赖</p> <img src="/posts/90c77d0c/3.png"><hr><h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p> 设K为关系模式R&lt;U,F&gt;中的属性或属性组合。</p><ul><li>若K → U，则K称为R的一个候选码（Candidate Key）。</li><li>若关系模式R有多个候选码，则选定其中的一个作为主码（Primary key）。</li><li>包含在任何一个候选码中的属性，称为主属性（Prime attribute）；</li><li>不包含在任何码中的属性，称为非主属性（Nonprime attribute）或非码属性（Non-key attribute）。</li></ul><p>例 :关系模式S（<u>Sno</u>，Sdept，Sage）中单个属性Sno是码，用下横线表示出来。SC（<u>Sno，Cno</u>，Grade）中属性组合（Sno，Cno）是码</p><p> 极端的情况是：整个属性组U是码，即所有属性当作一个码。若关系中只有一个候选码,且这个候选码中包含全部属性,则该候选码为全码，称为全码（All-key）。</p><p>例：关系模式R（<u>P，W，A</u>），属性P表示演奏者，W表示作品，A表示听众。假设一个演奏者可以演奏多个作品,某一作品可被多个演奏者演奏。听众也可以欣赏不同的演奏者的不同作品，这个关系的码为（P，W，A），即All-Key。</p><p>关系模式 R 中属性或属性组X 并非 R的码，但 X 是另一个关系模式的码，则称 X 是R 的外部码（Foreign key），也称外码。<br>主码和外码一起提供了表示关系间联系的手段。 例如上面的关系模式S于SC的联系就是通过Sno来体现的。</p><p>例如 在SC（Sno，Cno，Grade）中，Sno不是码，但Sno是关系模式S（Sno，Sdept，Sage）的码，则Sno是关系模式SC的外部码。</p><hr><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。<br>范式的种类包括：</p><ul><li>满足最低要求的，称为第一范式(1NF)</li><li>在第一范式中，满足进一步要求的，称为第二范式(2NF)</li><li>以此类推：第三范式(3NF)</li><li>BC范式(BCNF)</li><li>第四范式(4NF)</li><li>第五范式(5NF)<br>某一关系模式R为第n范式，可简记为R∈nNF</li></ul><p>5NF⊂4NF⊂BCNF⊂3NF⊂2NF⊂1NF</p><p>各模式之间的联系如下图</p> <img src="/posts/90c77d0c/4.png"><p>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化</p><p>一、 第一范式（1NF）</p><ul><li><p>关系中的每个分量必须是不可分的数据项。<br>满足了这个条件的关系模式R就属于第一范式（1NF），记作 R∈1NF。</p></li><li><p>第一范式是对关系模式的最起码的要求。<br>不满足第一范式的数据库模式不能称为关系数据库。</p></li></ul><p>满足第一范式的关系模式并不一定是一个好的关系模式。</p><p>例如 关系模式 SLC（Sno, Sdept, Sloc, Cno, Grade）<br> Sloc为学生住处，假设每个系的学生住在同一个地方。</p> <img src="/posts/90c77d0c/5.png"><p>SLC的码为(Sno, Cno)<br>非主属性Sdept和Sloc部分函数依赖于码(Sno, Cno)<br>SLC ∈1NF ，但是SLC并不是一个好的关系模式。</p><p>①插入异常<br>假设Sno＝’95102’，Sdept＝’IS’，Sloc＝’N’ 的学生还未选课，因课程号是主属性，因此该学生的信息无法插入SLC。<br>②删除异常<br>假定某个学生本来只选修了3号课程这一门课。现在因身体不适，他连3号课程也不选修了。因课程号是主属性，此操作将导致该学生信息的整个元组都要删除。<br>③数据冗余度大<br>如果一个学生选修了10门课程，那么他的Sdept和Sloc值就要重复存储10次。<br>④修改复杂<br>例如学生转系，在修改此学生元组的Sdept值的同时，还可能需要修改住处（Sloc）。如果这个学生选修了n门课，则必须无遗漏地修改n个元组中全部Sdept、Sloc信息。</p><p>造成这些问题的原因是：Sdept、 Sloc部分函数依赖于码。</p><p>解决方法：将SLC分解为两个关系模式，以消除这些部分函数依赖</p><p><strong>关系模式分解应当具有无损连接性和依赖保持性</strong></p><p>SC（Sno， Cno， Grade）<br>SL（Sno， Sdept， Sloc）</p> <img src="/posts/90c77d0c/6.png"><hr><p>二、第二范式（2NF）</p><p>定义 ：若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的码，则R∈2NF。</p><p>例<br>SLC(Sno, Sdept, Sloc, Cno, Grade) ∈1NF<br>SLC(Sno, Sdept, Sloc, Cno, Grade) ∉ 2NF<br>SC（Sno， Cno， Grade） ∈ 2NF<br>SL（Sno， Sdept， Sloc） ∈ 2NF</p><p>采用投影分解法将一个1NF的关系分解为多个2NF的关系，可以在一定程度上减轻原1NF关系中存在的插入异常、删除异常、数据冗余度大、修改复杂等问题。<br>但是，将一个1NF关系分解为多个2NF的关系，并不能完全消除关系模式中的各种异常情况和数据冗余。</p><p>三、第三范式（3NF）</p> <img src="/posts/90c77d0c/7.png"> <img src="/posts/90c77d0c/8.png"> <img src="/posts/90c77d0c/9.png"><p>如果R∈3NF，则R∈2NF。</p><p>采用投影分解法将一个2NF的关系分解为多个3NF的关系，可以在一定程度上解决原2NF关系中存在的插入异常、删除异常、数据冗余度大、修改复杂等问题。<br>但是，将一个2NF关系分解为多个3NF的关系后，并不能完全消除关系模式中的各种异常情况和数据冗余。</p><p>四、BCNF</p><p>BCNF是修正的第三范式，有时也称为扩充的第三范式。</p><p>设关系模式R&lt;U，F&gt;∈1NF，如果对于R的每个函数依赖X→Y，若Y不属于X，则X必含有候选码，那么R∈BCNF。</p><p>也就是说，关系模式R&lt;U,F&gt;中，若每一个决定因素都包含码</p><p>若R∈BCNF，则：</p><ul><li>每一个决定属性集（因素）都包含（候选）码</li><li>R中的所有属性（主属性和非主属性）都完全函数依赖于码</li><li>R∈3NF（由定义可知，排除了任何属性对码的传递依赖和部分依赖）</li></ul><p>但是，若R∈3NF，R不一定∈BCNF</p><p>例 在关系模式C（Cno，Cname，Pcno）中，只有一个码Cno。</p><ul><li>由于没有任何属性对Cno部分依赖或传递依赖，所以C∈3NF；</li><li>同时C中Cno是唯一的决定因素，所以C∈BCNF。</li></ul><p>例 关系模式 S（Sno, Sname, Sdept, Sage）中，假定Sname具有唯一性，那么S就有两个码（Sno和Sname），这两个码都由单个属性组成，彼此不相交。</p><ul><li>其他属性不存在对码的传递依赖与部分依赖，所以S∈3NF；</li><li>同时S中除Sno和Sname以外没有其他决定因素，所以S∈BCNF。</li></ul><p>例 关系模式 SJP（S, J, P）中，S表示学生，J表示课程，P表示名次。每个学生选修每门课程的成绩有一定的名次，每门课程中的每一名次只有一个学生（即没有并列名次）。由语法可以得到下面的函数依赖：<br> （S, J） → P，（J, P） → S</p><p>所以（S, J）和（J, P）都可以作为候选码，这两个码各由两个属性组成，而且它们是相交的。</p><ul><li>这个关系模式中显然没有属性对码的传递依赖或部分依赖。所以SJP∈3NF；</li><li>而且除了（S, J）和（J, P）以外没有其他的决定因素，所以SJP∈BCNF。</li></ul><p>例 在关系模式STJ（S，T，J）中，S表示学生，T表示教师，J表示课程。每一教师只教一门课。每门课由若干教师教，某一学生选定某门课，就确定了一个固定的教师。某个学生选修某个教师的课就确定了所选课的名称。则有如下的函数依赖：<br>（S，J）→ T，（S，T）→ J，T → J<br>这里(S，J)和(S，T)都可以作为候选码 ，S、T、J都是主属性<br>没有任何非主属性对码的传递依赖或部分依赖，所以STJ∈3NF；<br>由于T→J，T是决定因素，而T不是候选码，所以STJ∉BCNF。</p><p>非BCNF的关系模式也可以通过分解成为BCNF。<br>可分解为ST（S，T）<br>TJ（T，J） 它们都是BCNF。</p><p>3NF和BCNF是在函数依赖的条件下对模式分解所能达到的分离程度的测度。一个模式中的关系模式如果都属于BCNF，那么在函数依赖范畴内，它已实现了彻底的分离，已消除了插入和删除的异常。3NF的“不彻底”性表现在可能存在主属性对码的部分依赖和传递依赖。</p><hr><p>五、多值依赖</p><p>属于BCNF的关系模式是否就很完美了呢？下面来看一个例子。</p><ol><li>例如 学校中某一门课程由多个教员讲授，他们使用相同的一套参考书。每个教员可以讲授多门课程，每种参考书可以供多门课程使用。可以用一个非规范化的关系来表示教员T，课程C和参考书B之间的关系（如表6.1所示）。</li></ol> <img src="/posts/90c77d0c/10.png"> <img src="/posts/90c77d0c/11.png"><p>关系模型TEACHING（C，T，B）的码是（C，T，B），即All-Key。因而TEACHINGÎBCNF。</p><p>对数据的增删改很不方便，数据的冗余也十分明显。仔细考察这类关系模式，发现它具有一种称之为多值依赖（MVD）的数据依赖。</p><p>定义 ：设R（U）是属性集U上的一个关系模式。X，Y，Z是U的子集，并且Z=U-X-Y。关系模式R（U）中多值依赖X→→Y成立，当且仅当对R（U）的任一关系r，给定的一对（x,z）值，有一组Y的值，这组值仅仅决定于x值而与z值无关。</p><p>若X→→Y，而Z=f即Z为空，则称X→→Y为平凡的多值依赖</p><p> 多值依赖具有以下性质：</p><p>（1）多值依赖具有对称性。即若X→→Y，则X→→Z，其中Z=U-X-Y。</p><p>（2）多值依赖的传递性。即若X→→Y，Y→→Z，则X→→Z-Y。</p><p>（3）函数依赖可以看作是多值依赖的特殊情况。即若X→Y，则X→→Y。</p><p>（4）若X→→Y，X→→Z，则X→→YZ。</p><p>（5）若X→→Y，X→→Z，则X→→Y∩Z。</p><p>（6）若X→→Y，Y→→Z，则X→→Y-Z，X→→Z-Y。</p><p>多值依赖与函数依赖相比，具有下面两个基本的区别：</p><p>（1）多值依赖的有效性与属性集的范围有关。</p><p>若X→→Y在U上成立则在W（XY⊆W⊆U）上一定成立；反之则不然，即X→→Y在W（W⊂U）上成立，在U上并不一定成立。这是因为多值依赖的定义中不仅涉及属性组X和Y，而且涉及U中其余属性Z。</p><p>一般地，在R（U）上若有X→→Y在W（W⊂U）上成立，则称X→→Y为R（U）的嵌入型多值依赖。</p><p>但是在关系模式R（U）中函数依赖X→Y的有效性仅决定于X，Y这两个属性集的值。只要在R（U）的任何一个关系r中，元组在X和Y上的值满足函数依赖的定义，则函数依赖X→Y在任何属性集W（XY⊆W⊆U）上成立。</p><p>（2）若函数依赖X→Y在R（U）上成立，则对于任何Y’⊂Y均有X→Y’成立。而多值依赖X→→Y若在R（U）上成立，却不能断言对于任何Y⊂Y有X→→Y’成立。</p><hr><p>六、4NF</p><p>定义 关系模式R&lt;U，F&gt;∈1NF，如果对于R的每个非平凡多值依赖X→→Y（Y⊈X），X都含有码，则称R&lt;U,F&gt;∈4NF。</p><p>4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。因为根据定义，对于每一个非平凡的多值依赖X→→Y，X都含有候选码，于是就有X→Y，所以4NF所允许的非平凡的多值依赖实际上是函数依赖。</p><p>如果一个关系模式是4NF，则必为BCNF。</p><p>关系模式WSC的码是（W，S，C），即All-Key。WSC∈BCNF 但WSC∉ 4NF。</p><p>一个关系模式如果已达到了BCNF但不是4NF，这样的关系模式仍然具有不好的性质。数据冗余及插入、修改、删除异常等问题。因此还应该继续规范化使关系模式WSC达到4NF。</p><p>可以用投影分解的方法消去非平凡且非函数依赖的多值依赖。</p><p>例如可以把WSC分解为WS（W，S），WC（W，C）。在WS中虽然有W→→S，但这是平凡的多值依赖。WS中已不存在非平凡的非函数依赖的多值依赖。所以WS∈4NF。</p><p>函数依赖和多值依赖是两种最重要的数据依赖。如果只考虑函数依赖，则属于BCNF的关系模式规范化程度已经是最高的了。如果考虑多值依赖，则和多值依赖之外，还有其他数据依赖。例如有一种连接依赖。函数依赖是多值依赖的一种特殊情况，而多值依赖实际上又是连接依赖的一种特殊情况。但连接依赖不像函数依赖和多值依赖可由语义直接导出，而是在关系的连接运算时才反映出来。存在连接依赖的关系模式仍可能遇到数据冗余及插入、修改、删除异常等问题。如果消除了属于4NF的关系模式中存在的连接依赖，则可以进一步达到5NF的关系模式。</p><h3 id="规范化小结"><a href="#规范化小结" class="headerlink" title="规范化小结"></a>规范化小结</h3><p>规范化的基本思想为：</p><ul><li>逐步消除不合适的数据依赖，使各关系模式达到某种程度的“分离”，即采用“一事一地”的模式设计原则：让一个关系描述一个概念、一个实体或者实体间的一种联系。若多于一个概念就把它“分离”出去。</li><li><p>因此，所谓规范化实质上是概念的单一化。</p></li><li><p>此外，并不能说规范化程度越高的关系模式就越好。</p></li><li>在设计数据库模式结构时，必须对现实世界的实际情况和用户应用需求作进一步分析，确定一个合适的、能够反映现实世界的模式。上面的规范化步骤可以在其中任何一步终止。</li><li>在实际应用中，最有价值的是3NF和BCNF，在进行关系模式的设计时，通常分解到3NF就足够了。</li></ul> <img src="/posts/90c77d0c/12.png"><hr><h2 id="数据依赖的公理系统"><a href="#数据依赖的公理系统" class="headerlink" title="数据依赖的公理系统"></a>数据依赖的公理系统</h2><p>数据依赖的公理系统是模式分解算法的理论基础，下面首先讨论函数依赖的一个有效而完备的公理系统——Armstrong公理系统。<br>其用途是：</p><ul><li>求给定关系模式的码</li><li>从一组函数依赖求得蕴含的函数依赖 。</li></ul><p>定义 对于满足一组函数依赖 F 的关系模式R &lt;U, F&gt;，其任何一个关系 r，若函数依赖 X→Y 都成立（即 r 中任意两个元组 t 和 s，若 t[X] = s[X]，则 t[Y] = s[Y]）, 则称 F 逻辑蕴含 X →Y。</p><p>Armstrong公理系统 设U为属性集总体，F是U上的一组函数依赖，于是有关系模式R&lt;U,F&gt;。对R&lt;U,F&gt;来说有以下的推理规则：</p><p>A1自反律（Reflexivity）：若Y⊆X⊆U，则X→Y为F所蕴含。</p><p>A2增广律（Augmentation）：若X→Y为F所蕴含，且Z⊆U，则X∪Z→Y∪Z为F所蕴含。</p><p>A3传递律（Transitivity）：若X→Y及Y→Z为F所蕴含，则X→Z为F所蕴含。</p><p>注意：由自反律所得到的函数依赖均是平凡的函数依赖，自反律的使用并不依赖于F。</p><p>证明Armstrong推理规则的正确性：</p><p>自反律：<br>若 Y ⊆ X ⊆ U，则 X → Y 为F所蕴含。<br>证明:<br>设 Y ⊆ X ⊆ U，对R &lt;U，F&gt; 的任一关系 r 中的任意两个元组 t和s，有：若 t[X] = s[X]，由于Y ⊆X，必定有 t[Y] =s[Y]，所以 X→Y成立。<br>自反律得证。</p><p>增广律：<br>若 X→Y 为F所蕴含，且 Z ⊆ U，则 X∪Z → Y∪Z 为F所蕴含。<br>证明:<br>设 X→Y 为F所蕴含，且Z ⊆ U。设R&lt;U，F&gt; 的任一关系 r 中任意的两个元组 t和s<br>有：若 t[XZ] = s[XZ]，则有 t[X] = s[X] 和 t[Z] = s[Z]。<br>因为X→Y，则有 t[Y] = s[Y]，所以 t[YZ] = s[YZ]，所以XZ→YZ为F所蕴含 。<br>增广律得证。</p><p>传递律：<br>若 X→Y 及 Y→Z 为F所蕴含，则 X→Z 为F所蕴含。<br>证明:<br>设 X→Y 及 Y→Z 为F所蕴含。则对R&lt;U，F&gt; 的任一关系 r 中的任意两个元组 t和s<br>有：若 t[X] = s[X]，由于 X→Y，必定有 t[Y] = s[Y]；<br>再由 Y→Z，可知有 t[Z] = s[Z]，所以 X→Z 为F所蕴含 。<br>传递律得证。</p><p>根据A1，A2，A3这三条推理规则可以得到下面三条推理规则：<br>合并规则：由 X→Y，X→Z，有 X→YZ。（A2， A3）<br>伪传递规则：由 X→Y，WY→Z，有 XW→Z。（A2， A3）<br>分解规则：由 X→Y 及 Z⊆Y，有 X→Z。（A1， A3）<br>根据合并规则和分解规则，可得:<br> X→A1 A2 … Ak 成立的充分必要条件是: X→Ai 成立（i=1，2，…，k）。</p><p>小结：一组用于推导函数依赖的规则：<br>若Y ⊆ X， 则X→Y<br>若X→Y，则XZ →YZ<br>若X→Y, Y →Z，则X→Z<br>若X→Y, X →Z，则X →YZ<br>若X→Y, WY →Z，则XW →Z<br>若X→Y, Z ⊆Y，则X →Z<br>若X →YZ，则X→Y, X →Z</p><p>在关系模式R&lt;U,F&gt;中为F所逻辑蕴含的函数依赖的全体叫做F的闭包，记为F<sup>+</sup>。</p><p>人们把自反律，传递律和增广律称为Armstrong公理系统。Armstrong公理系统是有效的、完备的。Armstrong公理的<strong>有效性</strong>指的是：由F出发根据Armstrong公理推导出来的每一个函数依赖一定在F<sup>+</sup>中；<strong>完备性</strong>指的是F<sup>+</sup>中的每一个函数依赖，必定可以由F出发根据Armstrong公理推导出来。</p><p>要证明完备性，就首先要解决如何判定一个函数依赖是否属于由F根据Armstrong公理推导出来的函数依赖的集合。当然，如果能求出这个集合，问题就解决了。但不幸的是，这是一个NP完全问题。比如从F={X→A1，…，X→An}出发，至少可以推导出2<sup>n</sup>个不同的函数依赖为此引入了下面的概念：<br> 设F为属性集U上的一组函数依赖，X⊆U，X<sup>+</sup><sub>F</sub>={A|X→A 能由 F 根据 Armstrong 公理导出}，X<sup>+</sup><sub>F</sub> 称为属性集X关于函数依赖集F的闭包。</p><p>设F为属性集U上的一组函数依赖，X，Y⊆U，X→Y能由F根据Armstrong公理导出的充分必要条件是Y⊆X<sub>F</sub><sup>+</sup>。</p><p>是，判定X→Y是否能由F根据Armstrong公理导出的问题，就转化为求出X<sub>F</sub><sup>+</sup>，判定Y是否为X<sub>F</sub><sup>+</sup>的子集的问题。这个问题由下面的算法解决了。</p><p><strong>算法</strong> ： 求属性集X（X⊆U）关于U上的函数依赖集F的闭包X<sub>F</sub><sup>+</sup>。</p><p>输入：X，F</p><p>输出：X<sub>F</sub><sup>+</sup></p><p>步骤：</p><p>（1）令X（0）=X，i=0</p><p>（2）求B，这里B={A |（∃V）（∃W）（V→W ∈ F ∧ V ⊆ X <sup>（i）</sup> ∧ A ∈W）；</p><p>（3）X<sup>（i+1）</sup>=B∪X<sup>（i）</sup></p><p>（4）判断X<sup>（i+1）</sup> =X<sup>（i）</sup>吗？</p><p>（5）若相等或X<sup>（i+1）</sup>=U，则X<sup>（i+1）</sup>就是X<sub>F</sub><sup>+</sup>，算法终止。</p><p>（6）若否，则i=i+1，返回第（2）步。</p><p>例 书籍关系模式R&lt;U,F&gt;，</p><p>其中U={A，B，C，D，E}；F={AB→C，B→D，C→E，EC→B，AC→B}。</p><p>求（AB）<sub>F</sub><sup>+</sup>。</p><p>解 由算法，设X（0）=AB；</p><ul><li>计算X<sup>（1）</sup>；逐一扫描F集合中各个函数依赖，找左部为A，B或AB的函数依赖。得到两个：AB→C，B→D。于是X<sup>（1）</sup>=AB∪CD=ABCD。</li><li>因为X<sup>（0）</sup> ≠ X<sup>（1）</sup>，所以再找出左部为ABCD子集的那些函数依赖，又得到C→E ，AC→B，于是X<sup>（2）</sup> = X<sup>（1）∪ABCDE</sup></li><li>因为X<sup>（2）</sup>已等于全部属性集合，所以（AB）<sub>F</sub><sup>+</sup>=ABCDE。</li><li>对于算法， 令ai=| X<sup>（i）</sup>|,{a<sub>（i）</sub>}形成一个步长大于1的严格递增的序列，序列的上界是|U|，因此该算法最多|U|-|X|次循环就会终止。</li></ul><p>例：</p> <img src="/posts/90c77d0c/13.png"><p>证明完备性的逆否命题，即若函数依赖X→Y不能由F从Armstrong公理导出，那么它必然不为F所蕴含，它的证明分三步。</p> <img src="/posts/90c77d0c/14.png"><hr><h2 id="模式的分解"><a href="#模式的分解" class="headerlink" title="模式的分解"></a>模式的分解</h2><p>把低一级的关系模式分解为若干个高一级的关系模式的方法并不是唯一的，只有能够保证分解后的关系模式与原关系模式等价，分解方法才有意义</p><p>对于一个模式的分解是多种多样的，但是分解后产生的模式应当与原模式等价。<br>从不同的角度去看，“等价”有三种不同的定义：</p><ul><li>分解具有“无损连接性”</li><li>分解要“保持函数依赖”</li><li>分解既要“保持函数依赖”，又要具有“无损连接性”</li></ul><p>这3个定义是实行分解的3条不同的准则</p><p>例如: SL（Sno， Sdept， Sloc）<br>F = { Sno → Sdept, Sdept → Sloc, Sno → Sloc }<br>SL∈2NF</p><table><thead><tr><th>Sno</th><th>Sdept</th><th>Sloc</th></tr></thead><tbody><tr><td>95001</td><td>CS</td><td>A</td></tr><tr><td>95002</td><td>IS</td><td>B</td></tr><tr><td>95003</td><td>MA</td><td>C</td></tr><tr><td>95004</td><td>IS</td><td>B</td></tr><tr><td>95005</td><td>PH</td><td>B</td></tr></tbody></table><p>该模式存在插入异常、删除异常、冗余度大和修改复杂等问题。</p><ol><li><p>将SL分解为下面三个关系模式：<br>SN(Sno)<br>SD(Sdept)<br>SO(Sloc)<br>分解后的数据库丢失了许多信息。例如无法查询95001学生所在系或所在宿舍。如果分解后的关系可以通过自然连接恢复为原来的关系，那么这种分解就没有丢失信息。</p></li><li><p>将SL分解为下面两个关系模式：<br>NL(Sno, Sloc)<br>DL(Sdept, Sloc)<br>NL ⋈ DL比原来的SL关系多了3个元组，无法知道95002、95004、95005究竟是哪个系的学生 。元组增加了，信息丢失了 。</p></li><li><p>将SL分解为下面两个关系模式：<br>ND(Sno, Sdept)<br>NL(Sno, Sloc)<br>与SL关系一样，因此没有丢失信息，但仍存在插入、删除和更新异常</p></li><li><p>将SL分解为下面两个关系模式：<br>ND(Sno, Sdept)<br>DL(Sdept, Sloc)<br>与SL关系一样，因此没有丢失信息，并且也没有插入、删除和更新异常</p></li></ol><p>所以第四种是比较合适的模式分解。</p><h3 id="具有无损连接性的模式分解"><a href="#具有无损连接性的模式分解" class="headerlink" title="具有无损连接性的模式分解"></a>具有无损连接性的模式分解</h3><p>对于关系模式R&lt;U,F&gt;的一个分解 ρ = { R1&lt;U1, F1&gt;，R2&lt;U2, F2&gt;， …，Rn&lt;Un, Fn&gt;}<br>若R与R1, R2, …, Rn自然连接的结果相等，则称关系模式R的这个分解ρ具有无损连接性（Lossless join）。<br>具有无损连接性的分解保证不丢失信息。<br>但是，无损连接性不一定能解决插入异常、删除异常、修改复杂、数据冗余等问题。</p><p>定理<br>设 ρ={ R1(U1), R2(U2 )} 是 R(U) 的一个分解<br>则ρ为无损分解的充分必要条件为：<br>(U1∩U2) →(U1-U2) 或 (U1∩U2) →(U2-U1)</p><h3 id="保持函数依赖的模式分解"><a href="#保持函数依赖的模式分解" class="headerlink" title="保持函数依赖的模式分解"></a>保持函数依赖的模式分解</h3><p>设关系模式 R&lt;U, F&gt;被分解为若干个关系模式： R1&lt;U1, F1&gt;，R2&lt;U2, F2&gt;， …，Rn&lt;Un, Fn&gt; （其中U=U1∪U2∪…∪Un，且不存在Ui ⊆ Uj，Fi为F在Ui上的投影）<br>若F所有逻辑蕴含的函数依赖一定也由分解得到的某个关系模式中的函数依赖Fi所逻辑蕴含，则称关系模式R的这个分解是保持函数依赖的（Preserve dependency）。<br>判断一个分解是否保持依赖<br>检查每一个原来的依赖关系是否在子模式依赖关系的并的闭包内，涉及如何求一个属性集X的闭包X<sub>F</sub><sup>+</sup></p><h3 id="模式分解小结"><a href="#模式分解小结" class="headerlink" title="模式分解小结"></a>模式分解小结</h3><ul><li>如果一个分解具有无损连接性，则它能够保证不丢失信息。</li><li>如果一个分解保持了函数依赖，则它可以减轻或解决各种异常情况。</li></ul><p>分解具有无损连接性和分解保持函数依赖是两个互相独立的标准。</p><ul><li>具有无损连接性的分解不一定能够保持函数依赖。</li><li>同样，保持函数依赖的分解也不一定具有无损连接性。</li></ul><p>上面例子中（分解 SL(Sno， Sdept， Sloc)）：</p><ul><li>第一种分解方法： SN(Sno)，SD(Sdept)，SO(Sloc)<br>既不具有无损连接性，也未保持函数依赖，它不是原关系模式的一个等价分解。</li><li>第二种分解方法：NL(Sno, Sloc)，DL(Sdept, Sloc)<br>既未保持了函数依赖，也不具有无损连接性。</li><li>第三种分解方法：ND(Sno, Sdept)，NL(Sno, Sloc)<br>具有无损连接性，但未持函数依赖。</li><li>第四种分解方法： ND(Sno, Sdept)，DL(Sdept, Sloc)<br>既具有无损连接性，又保持了函数依赖。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>在规范化过程中，逐渐消除存储异常，使数据冗余尽量小，便于插入、删除和更新。规范化的基本原则就是遵从概念单一化“一事一地”的原则，即一个关系只描述一个实体或者实体间的联系。</li><li>规范化的投影分解方法不是唯一的，对于3NF的规范化，分解既要具有无损连接性，又要具有函数依赖保持性。</li><li>规范化理论为数据库设计提供了理论的指南和工具。</li><li>并不是规范化程度越高，模式就越好，必须结合应用环境和现实世界的具体情况合理地选择数据库模式。</li></ul><hr><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="数据库设计概述"><a href="#数据库设计概述" class="headerlink" title="数据库设计概述"></a>数据库设计概述</h2><p>数据库设计是指对于一个给定的应用环境，构造最优的数据库模式，建立数据库及其应用系统，使之能够有效地存储数据，满足各种用户的应用需求（信息要求和处理要求）</p><p>在数据库领域内，常常把使用数据库的各类系统统称为数据库应用系统。<br>数据库是信息系统的核心和基础，它把信息系统中大量的数据按一定的模型组织起来，提供存储、维护、检索数据的功能，使信息系统可以方便、及时、准确地从数据库中获得所需信息。</p><p>数据库是信息系统的各个部分能否紧密地结合在一起以及如何结合的关键所在，数据库设计是信息系统开发和建设的重要组成部分。</p><p>数据库设计人员应该具备的技术和知识有：</p><ul><li>数据库的基本知识</li><li>数据库设计技术</li><li>计算机科学的基础知识</li><li>程序设计的方法和技巧</li><li>软件工程的原理和方法</li><li>应用领域的知识</li></ul><h3 id="数据库设计的特点"><a href="#数据库设计的特点" class="headerlink" title="数据库设计的特点"></a>数据库设计的特点</h3><p>数据库结构（数据）设计与行为（处理）设计相结合</p><ol><li><p>数据库的结构设计</p><ul><li>数据库的结构设计指是根据给定的应用环境，进行数据库的模式或子模式的设计。它包括数据库的概念设计、逻辑设计和物理设计。</li><li>数据库模式是各应用程序共享的结构，是静态的、稳定的，一经形成后通常情况下是不容易改变的，所以结构设计又称为静态模型设计。</li></ul></li><li><p>数据库的行为设计</p><ul><li>数据库的行为设计是指确定数据库用户的行为和动作。而在数据库系统中，用户的行为和动作指用户对数据库的操作，这些要通过应用程序来实现，所以数据库的行为设计就是应用程序的设计。</li><li>用户的行为总是使数据库的内容发生变化，所以行为设计是动态的，行为设计又称为动态模型设计。</li></ul></li></ol><h3 id="数据库设计方法"><a href="#数据库设计方法" class="headerlink" title="数据库设计方法"></a>数据库设计方法</h3><p>数据库设计方法目前可分为四类：</p><ul><li>直观设计法</li><li>规范设计法</li><li>计算机辅助设计法</li><li>自动化设计法</li></ul><p>一、直观设计法<br>直观设计法也叫手工试凑法，它是最早使用的数据库设计方法。<br>这种方法依赖于设计者的经验和技巧，缺乏科学理论和工程原则的支持，设计的质量很难保证，常常是数据库运行一段时间后又发现各种问题，这样再重新进行修改，增加了系统维护的代价。<br>因此，这种方法越来越不适应信息管理发展的需要。</p><p>二、规范设计法<br>也称为新奥尔良法，它是目前公认的比较完整和权威的一种规范设计法。<br>新奥尔良法将数据库设计分成需求分析（分析用户需求）、概念设计（信息分析和定义）、逻辑设计（设计实现）和物理设计（物理数据库设计）。<br>其基本思想是：过程迭代和逐步求精。<br>下面简单介绍几种常用的规范设计方法。</p><ul><li>基于E-R模型的数据库设计方法<br>该方法是在需求分析的基础上，用E-R图构造一个反映现实世界实体之间联系的企业模式，然后再将此企业模式转换成基于某一特定的DBMS的概念模式。</li><li>基于3NF的数据库设计方法<br>该方法是在需求分析的基础上，确定数据库模式中的全部属性和属性间的依赖关系，将它们组织在一个单一的关系模式中，然后再分析模式中不符合3NF的约束条件，将其进行投影分解，规范成若干个3NF关系模式的集合。</li><li>基于视图的数据库设计方法<br>该方法先从分析各个应用的数据着手，其基本思想是为每个应用建立自己的视图，然后再把这些视图汇总起来合并成整个数据库的概念模式。</li></ul><p>计算机辅助设计法<br>ORACLE Designer 2000<br>SYBASE PowerDesigner</p><hr><h3 id="数据库设计的基本步骤"><a href="#数据库设计的基本步骤" class="headerlink" title="数据库设计的基本步骤"></a>数据库设计的基本步骤</h3><p>和其他软件一样，数据库的设计过程可以使用软件工程中的生存周期的概念来说明，称为“数据库设计的生存期”，它是指从数据库研制到不再使用它的整个时期。</p><p>按规范设计法可将数据库设计分为六个阶段：</p><ol><li>系统需求分析阶段</li><li>概念结构设计阶段</li><li>逻辑结构设计阶段</li><li>物理设计阶段</li><li>数据库实施阶段</li><li>数据库运行与维护阶段</li></ol> <img src="/posts/90c77d0c/15.png"><p>一、系统需求分析阶段</p><ul><li>需求分析是整个数据库设计过程的基础，要收集数据库所有用户的信息内容和处理要求，并加以规格化和分析。</li><li>这是最费时、最复杂的一步，但也是最重要的一步，相当于待构建的数据库大厦的地基，它决定了以后各步设计的速度与质量。需求分析做得不好，可能会导致整个数据库设计返工重做。</li><li>在分析用户需求时，要确保用户目标的一致性。</li></ul><p>二、概念结构设计阶段</p><ul><li>概念设计是把用户的信息要求统一到一个整体逻辑结构中，此结构能够表达用户的要求，是一个独立于任何DBMS软件和硬件的概念模型。</li><li>这个阶段是整个数据库设计的关键所在。</li></ul><p>三、逻辑结构设计阶段</p><ul><li>逻辑设计是将上一步所得到的概念模型转换为某个DBMS所支持的数据模型，并对其进行优化。</li></ul><p>四、物理设计阶段</p><ul><li>物理设计是为逻辑数据模型建立一个完整的能实现的数据库结构，包括存储结构和存取方法。</li></ul><p>五、数据库实施阶段</p><ul><li>设计人员根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。</li></ul><p>六、数据库运行与维护阶段</p><ul><li>这一阶段主要是收集和记录实际系统运行的数据，数据库运行的记录用来提高用户要求的有效信息，用来评价数据库系统的性能，进一步调整和修改数据库。</li><li>在数据库系统运行过程中必须不断地对其进行评价、调整与修改，以保持数据库的完整性，并能有效地处理数据库故障和进行数据库恢复。在运行和维护阶段，可能要对数据库结构进行修改或扩充。</li></ul><p>设计一个完善的数据库应用系统，往往是上述六个阶段的不断反复。</p><p>按照上述原则，设计过程各个阶段的设计描述，可以用下图概括</p> <img src="/posts/90c77d0c/18.png"><hr><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>需求分析是数据库设计的起点，为以后的具体设计做准备。<br>需求分析的结果是否准确的反映了用户的实际要求，将直接影响到后面各个阶段的设计，并影响到设计结果是否合理和实用。<br>经验证明，由于设计要求的不正确或误解，直到系统测试阶段才发现许多错误，则纠正起来要付出很大代价。因此，必须高度重视系统的需求分析。</p><p>一、需求分析的任务</p><ul><li>从数据库设计的角度来看，需求分析的任务是：对现实世界要处理的对象（组织、部门、企业）等进行详细的调查，通过对原系统（手工系统或计算机系统）的了解，明确用户的各种需求，收集支持新系统的基础数据并对其进行处理，在此基础上确定新系统的功能。</li><li>新系统必须充分考虑今后可能的扩充和改变，不能仅仅按当前应用需求来设计数据库。</li></ul><p>二、需求分析的重点<br>需求分析的重点是调查、收集与分析用户在数据管理中的：</p><ul><li>信息要求 —— 指用户需要从数据库中获得信息的内容与性质。由用户的信息要求可以导出数据要求，即在数据库中需要存储哪些数据。</li><li>处理要求 —— 指用户要完成什么处理功能，对处理的响应时间的要求，对处理方式的要求(批处理 / 联机处理)。</li><li>安全性与完整性要求</li></ul><p>三、需求分析的难点</p><ul><li>确定用户最终需求的难点<ul><li>用户缺少计算机知识，开始时无法确定计算机究竟能为自己做什么，不能做什么，因此无法一下子准确地表达自己的需求，他们所提出的需求往往不断地变化。</li><li>设计人员缺少用户的专业知识，不易理解用户的真正需求，甚至误解用户的需求。</li><li>新的硬件、软件技术的出现也会使用户需求发生变化。</li></ul></li><li>解决方法<br>设计人员必须采用有效的方法，与用户不断深入地进行交流，才能逐步得以确定用户的实际需求。</li></ul><p>四、需求分析的方法</p><ol><li><p>首先是调查清楚用户的实际需求并进行初步分析，与用户达成共识，然后 进一步分析与表达这些需求。</p><ul><li>调查组织机构情况，包括了解组织部门的组成情况和各部门的职责等。</li><li>调查各部门的业务活动情况，调查重点之一。包括了解各个部门输入和使用什么数据；如何加工处理这些数据；输出什么信息；输出到什么部门；输出结果的格式是什么，等等。</li></ul></li><li><p>做需求调查时，往往需要同时采用多种方法。无论使用何种调查方法，都必须有用户的积极参与和配合。</p></li><li>设计人员应该和用户取得共同的语言，帮助不熟悉计算机的用户建立数据库环境下的共同概念，并对设计工作的最后结果共同承担责任。</li></ol><p>常用调查方法包括：</p><ul><li>跟班作业。通过亲身参加业务工作了解业务活动的情况，能比较准确地理解用户的需求，但比较耗时。</li><li>开调查会。通过与用户座谈来了解业务活动情况及用户需求。</li><li>请专人介绍。</li><li>询问。对某些调查中的问题，可以找专人询问。</li><li>设计调查表请用户填写。如果调查表设计合理，则很有效，且易于为用户接受。</li><li>查阅记录。查阅与原系统有关的数据记录。</li></ul><p>五、进一步分析和表达用户需求<br>分析和表达用户的需求的常用方法是：<br>自顶向下的结构化分析方法（Structured Analysis，简称SA方法）</p><p>SA方法从最上层的系统组织机构入手，采用逐层分解的方式分析系统，并用数据流图和数据字典描述系统。</p> <img src="/posts/90c77d0c/16.png"><p>要反映更详细的内容，需要分解处理功能和数据。</p><ul><li>分解处理功能<ul><li>将处理功能的具体内容分解为若干子功能，再将每个子功能继续分解，直到把系统的工作过程表达清楚为止。</li><li>分解后的处理过程，用<strong>判定表</strong>或<strong>判定树</strong>来描述。</li></ul></li><li>分解数据<ul><li>在处理功能逐步分解的同时，其所用的数据也逐级分解，形成若干层次的数据流图。数据流图表达了数据和处理过程的关系。</li><li>分解后的数据，用<strong>数据字典</strong>来描述</li></ul></li></ul><p>最后，将分析结果再次提交给用户，征得用户的认可。整个过程如下图所示：</p> <img src="/posts/90c77d0c/17.png"><p>例如，我们要开发一个学校管理系统。</p><ul><li>经过可行性分析和初步需求调查，抽象出该系统最高层数据流图，该系统由教师管理子系统、学生管理子系统、后勤管理子系统组成，每个子系统分别配备一个开发小组。</li><li>进一步细化各个子系统。其中学生管理子系统开发小组通过进行进一步的需求调查，明确了该子系统的主要功能是进行学籍管理和课程管理，包括学生报到、入学、毕业的管理，学生上课情况的管理。通过详细的信息流程分析和数据收集后，他们生成了该子系统的数据流图。</li></ul><h3 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h3><p>数据字典的用途<br>数据字典是各类数据描述的集合，是进行详细的数据收集和数据分析所获得的主要结果。数据字典在数据库设计中占有很重要的地位。</p><p>数据字典通常包括：</p><ul><li>数据项</li><li>数据结构</li><li>数据流</li><li>数据存储</li><li>处理过程</li></ul><p>其中，数据项是数据的最小组成单位，若干个数据项可以组成一个数据结构。<br>数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容。<br>下面，我们用学生学籍管理子系统的数据字典 进行说明</p><h4 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h4><p>数据项是不可再分的数据单位。</p><pre><code>数据项描述＝｛ 数据项名，数据项含义说明，别名,
              数据类型，长度，取值范围，取值含义,
               与其他数据项的逻辑关系｝
</code></pre><p>其中，取值范围、与其他数据项的逻辑关系定义了数据的完整性约束条件.</p><p>以“学号”为例：</p><pre><code>数据项：　学号
含义说明：唯一标识每个学生
别名：　　学生编号
类型：　　字符型
长度：　　 8
取值范围：00000000至99999999
取值含义：前2位标明该学生所在年级，后面4位标明院系和班级，后2位按顺序编号
与其他数据项的逻辑关系：…… 
</code></pre><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>数据结构反映了数据之间的组合关系。</p><p>一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。</p><pre><code>数据结构描述＝｛ 数据结构名，含义说明，
             组成:｛数据项或数据结构｝｝ 
</code></pre><p>以“学生”为例：</p><pre><code>数据结构：　学生
含义说明：　是学籍管理子系统的主体数据结构，定义了一个学生的有关信息
组成：　　　学号，姓名，性别，年龄，所在系，年级 
</code></pre><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>数据流是数据结构在系统内传输的路径。</p><pre><code>数据流描述＝｛ 数据流名，说明，数据流来源，
             数据流去向，组成:｛数据结构｝，
                平均流量，高峰期流量 ｝
</code></pre><p>其中，数据流来源是说明该数据流来自哪个过程；数据流去向是说明该数据流将到哪个过程去；平均流量是指在单位时间（每天、每周、每月等）里的传输次数；高峰期流量则是指在高峰时期的数据流量。</p><p>以“体检结果”为例：</p><pre><code>数据流：　　体检结果
说明：　学生参加体格检查的最终结果
数据流来源：体检
数据流去向：审批
组成：　　　……
平均流量：　……
高峰期流量：…… 
</code></pre><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p>数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一。</p><pre><code>数据存储描述＝{ 数据存储名，说明，编号，
              流入的数据流，流出的数据流，
               组成:｛数据结构｝，数据量，存取方式｝  
</code></pre><p>其中，流入的数据流指出数据来源；流出的数据流指出数据去向；数据量是指每次存取多少数据，每天（或每小时、每周等）存取几次等信息；存取方法包括：批处理 / 联机处理、检索 / 更新、顺序检索 / 随机检索等。</p><p>以“学生登记表 ”为例：</p><pre><code>数据存储：　学生登记表
说明：　　　记录学生的基本情况
流入数据流：入学登记
流出数据流：查询信息
组成：　　　……
数据量：　　每年3000张
存取方式：　随机存取 
</code></pre><h4 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h4><p>处理过程的具体处理逻辑一般用判定表或判定树来描述。数据字典中只需要描述处理过程的说明性信息。</p><pre><code>处理过程描述＝｛ 处理过程名，说明，输入:｛数据流｝，
               输出:｛数据流｝，处理:｛简要说明｝｝
</code></pre><p>简要说明主要说明该处理过程的功能及处理要求：<br>功能是指该处理过程用来做什么；<br>处理要求是指处理频度要求（如单位时间里处理多少事务，多少数据量）、响应时间要求等。<br>处理要求是后面物理设计的输入及性能评价的标准。</p><p>以“分配宿舍 ”为例：</p><pre><code>处理过程：分配宿舍
说明：　　为所有新生分配学生宿舍
输入：　　学生，宿舍
输出：　　宿舍安排
处理：　　在新生报到后，为所有新生分配学生宿舍。要求同一间宿舍只能安排同一性别的学生，同一个学生只能安排在一个宿舍中。每个学生的居住面积不小于3平方米。安排新生宿舍其处理时间应不超过15分钟。……
</code></pre><p>可见，数据字典是关于数据库中数据的描述，即元数据，而不是数据本身。<br>数据字典是在需求分析阶段建立，在数据库设计过程中不断修改，充实，完善的。</p><hr><h2 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h2><h3 id="概念结构"><a href="#概念结构" class="headerlink" title="概念结构"></a>概念结构</h3><ul><li>需求分析阶段描述的用户应用需求是现实世界的具体需求，将需求分析得到的用户需求抽象为信息结构即概念模型的过程就是概念结构设计。</li><li>概念结构是各种数据模型的共同基础，它比数据模型更独立于机器、更抽象，从而更加稳定。</li><li>概念结构设计是整个数据库设计的关键。</li></ul><p>概念结构设计的特点：</p><ul><li>能真实、充分地反映现实世界，包括事物和事物之间的联系，能满足用户对数据的处理要求。是对现实世界的一个真实模型。</li><li>易于理解，从而可以用它和不熟悉计算机的用户交换意见，用户的积极参与是数据库的设计成功的关键。</li><li>易于更改，当应用环境和应用要求改变时，容易对概念模型修改和扩充。</li><li>易于向关系、网状、层次等各种数据模型转换。</li></ul><p>描述概念模型的工具<br>E-R模型</p><h3 id="概念结构设计的方法与步骤"><a href="#概念结构设计的方法与步骤" class="headerlink" title="概念结构设计的方法与步骤"></a>概念结构设计的方法与步骤</h3><p>设计概念结构的四类方法</p><ol><li>自顶向下<br>首先定义全局概念结构的框架，然后逐步细化。</li></ol> <img src="/posts/90c77d0c/19.png"><ol start="2"><li>自底向上<br>首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构 。</li></ol> <img src="/posts/90c77d0c/20.png"><ol start="3"><li>逐步扩张<br>首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构。</li></ol> <img src="/posts/90c77d0c/21.png"><ol start="4"><li>混合策略<br>将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构 。</li></ol><p>常用策略:</p><ul><li>自顶向下地进行<strong>需求分析</strong></li><li>自底向上地设计<strong>概念结构</strong></li></ul> <img src="/posts/90c77d0c/22.png"><p>这里只介绍自底向上设计概念结构的方法。它通常分为两步：第1步是抽象数据并设计局部视图，第2步是集成局部视图，得到全局的概念结构，如下图所示。</p> <img src="/posts/90c77d0c/23.png"><p>其中DD是数据字典，DFD是数据流</p><hr><h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><p>概念结构是对现实世界的一种抽象。从实际的人、物、事和概念中抽取所关心的共同特性，忽略非本质的细节。把这些特性用各种概念精确地加以描述，这些概念组成了某种模型。</p><h4 id="三种常用抽象包括"><a href="#三种常用抽象包括" class="headerlink" title="三种常用抽象包括"></a>三种常用抽象包括</h4><ol><li>分类（Classification）<ul><li>定义某一类概念作为现实世界中一组对象的类型，这些对象具有某些共同的特性和行为，它抽象了对象值和型之间的“is member of”的语义。</li><li>在E-R模型中，实体型就是这种抽象。</li><li>例如： 哪些人构成“学生”，哪些人构成“教师” 。</li></ul></li></ol> <img src="/posts/90c77d0c/24.png"><ol start="2"><li>聚集（Aggregation）<ul><li>定义某一类型的组成成分，它抽象了对象内部类型和成分之间“is part of”的语义。</li><li>在E-R模型中若干属性的聚集组成了实体型，就是这种抽象。</li><li>例如：“学生”由学号、姓名、性别、班级等属性构成。</li></ul></li></ol> <img src="/posts/90c77d0c/25.png"><ol start="3"><li>概括（Generalization）<ul><li>定义类型之间的一种子集联系，它抽象了类型之间的“is subset of”的语义。</li><li>概括有一个很重要的性质：继承性。子类继承超类上定义的所有抽象。</li><li>例如：本科生和研究生是学生的子类，学生是它们的父类。</li></ul></li></ol><p>原本的E-R图不具有概括，然后对E-R模型作了扩充，允许定义超类实体和子类实体。并用双竖边的矩形框表示子类，用直线加小圈圈表示超类—子类的联系，如下图所示</p> <img src="/posts/90c77d0c/26.png"><p>概括有一个很重要的性质：继承性。子类继续超类上定义的所有抽象。这样，本科生和研究生集成了学生类型的属性，子类也可以增加自己的某些特殊属性。</p><hr><h4 id="局部E-R模型设计"><a href="#局部E-R模型设计" class="headerlink" title="局部E-R模型设计"></a>局部E-R模型设计</h4><p>数据抽象是概念设计的第一步，其用途是：<br>对需求分析阶段收集到的数据进行分类、组织（聚集），形成实体、实体的属性，标识实体的码，并确定实体之间的联系类型（1:1，1:n，m:n），设计局部E-R模型。</p><p>E-R方法：</p><ul><li>“实体-联系方法”（Entity-Relationship Approach）的简称。它是描述现实世界概念结构模型的有效方法。</li><li>用E-R方法建立的概念结构模型称为E-R模型，或称为E-R图。</li><li>实体型：用矩形框表示，框内标注实体名称。</li><li>属性：用椭圆形框表示，框内标注属性名称。</li><li>联系：指实体之间的联系，有一对一（1：1），一对多（1：n）或多对多（m ：n）三种联系类型。<br>例如系主任领导系，学生属于某一系，学生选修课程，工人生产产品，这里“领导”、“属于”、“选修”、“生产”表示实体间的联系，可以作为联系名称。联系用菱形框表示，框内标注联系名称。</li></ul> <img src="/posts/90c77d0c/38.png"><p>现实世界的复杂性导致实体联系的复杂性。表现在E-R图上可以归结为下图所示的几种基本形式：</p><ol><li>两个实体之间的联系</li></ol> <img src="/posts/90c77d0c/39.png"><ol start="2"><li>两个以上实体间的联系</li></ol> <img src="/posts/90c77d0c/40.png"><ol start="3"><li>同一实体集内部各实体之间的联系</li></ol> <img src="/posts/90c77d0c/41.png"><p>需要注意的是，因为联系本身也是一种实体型，所以联系也可以有属性。如果一个联系具有属性，则这些联系也要用无向边与该联系连接起来。<br>例如，如下图所示，学生选修的课程有相应的成绩。这里的“成绩”既不是学生的属性，也不是课程的属性，只能是学生选修课程的联系的属性。</p> <img src="/posts/90c77d0c/42.png"><p>设计分E-R图具体做法</p><p>① 选择局部应用<br>在多层的数据流图中选择一个适当层次的数据流图，作为设计分E-R图的出发点。让这组图中每一部分对应一个局部应用。</p><p>由于高层的数据流图只能反映系统的概貌，而中层的数据流图能较好地反映系统中各局部应用的子系统组成，因此人们往往以中层数据流图作为设计分E-R图的依据（如图所示）。</p> <img src="/posts/90c77d0c/27.png"><p>②逐一设计分E-R图</p><p>选择好局部应用之后，就要对每个局部应用逐一设计分E-R图，亦称局部E-R图。</p><p>③ 实体与属性之间并没有形式上可以截然划分的界限，但可以给出两条准则：<br>（1）作为“属性”，不能再具有需要描述的性质。“属性”必须是不可分的数据项，不能包含其他属性。<br>（2）“属性”不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系。<br>凡满足上述两条准则的事物，一般均可作为属性对待。</p> <img src="/posts/90c77d0c/43.png"><p>④例子<br>例如1：职工是一个实体，职工号、姓名、年龄是职工的属性，职称如果没有与工资、福利挂钩，换句话说，没有需要进一步描述的特性，则根据准则（1）可以作为职工实体的属性。但如果不同的职称有不同的工资、住房标准和不同的附加福利，则职称作为一个实体看待就更恰当，如下图所示。</p> <img src="/posts/90c77d0c/28.png"><p>例如2在医院中，一个病人只能住在一个病房，病房号可以作为病人实体的一个属性。但如果病房还要与医生实体发生联系，即一个医生负责几个病房的病人的医疗工作，则病房根据准则（2）应作为一个实体，如图所示。</p> <img src="/posts/90c77d0c/29.png"><p>例如3如果一种货物只存放在一个仓库，那么就可以把存放货物的仓库号作为描述货物存放地点的属性。但如果一种货物可以存放在多个仓库中，或者仓库本身又用面积作为属性，或者与职工发生管理上的联系，那么就应把仓库作为一个实体，如下图所示。</p> <img src="/posts/90c77d0c/30.png"><p><strong>实例</strong> 销售管理子系统分E-R图的设计。</p><p>子系统的主要功能是：处理顾客和销售员送来的订单（接订单）</p><p>根据订货安排生产的（处理订单）</p><p>交出货物同时开出发票（开发票）</p><p>收到顾客付款后,根据发票存根和信贷情况进行应收款处理</p><p>得到了该子系统二层数据流图（共5张）和数据字典，其中包括14个数据结构和29个数据流。</p> <img src="/posts/90c77d0c/31.png"><p>图7.18是第一层数据流图。虚线部分划出了系统边界。图中把系统功能又分为四个子系统。图7.19至图7.22是第二层数据流图。</p> <img src="/posts/90c77d0c/32.png"> <img src="/posts/90c77d0c/33.png"> <img src="/posts/90c77d0c/34.png"> <img src="/posts/90c77d0c/35.png"><p>设计该分E-R图的草图（如图7.23所示）。</p> <img src="/posts/90c77d0c/36.png"><p>然后参照第二层数据流图和数据字典中的详尽描述，遵循前面给出的两个准则，进行了如下调整：</p><p>（1）每张订单由订单号、若干头信息和订单细节组成。订单细节又有订货的零件号、数量等来描述。按照准则（2），订单细节就不能作订单的属性处理而应该上升为实体。一张订单可以订若干产品，所以订单与订单细节两个实体之间是1：n的联系。</p><p>（2）原订单和产品的联系实际上是订单细节和产品的联系。每条订货细节对应一个产品描述，订单处理时从中获得当前单价、产品重要等信息。</p><p>（3）图7.21中“发票清单”是一个数据存储，是否应作为实体加入分E-R图呢？答案是不必。这里的数据存储对应手工凭证，发票上的信息在开具发票的同时已及时存入应收账款中了。</p><p>（4）工厂对大宗订货给予优惠。每种产品都规定了不同订货数量的折扣，应增加一个“折扣规则”实体存放这些信息，而不应把它们放在产品描述实体中。</p><p>最后得到分E-R图如图7.24所示。</p> <img src="/posts/90c77d0c/37.png"><p>对每个实体定义的属性如下：</p><pre><code>顾客：{&lt;u&gt;顾客号&lt;/u&gt;，顾客名，地址，电话，信贷状况，账目余额
订单：{&lt;u&gt;订单号&lt;/u&gt;，顾客号，订货项数，订货日期，交货日期，工种号，生产地点}
订单细则：{&lt;u&gt;订单号，细则号&lt;/u&gt;，零件号，订货数，金额}
应收账款：{&lt;u&gt;顾客号，订单号&lt;/u&gt;，发票号，应收金额，支付日期，支付金额，当前余额，货款限额}
产品描述：{&lt;u&gt;产品号&lt;/u&gt;，产品名，单价，重量}
折扣规则：{&lt;u&gt;产品号&lt;/u&gt;，订货量，折扣}
</code></pre><hr><h4 id="视图的集成"><a href="#视图的集成" class="headerlink" title="视图的集成"></a>视图的集成</h4><p>各子系统的分E-R图设计好以后，下一步就是要将所有的分E-R图综合成一个系统的总E-R图。</p><ol><li>有两种方式：</li></ol><p>多个分E-R图一次集成，如图所示。</p> <img src="/posts/90c77d0c/44.png"><p>逐步集成，用累加的方式一次集成两个分E-R图，如图所示。</p> <img src="/posts/90c77d0c/45.png"><p>第一种方式比较复杂，做起来难度较大。</p><p>第二种方式每次只集成两个分E-R图，可以降低复杂度。</p><ol start="2"><li>每次集成局部E-R图时都需要分两步走。</li></ol><p>（1）合并。解决各分E-R图之间的冲突，将各分E-R图合并起来生成初步E-R图。</p><p>（2）修改和重构。消除不必要的冗余，生成基本E-R图。</p><p>一、合并分E-R图，生成初步E-R图</p><p>合理消除各分E-R图的冲突是合并分E-R图的主要工作与关键所在。</p><p>各分E-R图之间的冲突主要有三类：属性冲突、命名冲突和结构冲突。</p><ol><li><p>属性冲突</p><ul><li><p>属性值域冲突即属性值的类型、取值范围或取值集合不同。比如学号，有些部门将其定义为数值型，而有些部门将其定义为字符型。又如年龄，有的可能用出生年月表示，有的则用整数表示。</p></li><li><p>属性取值单位冲突。<br>比如零件的重量，有的以公斤为单位，有的以斤为单位，有的则以克为单位。</p></li></ul></li></ol><p>属性冲突属于用户业务上的约定，必须与用户协商后解决。</p><ol start="2"><li><p>命名冲突<br>命名不一致可能发生在实体名、属性名或联系名之间，其中属性的命名冲突更为常见。一般表现为同名异义或异名同义（实体、属性、联系名）。</p><ul><li><p>同名异义<br>即同一名字的对象在不同的部门中具有不同的意义。<br>比如，“单位”在某些部门表示为人员所在的部门，而在某些部门可能表示物品的重量、长度等属性。</p></li><li><p>异名同义（一义多名），即同一意义的对象在不同的部门中具有不同的名称。<br>比如，有的部门把教科书称为“课本“，有的部门则把教科书称为”教材“。</p></li><li><p>命名冲突可能发生在属性级、实体级、联系级上。其中属性的命名冲突更为常见。</p></li><li><p>命名冲突的解决方法同属性冲突，需要与各部门协商、讨论后加以解决。</p></li></ul></li></ol><ol start="3"><li><p>结构冲突</p><ul><li>同一对象在不同应用中有不同的抽象，可能为实体，也可能为属性。例如，“系别”在某一局部应用中被当作实体，而在另一局部应用中则被当作属性。这类冲突在解决时，就是使同一对象在不同应用中具有相同的抽象，或把实体转换为属性，或把属性转换为实体。</li><li>同一实体在不同应用中属性组成不同，或者是属性次序不同。原因：不同的局部应用关心的是该实体的不同侧面。<br>解决办法是：合并后实体的属性组成为各局部E-R图中的同名实体属性的并集，然后再适当调整属性的次序。</li><li>同一联系在不同应用中呈现不同的类型。<br>例如，E1与E2在某一应用中可能是一对一联系，而在另一应用中可能是一对多或多对多联系，也可能是在E1、E2、E3三者之间有联系。<br>这种情况应该根据应用的语义对实体联系的类型进行综合或调整。</li></ul></li></ol><p>下面以教务管理系统中的两个局部E-R图为例，来说明如何消除各局部E-R图之间的冲突，进行局部E-R模型的合并，从而生成初步E-R图。<br>首先，这两个局部E-R图中存在着命名冲突，学生选课局部E-R图中的实体“系”与教师任课局部E-R图中的实体“单位”，都是指“系”，即所谓的异名同义，合并后统一改为“系”，这样属性“名称”和“单位”即可统一为“系名”。<br>其次，还存在着结构冲突，实体“系”和实体“课程” 在两个不同应用中的属性组成不同，合并后这两个实体的属性组成为原来局部E-R图中的同名实体属性的并集。解决上述冲突后，合并两个局部E-R图，生成如图所示的初步的全局E-R图。</p> <img src="/posts/90c77d0c/46.png"><p>修改与重构，消除不必要的冗余，生成基本E-R图</p><ul><li>所谓冗余，在这里指冗余的数据和实体之间冗余的联系。<ul><li>冗余的数据是指可由基本的数据导出的数据；</li><li>冗余的联系是由其他的联系导出的联系。</li></ul></li><li>在上面消除冲突合并后得到的初步E-R图中，可能存在冗余的数据或冗余的联系。冗余的存在容易破坏数据库的完整性，给数据库的维护增加困难，应该消除。我们把消除了冗余的初步E-R图称为基本E-R图。</li><li>通常采用分析的方法消除冗余。数据字典是分析冗余数据的依据，还可以通过数据流图分析出冗余的联系。</li></ul><p>例如，在上图所示的初步E-R图中</p><ul><li>“课程”实体中的属性“教师号”可由“讲授”这个教师与课程之间的联系导出，而学生的平均成绩可由“选修”联系中的属性“成绩”中计算出来，所以“课程”实体中的 “教师号” 与“学生”实体中的“平均成绩”均属于冗余数据。</li><li>最终得到的基本E-R模型是企业的概念模型，它代表了用户的数据要求，是沟通“要求”和“设计”的桥梁。它决定数据库的总体逻辑结构，是成功建立数据库的关键。如果设计不好，就不能充分发挥数据库的功能，无法满足用户的处理要求。</li><li>因此，用户和数据库人员必须对这一模型反复讨论，在用户确认这一模型已正确无误的反映了他们的要求后，才能进入下一阶段的设计工作。</li></ul><h3 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h3><p>数据库逻辑设计的任务是将概念结构转换成特定DBMS所支持的数据模型的过程。从此开始便进入了“实现设计”阶段，需要考虑到具体的DBMS的性能、具体的数据模型特点。<br>从E-R图所表示的概念模型可以转换成任何一种具体的DBMS所支持的数据模型，如网状模型、层次模型和关系模型。<br>这里只讨论关系数据库的逻辑设计问题，所以只介绍E-R图如何向关系模型进行转换。</p><p>逻辑结构设计的步骤包括：</p><ul><li>将概念结构转化为一般的关系、网状、层次模型；</li><li>将转化来的关系、网状、层次模型向特定DBMS支持下的数据模型转换</li><li>对数据模型进行优化</li></ul><p>转换内容</p><ul><li>E-R图由实体、实体的属性和实体之间的联系三个要素组成，关系模型的逻辑结构是一组关系模式的集合。</li><li>将E-R图转换为关系模型，也就是将实体、实体的属性和实体之间的联系转化为关系模式。</li></ul><p>一、转换原则</p><ol><li>一个实体型转换为一个关系模式<ul><li>实体型的属性就是关系的属性</li><li>实体型的码就是关系的码<br>例如，学生实体可以转换为如下关系模式：学生（学号，姓名，性别、出生日期，所在系，年级，平均成绩）<br>宿舍、班级、档案材料、教师、课程、教室、教科书都可以分别转换为一个关系模式。</li></ul></li></ol><ol start="2"><li><p>一个m:n联系转换为一个关系模式</p><ul><li>关系的属性：与该联系相连的各实体的码以及联系本身的属性</li><li>关系的码：各实体码的组合<br>例如，“选修”联系是一个m:n联系，可以将它转换为如下关系模式，其中学号与课程号为关系的组合码：<br>选修（学号，课程号，成绩）</li></ul></li><li><p>一个1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并</p><ul><li><p>转换为一个独立的关系模式<br>关系的属性：与该联系相连的各实体的码以及联系本身的属性<br>关系的码：n端实体的码<br>例如，“系“和“教师”是1:n的联系，建立一个关系，记录教师和所在的系，以教师作为码。</p></li><li><p>与n端对应的关系模式合并<br>合并后关系的属性：在n端关系中加入1端关系的码和联系本身的属性<br>合并后关系的码：不变。<br>例如，“系“和“教师”是1:n的联系，在“教师“关系中加入”系“作为属性。<br>这种可以减少系统中的关系个数，一般情况下更倾向于采用这种方法。</p></li></ul></li><li><p>一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并</p><ul><li><p>转换为一个独立的关系模式<br>关系的属性：与该联系相连的各实体的码以及联系本身的属性<br>关系的候选码：每个实体的码均是该关系的候选码<br>例如，“班长”和“班级”是1:1的联系，可以建立一个关系，记录班长和所在班级，这两个属性都可以作为该关系的候选码。</p></li><li><p>与某一端对应的关系模式合并<br>合并后关系的属性：加入对应关系的码和联系本身的属性<br>合并后关系的码：不变<br>例如，“班长”和“班级”是1:1的联系，可以在“班长“关系中增加班级属性，也可以在”班级“关系中加入班长属性。</p><p>从理论上讲，1:1联系可以与任意一端对应的关系模式合并。<br>但在一些情况下，与不同的关系模式合并效率会大不一样。因此究竟应该与哪端的关系模式合并需要依应用的具体情况而定。<br>由于连接操作是最费时的操作，所以一般应以尽量减少连接操作为目标。<br>例如，如果经常要查询某个班级的班长信息，那么将“班级“属性合并到“班长“关系中会更好些。</p></li></ul></li><li><p>三个或三个以上实体间的一个多元联系转换为一个关系模式</p><ul><li>关系的属性：与该多元联系相连的各实体的码以及联系本身的属性</li><li>关系的码：各实体码的组合<br>例如，“授课”联系是一个三元联系，可以将它转换为如下关系模式，其中课程号、教师号和教材号为关系的组合码：　　授课（课程号，教师号，教材号）</li></ul></li></ol><ol start="6"><li>同一实体集的实体间的联系，即自联系，也可按上述1:1、1:n和m:n三种情况分别处理<br>例如，如果教师实体集内部存在领导与被领导的1:n自联系，我们可以将该联系与教师实体合并，这时主码教师号将多次出现，但作用不同，可用不同的属性名加以区分：教师：｛教师号，姓名，性别，职称，系主任｝</li></ol><ol start="7"><li>同一具有相同码的关系模式可合并<ul><li>目的：减少系统中的关系个数。</li><li>合并方法：将其中一个关系模式的全部属性加入到另一个关系模式中，然后去掉其中的同义属性（可能同名也可能不同名），并适当调整属性的次序。<br>例如，某关系模式记录了学生的身份证号：<br>　 身份证（学号，身份证号）<pre><code>  可以与学生关系模式合并为：
学生（学号，姓名，出生日期，身份证号，……） 
</code></pre></li></ul></li></ol><p>向特定DBMS规定的模型进行转换</p><ul><li>一般的数据模型还需要向特定DBMS规定的模型进行转换。</li><li>转换的主要依据是所选用的DBMS的功能及限制。没有通用规则。</li><li>对于关系模型来说，这种转换通常都比较简单。</li></ul><p>二、数据模型的优化</p><ul><li>数据库逻辑设计的结果不是唯一的。</li><li>得到初步数据模型后，还应该适当地修改、调整数据模型的结构，以进一步提高数据库应用系统的性能，这就是数据模型的优化。</li><li>关系数据模型的优化通常以规范化理论为指导。</li></ul><p>三、关系模式规范化</p><ul><li>应用规范化理论对上述产生的关系的逻辑模式进行初步优化，以减少乃至消除关系模式中存在的各种异常，改善完整性、一致性和存储效率。</li><li>规范化理论是数据库逻辑设计的指南和工具，规范化过程可分为两个步骤：<ol><li>确定规范式级别<br>考查关系模式的函数依赖关系，确定范式等级，逐一分析各关系模式，考查是否存在部分函数依赖，传递函数依赖等，确定它们分别属于第几范式。</li><li>实施规范化处理<br>确定范式级别后，利用第4章的规范化理论，逐一考察各个关系模式，根据应用要求，判断它们是否满足规范要求，可用已经介绍过的规范化方法和理论将关系模式规范化。</li></ol></li></ul><p>综合以上数据库的设计过程，规范化理论在数据库设计中有如下几方面的应用：</p><ul><li>在需求分析阶段，用数据依赖概念分析和表示各个数据项之间的联系。</li><li>在概念结构设计阶段，以规范化理论为指导，确定关系键，消除初步E-R图中冗余的联系。</li><li>在逻辑结构设计阶段，从E-R图向数据模型转换过程中，用模式合并与分解方法达到规范化级别。</li></ul><p>四、模式评价与改进<br>关系模式的规范化不是目的而是手段，数据库设计的目的是最终满足应用需求。因此，为了进一步提高数据库应用系统的性能，还应该对规范化后产生的关系模式进行评价、改进，经过反复多次的尝试和比较，最后得到优化的关系模式。</p><p>模式评价：</p><ul><li>目的是检查所设计的数据库模式是否满足用户的功能要求、效率，确定加以改进的部分。</li><li>模式评价包括：<ul><li>功能评价</li><li>性能评价</li></ul></li></ul><ol><li><p>功能评价</p><ul><li>功能评价指对照需求分析的结果，检查规范化后的关系模式集合是否支持用户所有的应用要求。</li><li>关系模式必须包括用户可能访问的所有属性。在涉及多个关系模式的应用中，应确保联接后不丢失信息。如果发现有的应用不被支持，或不完全被支持，则应该改进关系模式。</li><li>发生这种问题的原因可能是在逻辑设计阶段，也可能是在需求分析或概念设计阶段。是哪个阶段的问题就返回到哪个阶段去，因此有可能对前两个阶段再进行评审，解决存在的问题。</li></ul></li><li><p>性能评价</p></li></ol><ul><li>对于目前得到的数据库模式，由于缺乏物理设计所提供的数量测量标准和相应的评价手段，所以性能评价是比较困难的，只能对实际性能进行估计，包括逻辑记录的存取数、传送量以及物理设计算法的模型等。</li></ul><p>模式改进</p><ul><li>根据模式评价的结果，对已生成的模式进行改进。</li><li>如果因为需求分析、概念设计的疏漏导致某些应用不能得到支持，则应该增加新的关系模式或属性。</li><li>如果因为性能考虑而要求改进，则可采用合并或分解的方法。</li></ul><ol><li><p>合并</p><ul><li>如果有若干个关系模式具有相同的主键，并且对这些关系模式的处理主要是查询操作，而且经常是多关系的查询，那么可对这些关系模式按照组合使用频率进行合并。</li><li>这样便可以减少联接操作而提高查询效率。</li></ul></li><li><p>分解</p><ul><li>为了提高数据操作的效率和存储空间的利用率，最常用和最重要的模式优化方法就是分解。</li><li><p>根据应用的不同要求，可以对关系模式进行垂直分解和水平分解。<br>①水平分解</p><ul><li>是把关系的元组分为若干子集合，定义每个子集合为一个子关系</li><li>对于经常进行大量数据的分类条件查询的关系，可进行水平分解，这样可以减少应用系统每次查询需要访问的记录数，从而提高了查询性能。</li><li><p>例如，有学生关系（学号，姓名，类别……），其中类别包括大专生、本科生和研究生。如果多数查询一次只涉及其中的一类学生，就应该把整个学生关系水平分割为大专生、本科生和研究生三个关系。</p><p>②垂直分解</p></li><li>把关系模式的属性分解为若干子集合，形成若干子关系模式。垂直分解的原则是把经常一起使用的属性分解出来，形成一个子关系模式 。</li><li>垂直分解可以提高某些事务的效率，但也有可能使另一些事务不得不执行连接操作，从而降低了效率。因此是否要进行垂直分解要看分解后的所有事务的总效率是否得到了提高。垂直分解要保证分解后的关系具有无损连接性和函数依赖保持性。</li><li>例如，有教师关系（教师号，姓名，性别，年龄，职称，工资，岗位津贴，住址，电话），如果经常查询的仅是前六项，而后三项很少使用，则可以将教师关系进行垂直分割，得到两个教师关系：<br>教师关系1（教师号，姓名，性别，年龄，职称，工资）<br>教师关系2（教师号，岗位津贴，住址，电话）<br>这样，便减少了查询的数据传递量，提高了查询速度。</li></ul></li></ul></li></ol><p>经过多次的模式评价和模式改进之后，最终的数据库模式得以确定。逻辑设计阶段的结果是全局逻辑数据库结构。对于关系数据库系统来说，就是一组符合一定规范的关系模式组成的关系数据库模型。<br>数据库系统的数据物理独立性特点消除了由于物理存储改变而引起的对应程序的修改。标准的DBMS例行程序应适用于所有的访问，查询和更新事务的优化应当在系统软件一级上实现。这样，逻辑数据库确定之后，就可以开始进行应用程序设计了。</p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>Just for fun!</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Qsx 微信支付"><p>微信支付</p></div></div></div></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------<i class="fa fa-paw"></i> 文章已经到尾<i class="fa fa-paw"></i> -------------</div></div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/学习/" rel="tag"># 学习</a> <a href="/tags/数据库/" rel="tag"># 数据库</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/a6386957.html" rel="next" title="数据库学习基础篇②"><i class="fa fa-chevron-left"></i> 数据库学习基础篇②</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Qsx"><p class="site-author-name" itemprop="name">Qsx</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">11</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Shelhon" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:ppp00qqq@163.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="http://weibo.com/qsxmybaby" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i> 微博</a></span><span class="links-of-author-item"><a href="https://zhihu.com/people/shelhon" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i> 知乎</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://www.kofes.cn/" title="cz" target="_blank">cz</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#关系数据理论"><span class="nav-number">1.</span> <span class="nav-text">关系数据理论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题的提出"><span class="nav-number">1.1.</span> <span class="nav-text">问题的提出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#规范化"><span class="nav-number">1.2.</span> <span class="nav-text">规范化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数依赖"><span class="nav-number">1.2.1.</span> <span class="nav-text">函数依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#码"><span class="nav-number">1.2.2.</span> <span class="nav-text">码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#范式"><span class="nav-number">1.2.3.</span> <span class="nav-text">范式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#规范化小结"><span class="nav-number">1.2.4.</span> <span class="nav-text">规范化小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据依赖的公理系统"><span class="nav-number">1.3.</span> <span class="nav-text">数据依赖的公理系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模式的分解"><span class="nav-number">1.4.</span> <span class="nav-text">模式的分解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#具有无损连接性的模式分解"><span class="nav-number">1.4.1.</span> <span class="nav-text">具有无损连接性的模式分解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保持函数依赖的模式分解"><span class="nav-number">1.4.2.</span> <span class="nav-text">保持函数依赖的模式分解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式分解小结"><span class="nav-number">1.4.3.</span> <span class="nav-text">模式分解小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">1.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库设计"><span class="nav-number">2.</span> <span class="nav-text">数据库设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库设计概述"><span class="nav-number">2.1.</span> <span class="nav-text">数据库设计概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库设计的特点"><span class="nav-number">2.1.1.</span> <span class="nav-text">数据库设计的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库设计方法"><span class="nav-number">2.1.2.</span> <span class="nav-text">数据库设计方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库设计的基本步骤"><span class="nav-number">2.1.3.</span> <span class="nav-text">数据库设计的基本步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需求分析"><span class="nav-number">2.2.</span> <span class="nav-text">需求分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据字典"><span class="nav-number">2.2.1.</span> <span class="nav-text">数据字典</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据项"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">数据项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据流"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">数据流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据存储"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">数据存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理过程"><span class="nav-number">2.2.1.5.</span> <span class="nav-text">处理过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概念结构设计"><span class="nav-number">2.3.</span> <span class="nav-text">概念结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念结构"><span class="nav-number">2.3.1.</span> <span class="nav-text">概念结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念结构设计的方法与步骤"><span class="nav-number">2.3.2.</span> <span class="nav-text">概念结构设计的方法与步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据抽象"><span class="nav-number">2.3.3.</span> <span class="nav-text">数据抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三种常用抽象包括"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">三种常用抽象包括</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部E-R模型设计"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">局部E-R模型设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#视图的集成"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">视图的集成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑结构设计"><span class="nav-number">2.3.4.</span> <span class="nav-text">逻辑结构设计</span></a></li></ol></li></ol></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Qsx</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">82.3k</span></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span><span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/love.js"></script></body></html>