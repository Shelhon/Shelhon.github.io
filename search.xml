<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库学习基础篇]]></title>
    <url>%2Fposts%2F486c9009.html</url>
    <content type="text"><![CDATA[基础篇内容一、绪论二、关系数据库三、关系数据库标准语言四、数据库安全性五、数据库完整性 绪论数据库系统概述一、基础概念 数据数据是数据库存储的基本对象，有多种表现形式。数据的表现形式还不能完全表达其内容，需要经过解释，数据的解释是指对数据含义的说明，数据的含义成为数据的语义，数据和他的语义是不可区分的。 数据库（database，简称DB）是存放数据的仓库，按照一定的格式存放的。严格来说，数据库是长期存储在计算机内，有组织、可共享的大量数据的集合。数据库中的数据按照一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性、并可为各种用户共享。具有三个基本特点：永久存储、有组织、可共享 数据库管理系统（database management system ，DBMS）DBMS的作用就是科学的组织和存储数据，高效的获取和维护数据。主要功能包括了 数据定义功能：提供数据定义语言来对数据对象进行定义 数据组织、存储和管理： 基本目标是提供存储空间利用率和方便存取，提供多种方法（如索引查找，hash查找、顺序查找等）来提供存取效率 数据操纵功能：通过数据操纵语言对数据库进行基本操作，如查询，插入，删除和修改等。 数据库的事务管理和运行管理：数据库在建立、运用和维护时对数据库管理系统统一管理、控制、以保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。 数据库的建立和维护功能：包括了数据库初始数据的输入，转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。 其他功能：DBMS与网络中其他软件系统的通信功能；一个DBMS与另一个DBMS或文件系统的数据转换功能；异构数据库之间的互访和互操作功能等。 数据库系统（database system，DBS）数据库系统是指计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、应用系统、数据库管理员构成。 二、 数据库系统的特点 数据结构化这是一个主要特征之一。所谓的“整体”结构化是指数据库的数据不再仅仅针对某一个应用，而是面向全组织；不仅数据内部是结构化的，而且整体也是结构化的，数据之间是具有联系的。在数据库系统中，不仅数据是整体结构化，而且存取数据的方式也很灵活，可以存取数据库中的某一个数据项、一组数据项、一个记录或一组记录。 数据的共享性高，冗余度低，易扩充数据是面向整个系统，可以被多个用户多个应用共享使用，数据共享可以大大减少数据冗余，还能避免数据之间的不相容性和不一致性。数据不一致性是指同一数据由于人工管理或者文件系统管理时，重复存储，导致不同拷贝的值不一样。 数据独立性高数据的物理独立性：是指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。即，数据在磁盘上怎样存储由DBMS管理，用户程序不需要了解，应用程序要处理的只是数据的逻辑结构，这样当数据的物理存储改变了，应用程序不用改变。逻辑独立性：是指用户的应用程序与数据库的逻辑结构是相互独立的，即，当数据的逻辑结构改变时，用户程序也可以不变。数据独立性由DBMS的二级映像功能来保证。 数据由DBMS统一管理和控制数据库的共享是并发共享，即多个用户可以同时存取数据库中的数据甚至同时存储同一个数据。所以DBMS还提供以下几个数据控制功能：（1）数据的安全性保护（2）数据的完整性检查（3）并发控制（4）数据库恢复 总结：数据库是长期存储在计算机内有组织的大量的共享的数据集合。它可以提供各种用户共享，具有最小冗余度和较高的数据独立性。 数据模型数据模型是现实世界数据特征的抽象 数据模型应该满足三个方面：比较真实的模拟现实世界；二是容易为人所理解；三是便于在计算机实现。 根据不同的目的，可以把模型划分两类： 概念模型：也称为信息模型，按照用户的观点来对数据和信息建模，主要用于数据库设计 逻辑模型和物理模型：逻辑模型主要包括层次模型，网状模型，关系模型，面向对象模型和对象关系模型等。是按照计算机系统的观点对数据建模。主要用于DBMS的实现。物理模型是对数据最底层的抽象，描述数据在系统内部的表示方法和存取方法，是面向计算机系统的。物理模型的具体实现是DBMS的任务，数据库设计人员要了解和选择物理模型，一般用户则不需要考虑物理级的细节。 数据模型的组成要素一般来说，数据模型是严格定义一组概念的集合，这些概念精确地描述了系统的静态特性，动态特性和完整性约束条件。因此数据模型通常由数据结构，数据操作和完整性约束三部分来组成。 一、 数据结构数据结构描述数据库的组成对象以及对象之间的联系。有两类： 是与对象的类型，内容，性质有关的，例如网状模型中的数据项，记录，关系模型中的域，属性，关系等。 是与数据之间的联系有关的对象，例如网状模型中的系型。 二、 数据操作 数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。 数据库的主要有查询和更新（包括插入，删除、修改）两大类操作。数据模型必须定义这些操作的确切含义，操作符号，操作规则（如优先级）以及实现操作的语言。 数据操作是对系统动态特性的描述。 三、 数据的完整性约束条件 数据的完整性约束条件是一组完整性规则。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态和状态的变化，以保证数据的正确，有效，相容。 数据模型应该反映和规定本数据模型必须遵守的基本的通用的基本的通用的完整性约束条件。 数据模型还应该提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。 概念模型概念模型一方面应该具有较强的语义表达能力，能够方便、直接的表达应用中的各种语义知识、另一方面应该简单，清晰，易于用户理解。 基本概念（1） 实体：客观存在并可相互区别的事物成为实体。可以是具体的人事物，也可以是抽象的概念或者联系，比如老师和学校的工作关系。 （2）属性：实体所具有的某一特性称为属性。一个实体可以由若干的属性来刻画，比如学生这个实体可以由学号姓名性别出生年月等信息组成。 （3）码:唯一标识实体的属性集称为码。比如学号是学生实体的码。 （4）域：属性的取值范围称为该属性的域，比如学号的域为8位整数，姓名的域为字符串集合，学生年龄的域为整数，性别的域为（男，女） （5）实体型：具有相同属性的实体必然具有共同的特征和性质。用实体名以及属性名称集合来抽象和刻画同类实体，称为实体型。比如学生（学号，姓名，性别，出生年月，所在院系，入学时间）就是一个实体型。 （6）实体集：同一类型实体的集合称为实体集，例如全体学生就是一个实体集 （7）联系：实体内部的联系通常是指组成实体的各属性之间的联系；实体之间的联系通常是指不同的实体集之间的联系。 实体型之间的联系一、两个实体型的联系分为三种： 一对一联系（1：1）如果对于实体集A中每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，则称为一对一联系。比如电影院座位和观众实体之间的联系 一对多联系（1：n）如果对于实体集A中每一个实体，实体集B中有n个实体（n&gt;=0）与之联系，比如部门和员工两个实体集之间的联系。 多对多联系（n:n）表示实体集A中多个实体可与实体集B中多个实体相联系。例如一门课程可以同时有若干学生选修，而一个学生也可以同时选修多门课程，这就是多对多联系。实际上，一对一联系是一对多联系的特例，而一对多联系又是多对多联系的特例。 二、 两个以上的实体型之间的联系 一般来说，两个以上的实体型也存在一对一，一对多，多对多的联系比如 课程，老师，参考书 。一个课程可以由若干个老师讲授，也可以使用若干本参考书，这就是一对多。供应商与项目，零件的联系，一个供应商可以供给多个项目多种零件，而且每个项目可以使用多个供应商供应的零件，每种零件可由不同的供应商攻击。所以是多对多联系。 三、 单个实体型内的联系 同一个实体集内的各实体之间也可以存在一对一，一对多，多对多的联系。比如职工内部也存在领导与被领导的关系，而一个职工仅被另一个职工直接领导，这是一对多的联系 四、概念模型的一种表示方法：实体–联系方法 概念模型的方法挺多，最著名的是实体-联系方法（entity-relationship Approach）。该方法用E-R图来描述现实世界的概念模型，也称为E-R模型 E-R图提供表示实体型、属性和联系的方法： 实体型 ：用矩阵表示，矩形框内写明实体名 属性：用椭圆表示，并用无向边将其相应的实体型连接起来 例如 ：学生实体具有学号、姓名、性别、出生年份、系、入学时间等属性，用E_R图表示如下 联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁边表上联系的类型（1:1,1:n或m:n） 如果联系具有属性，那么这些属性也需要用无向边和该联系连接起来 五、 一个实例 下面用E-R图来表示某个工厂物资管理的概念模型 物资管理设计的实体有： 仓库 —属性有仓库号，面积，电话号码 零件 —属性有零件号，名称，规格，单价，描述 供应商—属性有供应商号，姓名，地址，电话号码，账号 项目 —属性有项目号，预算，开工日期 职工 —属性有职工号，姓名，年龄，职称 这些实体的联系如下：（1）一个仓库可以存放多种零件，一种零件可以存放在多个仓库中，因此仓库和零件具有多对多的联系。用库存量来表示某种零件在某个仓库中的数量（2）一个额仓库有多个职工当仓库保管员，一个职工只能在一个仓库工作，因此仓库和职工之间是一对多的联系。（3）职工之间具有领导和被领导关系，即仓库主任领导若干保管员，因此职工实体型中具有一对多的联系。（4）供应商、项目和零件三者之间具有多对多的联系。即一个供应商可以供给若干项目多种零件，每个项目可以使用不同供应商供应的零件，每种零件可由不同的供应商供给。 最常用的数据模型]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iBatis]]></title>
    <url>%2Fposts%2F115b549a.html</url>
    <content type="text"><![CDATA[iBatis内容包括 iBatis 简介搭建环境配置文件读取配置基本的CRUD操作模糊查询自动主键selectKey优点 iBatis 简介&nbsp; iBATIS一词来源于“internet”和“abatis”的组合，是一个由Clinton Begin在2001年发起的开放源代码项目。于2010年6月16号被谷歌托管，改名为MyBatis。是一个基于SQL映射支持Java和·NET的持久层框架。 &nbsp; Ibatis是开源软件组织Apache推出的一种轻量级的对象关系映射(ORM)框架，和Hibernate、Toplink等在java编程的对象持久化方面深受开发人员欢迎。 &nbsp; 对象关系映射(ORM)：简单原理是通过面向对象方式操作关系型数据库，目前存储数据最常用最流行的工具是关系型数据库，其操作方式是通过 SQL语句操作数据库的表，但是对于Java面向对象编程语言中，所有的操作对象都是对象，因此对象关系映射就是把数据库表和java编程语言中的对象对 应起来，把表的列同java对象中的字段对应起来，程序员在程序开发过程中不再是使用原始SQL语句去直接操作数据库，而是通过ORM提供的查询语句操作 普通的java对象，ORM将其提供的对普通java对象的查询语句翻译成SQL语句来操作数据库，从而屏蔽了不同数据库SQL语句的差别，简化了程序开 发工作，提高了程序的可移植性。 环境搭建导入jar包ibatis-2.3.4.726.jarsqljdbc.jar 配置文件这是总配置文件 SqlMapConfig.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE sqlMapConfig PUBLIC "-//iBATIS.com//DTD SQL Map Config 2.0//EN" "http://www.ibatis.com/dtd/sql-map-config-2.dtd" &gt; &lt;sqlMapConfig&gt;&lt;properties resource="Resources/SqlMap.properties"/&gt;&lt;transactionManager type ="JDBC" &gt; &lt;!-- 定义了ibatis的事务管理器有3中（JDBC,JTA,EXTERNAL） --&gt; &lt;dataSource type ="SIMPLE"&gt; &lt;!-- type属性指定了数据源的链接类型，也有3种类型(SIMPLE,DBCP,JNDI) --&gt; &lt;property name ="JDBC.Driver" value ="$&#123;driver&#125;" /&gt;&lt;property name ="JDBC.ConnectionURL" value ="$&#123;url&#125;" /&gt;&lt;property name ="JDBC.Username" value ="$&#123;username&#125;" /&gt;&lt;property name ="JDBC.Password" value ="$&#123;password&#125;" /&gt;&lt;property name ="Pool.MaximumActiveConnections" value ="10"/&gt; &lt;!-- 连接池维持的最大容量 --&gt;&lt;property name ="Pool.MaximumIdleConnections" value ="5" /&gt; &lt;!-- 连接池允许挂起的最大连接 --&gt;&lt;property name ="Pool.MaximumCheckoutTime" value ="120000" /&gt; &lt;!-- 连接被某个任务所允许占用的最大时间 --&gt; &lt;property name ="TimeToWait" value ="500" /&gt; &lt;!-- 线程允许等待的最大时间 --&gt; &lt;/dataSource &gt;&lt;/transactionManager &gt;&lt;sqlMap resource = "cn/shelhon/Student.xml" /&gt;&lt;/sqlMapConfig &gt; 这是映射文件 student.xml表示实体类的映射文件，它的里面是对实体的一些操作，即增、删、改、查。 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE sqlMap PUBLIC "-//ibatis.apache.org//DTD SQL Map 2.0//EN" "http://ibatis.apache.org/dtd/sql-map-2.dtd"&gt; &lt;sqlMap&gt;&lt;!-- 定义别名,可以在指定类型时不用输入类型全路径 方便开发--&gt;&lt;typeAlias alias="Student" type="cn.shelhon.Student"/&gt;&lt;select id="selectAllStudent" resultClass="Student"&gt;select * from student&lt;/select&gt;&lt;select id="selectAllStudentByID" parameterClass="int" resultClass="Student"&gt;select * from student where sid= #sid# &lt;/select&gt;&lt;/sqlMap&gt; 其中映射文件可以不断修改来增加功能 属性文件 SqlMap.properties 1234driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost/test username=root password=12345 创建实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package cn.shelhon;import java.sql.Date;public class Student &#123; private int sid = 0; private String sname =null; private String major =null; private Date birth= null; private float score = 0; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; public int getSid() &#123; return sid; &#125; public void setSid(int sid) &#123; this.sid = sid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public String getMajor() &#123; return major; &#125; public void setMajor(String major) &#123; this.major = major; &#125; public float getScore() &#123; return score; &#125; public void setScore(float score) &#123; this.score = score; &#125; @Override public String toString() &#123; return "Student&#123;" + "sid=" + sid + ", sname='" + sname + '\'' + ", major='" + major + '\'' + ", birth=" + birth + ", score=" + score + '&#125;'; &#125;&#125; 创建接口类 12345678910111213package cn.shelhon;import java.util.List;public interface IStudentDAO &#123; public void addStudent (Student student); public void addStudentBySequence(Student student); public void deleteStudentByID(int id); public void updateStudent(Student student); public List&lt;Student&gt; queryAllStudent(); public List&lt;Student&gt; queryStudentByName(String name); public Student queryStudentByID(int id);&#125; 然后再创建实现类来实现方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package cn.shelhon;import com.ibatis.sqlmap.client.SqlMapClient;import java.io.IOException;import java.io.Reader;import java.sql.SQLException;import java.util.List;public class IStudentDAOImpl implements IStudentDAO&#123; private static SqlMapClient sqlMapClient= null;//读取配置信息 static &#123; try&#123; Reader reader=com.ibatis.common.resources.Resources.getResourceAsReader("SqlMapConfig.xml"); sqlMapClient = com.ibatis.sqlmap.client.SqlMapClientBuilder.buildSqlMapClient(reader); reader.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; @Override public void addStudent(Student student) &#123; &#125; @Override public void addStudentBySequence(Student student) &#123; &#125; @Override public void deleteStudentByID(int id) &#123; &#125; @Override public void updateStudent(Student student) &#123; &#125;//查询所有信息 @Override public List&lt;Student&gt; queryAllStudent() &#123; List&lt;Student&gt; studentList =null; try &#123; studentList = sqlMapClient.queryForList("selectAllStudent"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return studentList; &#125; @Override public List&lt;Student&gt; queryStudentByName(String name) &#123; return null; &#125;//通过id来查询信息 @Override public Student queryStudentByID(int id) &#123; Student student= null; try &#123; student = (Student) sqlMapClient.queryForObject("selectAllStudentByID",id); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return student; &#125; public static void main(String[] args) &#123; IStudentDAO dao =new IStudentDAOImpl(); /* for(Student student:dao.queryAllStudent())&#123; System.out.println(student); &#125;*/ Student student=dao.queryStudentByID(1); System.out.println(student); &#125;&#125; 查询所有对象 增加查询接口 1public List&lt;Student&gt; queryAllStudent(); 映射文件 123&lt;select id="selectAllStudent" resultClass="Student"&gt;select * from student&lt;/select&gt; 实现接口 1234567891011//查询所有对象 @Override public List&lt;Student&gt; queryAllStudent() &#123; List&lt;Student&gt; studentList =null; try &#123; studentList = sqlMapClient.queryForList("selectAllStudent"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return studentList; &#125; 测试 12345public static void main(String[] args) &#123; IStudentDAO dao =new IStudentDAOImpl(); for(Student student:dao.queryAllStudent())&#123; System.out.println(student); &#125;&#125; 查询指定id的对象 接口 1public void deleteStudentByID(int id); 映射文件 1234&lt;select id="selectAllStudentByID" parameterClass="int" resultClass="Student"&gt;select * from student where sid= #sid# &lt;/select&gt; 方法 1234567891011//通过id来查询信息 @Override public Student queryStudentByID(int id) &#123; Student student= null; try &#123; student = (Student) sqlMapClient.queryForObject("selectAllStudentByID",id); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return student; &#125; 测试 12345public static void main(String[] args) &#123; IStudentDAO dao =new IStudentDAOImpl(); Student student=dao.queryStudentByID(1); System.out.println(student); &#125; 增加对象 接口 1public void addStudent (Student student); 映射文件 1234&lt;insert id="insertStudent" parameterClass="Student"&gt; insert into Student (sid,sname,major,birth,score) values (#sid#,#sname#,#major#,#birth#,#score#);&lt;/insert&gt; 实现类 1234567public void addStudent(Student student) &#123; try &#123; sqlMapClient.insert("insertStudent",student); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 测试 12345678910public static void main(String[] args) &#123; IStudentDAO dao = new IStudentDAOImpl(); Student student = new Student(); student.setSid(3); student.setMajor("体育"); student.setBirth(Date.valueOf("1993-10-11")); student.setSname("qsx"); student.setScore(919); dao.addStudent(student);&#125; 删除指定id的对象 接口 1public void deleteStudentByID(int id); 映射文件 12345&lt;delete id="deleteStudentByID" parameterClass="int"&gt; delete from student where sid =#sid# &lt;/delete&gt; 实现 12345678// 通过id删除对象 public void deleteStudentByID(int id) &#123; try &#123; System.out.println(sqlMapClient.delete("deleteStudentByID",id));//为了验证效果，打印影响了几行 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 测试 12345public static void main(String[] args) &#123; IStudentDAO dao = new IStudentDAOImpl();//测试删除id为13的对象 dao.deleteStudentByID(13);&#125; 注意在映射文件的mysql语句where sid = #sid#后面的 #sid#可以写成 #任意内容#因为这两个#号只是占位符，会自动匹配但是在多个值要输入的时候，就还是按照模板来写，不然还是会报错因为错误的值会导致找不到对应对象里面的get方法 更新修改对象 接口 1public void updateStudent(Student student); 映射文件 1234567&lt;update id="updateStudentByID" parameterClass="Student"&gt; update Student set sname=#sname#, major=#major#, score=#score#, birth=#birth# where sid=#sid# &lt;/update&gt; 特别要注意里面set sname 、major、score、birth之间要加逗号不然又是语法错误 实现 1234567@Override // 修改对象 public void updateStudent(Student student) &#123; try &#123; System.out.println(sqlMapClient.update("updateStudentByID",student)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 测试 12345678910public static void main(String[] args) &#123; IStudentDAO dao = new IStudentDAOImpl(); Student student =new Student(); student.setSid(2); student.setScore(10); student.setSname("shelhon"); student.setBirth(Date.valueOf("1993-12-30")); student.setMajor("科学"); dao.updateStudent(student);&#125; 通过名字模糊查找 接口 1public List&lt;Student&gt; queryStudentByName(String name); 映射文件 12345&lt;select id="selectStudentByName" parameterClass="String" resultClass="Student"&gt; select sid,sname,score,major,birth from Student where sname like '%$sname$%'&lt;/select&gt; 这里要注意最后的符号问题！！！ 1&apos;%$sname$%&apos; 实现 1234567891011@Override //通过名字模糊查询 public List&lt;Student&gt; queryStudentByName(String name) &#123; List&lt;Student&gt; studentList=null; try &#123; studentList=sqlMapClient.queryForList("selectStudentByName",name); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return studentList;&#125; 测试 123456IStudentDAO dao = new IStudentDAOImpl();for(Student student:dao.queryStudentByName("q"))&#123; System.out.println(student);&#125; 通过序列插入对象 接口 1public void addStudentBySequence(Student student); 映射文件 1234567&lt;insert id="addStudentBySequence" parameterClass="Student"&gt;&lt;selectKey resultClass="int" keyProperty="sid"&gt; SELECT @@IDENTITY as sid &lt;/selectKey&gt; insert into Student (sid, sname, major, birth, score) value (#sid#,#sname#,#major#,#birth#,#score#)&lt;/insert&gt; 实现 1234567891011@Override // 增加序列 public void addStudentBySequence(Student student) &#123; try &#123; //1从数据库序列中获取主键值 //2往student表中插入记录 sqlMapClient.insert("addStudentBySequence",student); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 测试 1234567Student student =new Student();student.setSid(2);student.setScore(100);student.setSname("qsx");student.setBirth(Date.valueOf("1993-12-30"));student.setMajor("科学1");dao.addStudentBySequence(student); 由于视频学习的是Oracle的数据库操作，然后我使用的是mysql的,所以在配置上有点不同，但是我个人觉得，MySQL数据库在添加对象的时候，没必要输入id，因为数据库的主键id可以自增，直接不输入id，表生成的时候id就会自己添加进去。效果跟这个通过序列插入对象是一样的。 优缺点优点与JDBC相比： 减少了百分之60的代码量 简单 架构级性能增强 SQL语句和程序代码分离 简化项目中的分工 增强了移植性 缺点： SQL需要自己写 参数数量只能是一个 已经出了第三代Mybatis的版本，ibatis已经落后了]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>iBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2学习(二）]]></title>
    <url>%2Fposts%2F3a01fcdf.html</url>
    <content type="text"><![CDATA[主要内容 struts2值栈struts2拦截器 struts2值栈ognl概述 EL表达式在jsp中获取域对象里面的值 OGNL也是一种表达式，这个表达式功能更加强大（1）在struts2里面操作值栈数据（2）一般把ognl在struts2操作：和struts2标签一起使用操作值栈 OGNL不是struts2的一部分，单独的项目，经常和struts2一起使用（1）使用ognl时候首先导入jar包，struts2提供jar包 OGNL入门案例 使用ognl+struts2标签实现计算字符串长度支持对象方法调用，比如objName.methodName()在Java代码中，调用字符串length() 使用struts2标签 （1）使用jstl时候，导入jar包之外，在jsp页面中引入标签库使用struts2标签时候，在jsp中引入标签库1&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt; （2）使用struts2标签实现操作1&lt;!-- 使用ognl加struts2标签实现计算字符串长度 --&gt; &lt;s:property value="'asdasd'.length()"/&gt; 什么是值栈 之前在web阶段，在servlet里面进行操作，把数据放到域对象里面，在页面中使用el表达式获取到，域对象在一定范围内，存值和取值 在struts2里面提供本身一种存储机制，类似于域对象，是值栈，可以存值和取值（1）在action里面把数据放到值栈里面，在页面中获取到值栈数据 servlet和action区别（1）Servlet：默认在第一次访问时候创建，创建一次，单实例对象（2）Action：访问时候创建，每次访问action时候，都会创建action对象，创建多次，多实例对象 值栈存储位置（1）每次访问action时候，都会创建action对象，（2）在每个action对象里面都会有一个值栈对象（只有一个） 获取值栈对象 获取值栈对象有多种方式（1）常用方式：使用ActionContext类里面的方法得到值栈对象1234567public String execute() throws Exception &#123; //获取ActionContext类对象 ActionContext context =ActionContext.getContext(); //调用方法得到值栈 ValueStack stack1 = context.getValueStack(); return NONE;&#125; 值栈内部结构 值栈分为两部分： 第一部分 root，结构是list集合 一般操作都是root里面数据 第二部分 context，结构map集合 具体看下图 struts2里面标签 s:debug，使用这个标签可以查看值栈结构和存储值（1）访问action，执行action的方法有返回值，配置返回值到jsp页面中，在jsp页面中使用这个标签 12&lt;!--struts2标签查看值栈结构--&gt; &lt;s:debug&gt;&lt;/s:debug&gt; 就会多一个debug按钮来查看信息 action对象里面有值栈对象值栈对象里面有action引用 向值栈放数据向值栈放数据多种方式第一种 获取值栈对象，调用值栈对象里面的 set 方法 12345678public String execute() throws Exception &#123; //第一种方法 获取值栈对象里面的set方法 //获取值栈对象 ActionContext context = ActionContext.getContext(); ValueStack stack = context.getValueStack(); //调用方法set方法 stack.set("username","shelhon"); return "ok"; debug页面就会多一个入栈 java.util.HashMap 第二种 获取值栈对象，调用值栈对象里面的 push方法12//调用方法push方法 stack.push("abdc"); 又多一个入栈 ：java.lang.String 第三种 在action定义变量，生成变量的get方法 123456789private String name;public String getName() &#123; return name;&#125;@Override public String execute() throws Exception &#123; //在执行方法里面向变量来赋值 name ="asdasd"; return "ok";&#125; 这种方法直接在原来的值栈上面写入数据，不需要生成新的值栈来存储，可以节省空间 向值栈放对象 实现步骤 第一步 定义对象变量12//1定义变量 private User user = new User(); 第二步 生成变量的get方法123public User getUser() &#123; return user;&#125; 第三步 在执行的方法里面向对象中设置值1234567public String execute() throws Exception &#123; //3 向值栈的user里面放数据 user.setUsername("luck"); user.setPassword("123"); user.setAddress("gz"); return "ok";&#125; 向值栈放list集合第一步 定义list集合变量1private List&lt;User&gt; list = new ArrayList&lt;User&gt;(); 第二步 生成变量的get方法123public List&lt;User&gt; getList() &#123; return list;&#125; 第三步 在执行的方法里面向list集合设置值123456789101112131415public String execute() throws Exception &#123; User user1= new User(); user1.setUsername("ben"); user1.setAddress("gz"); user1.setPassword("111"); User user2 =new User(); user2.setUsername("jack"); user2.setPassword("009"); user2.setAddress("cd"); list.add(user1); list.add(user2); return "ok";&#125; 从值栈获取数据使用struts2的标签+ognl表达式获取值栈数据&lt;s:property value=”ognl表达式”/&gt; 获取字符串 向值栈放字符串 12345678910111213public class ValueStackAction extends ActionSupport &#123; //定义变量 private String username; public String getUsername()&#123; return username; &#125; @Override public String execute() throws Exception &#123; //给变量赋值 username="shelhon"; return "ok"; &#125;&#125; 在jsp使用struts2标签+ognl表达式获取 1&lt;s:property value="username"/&gt; 获取对象 向值栈放对象 123456789101112131415public void setUser(User user) &#123; this.user = user;&#125;private User user =new User();public User getUser() &#123; return user;&#125;public String execute() throws Exception &#123; user.setUsername("asd"); user.setPassword("222"); user.setAddress("gz"); return "ok"; 在页面中获取值123&lt;s:property value="user.username"/&gt;&lt;s:property value="user.password"/&gt;&lt;s:property value="user.address"/&gt; 获取list集合三种方法一开始先把list放到值栈去1234567891011121314151617private List&lt;User&gt; list = new ArrayList&lt;User&gt;();public List&lt;User&gt; getList() &#123; return list;&#125;@Override public String execute() throws Exception &#123; User user1= new User(); user1.setUsername("qsx"); user1.setAddress("gz"); user1.setPassword("111"); User user2 =new User(); user2.setUsername("jack"); user2.setPassword("009"); user2.setAddress("cd"); list.add(user1); list.add(user2); return "ok"; 第一种 1234567&lt;!-- 第一种方式 --&gt; &lt;s:property value="list[0].username"/&gt;&lt;s:property value="list[0].possword"/&gt;&lt;s:property value="list[0].address"/&gt;&lt;s:property value="list[1].username"/&gt;&lt;s:property value="list[1].possword"/&gt;&lt;s:property value="list[1].address"/&gt; 第二种 1234567&lt;!-- 使用struts2标签，类似jst1的foreach标签 &lt;s:iterator&gt;遍历值栈的list集合--&gt;&lt;s:iterator value="list"&gt;&lt;!-- 遍历list得到list里面每一个user对象 --&gt; &lt;s:property value="username"/&gt; &lt;s:property value="password"/&gt; &lt;s:property value="address"/&gt; &lt;/s:iterator&gt; 第三种1234567&lt;s:iterator value="list" var="user"&gt; &lt;!-- 遍历值栈list集合，得到每个user对象 机制：把每次遍历出来的user对象放到context里面 获取context里面的数据特点：写ognl表达式， 使用特殊符号 # --&gt; &lt;s:property value="#user.username"/&gt; &lt;s:property value="#user.username"/&gt; &lt;s:property value="#user.username"/&gt;&lt;/s:iterator&gt; 其他操作 先获取set方法设置的值 使用set方法向值栈放数据，获取12ValueStack stack = context.getValueStack();stack.set("shelhon","shelhon.cn"); 1&lt;s:property value="shelhon"/&gt; 使用push方法向值栈放数据，获取 1stack.push("asdb"); （1）使用push方法设置值，没有名称，只有设置的值（2）向值栈放数据，把向值栈放数据存到数组里面，数组名称 top，根据数组获取值1&lt;s:property value="[0].top"/&gt; EL表达式获取值栈数据首先要先导入两个jar包，分别是jstl.jar和standard.jar切记用idea的maven时，需要把这个jar包导入到tomcat里面去，具体看另一篇笔记，配置依赖的问题。 在jsp上面补个标签1&lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt; 1234&lt;c:forEach items="$&#123;list &#125;" var="user"&gt; $&#123;user.username &#125; $&#123;user.password &#125; $&#123;user.address &#125; &lt;/c:forEach&gt; EL表达式获取域对象值 向域对象里面放值使用setAttribute方法，获取值使用getAttribute方法 底层增强request对象里面的方法getAttribute方法（1） 首先从request域获取值，如果获取到，直接返回（2）如果从request域获取不到值，到值栈中把值获取出来，把值放到域对象里面 源码：public class StrutsRequestWrapper extends HttpServletRequestWrapperpublic Object getAttribute(String key) 不建议这么做，性能很低 OGNL的#、%使用关于 # 号的使用 使用#获取context里面数据 123&lt;s:property value="#user.username"/&gt;&lt;s:property value="#user.username"/&gt;&lt;s:property value="#user.username"/&gt; 关于 % 的使用 在struts2标签中表单标签（1） 在struts2标签里面使用ognl表达式，如果直接在struts2表单标签里面使用ognl表达式不识别，只有%之后才会识别。 错误示范,识别不了1&lt;s:textfield name="username" value="#request.req"&gt;&lt;/s:textfield&gt; 正确的应该是 1&lt;s:textfield name="username" value="%&#123;#request.req&#125;"&gt;&lt;/s:textfield&gt; 就是一个 %{} 里面写入ognl表达式 Struts2拦截器概述 struts2是框架，封装了很多的功能，struts2里面封装的功能都是在拦截器里面 struts2里面封装了很多的功能，有很多拦截器，不是每次这些拦截器都执行，每次执行默认的拦截器 struts2里面默认拦截器位置在struts2-core-2.3.24.jar里面有个叫struts-default.xml的文件最下面的内容是默认的拦截器 1234567891011121314151617181920212223242526&lt;interceptor-stack name="defaultStack"&gt; &lt;interceptor-ref name="exception"/&gt; &lt;interceptor-ref name="alias"/&gt; &lt;interceptor-ref name="servletConfig"/&gt; &lt;interceptor-ref name="i18n"/&gt; &lt;interceptor-ref name="prepare"/&gt; &lt;interceptor-ref name="chain"/&gt; &lt;interceptor-ref name="scopedModelDriven"/&gt; &lt;interceptor-ref name="modelDriven"/&gt; &lt;interceptor-ref name="fileUpload"/&gt; &lt;interceptor-ref name="checkbox"/&gt; &lt;interceptor-ref name="datetime"/&gt; &lt;interceptor-ref name="multiselect"/&gt; &lt;interceptor-ref name="staticParams"/&gt; &lt;interceptor-ref name="actionMappingParams"/&gt; &lt;interceptor-ref name="params"/&gt; &lt;interceptor-ref name="conversionError"/&gt; &lt;interceptor-ref name="validation"&gt; &lt;param name="excludeMethods"&gt;input,back,cancel,browse&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="workflow"&gt; &lt;param name="excludeMethods"&gt;input,back,cancel,browse&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="debugging"/&gt; &lt;interceptor-ref name="deprecation"/&gt;&lt;/interceptor-stack&gt; 拦截器在什么时候执行？在action对象创建之后，action的方法执行之前 拦截器底层原理 拦截器底层使用两个原理第一个: aop思想文字描述：Aop是面向切面（方面）编程，有基本功能，扩展功能，不通过修改源代码方式扩展功能 看图理解 第二个 ：责任链模式（1）在java中有很多的设计模式，责任链模式是其中的一种（2）责任链模式和过滤链很相似的责任链模式： 要执行多个操作，有添加、修改、删除三个操作。首先执行添加操作，添加操作执行之后 做类似于放行操作，执行修改操作，修改操作执行之后做类似于放行操作，执行删除操作 过滤链：一个请求可有多个过滤器进行过滤，每个过滤器只有做放行才能到下一个过滤器 aop思想和责任链模式如何应用到拦截器里面？ 1）文字描述： 拦截器在action对象创建之后，action的方法执行之前执行 在action方法执行之前执行默认拦截器，执行过程使用aop思想，在action没有直接调用拦截器的方法，使用配置文件方式进行操作 在执行拦截器时候，执行很多的拦截器，这个过程使用责任链模式 假如执行三个拦截器，执行拦截器1，执行拦截器1之后做放行操作，执行拦截器2，执行拦截器2之后做放行，执行拦截器3，执行拦截器3之后放行，执行action的方法 看图分析 重要的概念 过滤器和拦截器区别（1）过滤器：过滤器理论上可以任意内容，比如html、jsp、servlet、图片路径（2）拦截器：拦截器只可以拦截action Servlet和action区别（1）servlet默认第一次访问时候创建，创建一次，单实例对象（2）action每次访问时候创建，创建多次，多实例对象 自定义拦截器 在struts2里面有很多的拦截器，这些拦截器是struts2封装的功能，但是在实际开发中，struts2里面的拦截器中可以没有要使用的功能，这个时候需要自己写拦截器实现功能 拦截器结构 （1）从源码查看拦截器结构 继承类1class ModelDrivenInterceptor extends AbstractIntercetor 1class AbstractInterceptor implements Interceptor 在接口里有三个方法初始化： 1void init(); 销毁：1void destroy(); 拦截逻辑操作： 1String intercept(ActionInvocation invocation) (2)开发中，建议使用另外一种方式 写类，继承 MethodFilterInterceptor类实现 让action里面某个的方法不进行拦截 （3）让拦截器和action有关系 不是在action调用拦截器的方法，而是通过配置文件方式让建立关系 自定义登录拦截器 需求：在项目中，有很多的action的超链接，实现只有是登录的状态，才可以点击action的超链接实现功能，如果不是登录状态，点击action超链接返回到登录页面 登录的状态：使用session域对象实现（1）登录成功之后，把数据放到session里面（2）判断session是否有值，可以知道是否是登录状态 实现登录的基本功能查询数据库判断用户名和密码（另外实现） 添加登录拦截器功能 （1）判断是否登录：判断session里面是否有名称是username的值 （2）拦截器实现过程 第一步 创建类，继承MethodFilterInterceptor类 第二步 重写MethodFilterInterceptor类里面的方法写拦截器逻辑 第三步 配置action和拦截器关系（注册拦截器） （1）在要拦截的action标签所在的package标签里面声明拦截器 （2）在具体的action标签里面使用声明的拦截器 （3）struts2里面执行很多的默认拦截器，但是如果在action里面配置自定义拦截器.问题：默认的拦截器不会执行了解决：把默认拦截器手动使用一次 配置拦截器，对action里面所有的方法都进行拦截（1）在action里面有login的登录的方法，这个方法不需要拦截，如果这个方法都拦截，问题是，永远登录不进去了（2）解决：让login方法不进行拦截 直接通过配置方式让action里面某些方法不进行拦截 Struts2的标签库 struts2标签只能使用jsp页面中 s:property： 和ognl表达式在jsp页面中获取值栈数据 s:iterator: 获取值栈list集合数据，表示list集合 s:debug: 查看值栈结构和数据 Struts2表单标签（会用）1 html表单标签 （1）form : action、method、enctype （2）输入项 大部分在input里面封装 type=”值” text：普通输入项 password：密码输入项 radio：单选输入项 checkbox：复选输入项 file：文件上传项 hidden：隐藏项 button：普通按钮 submit：提交按钮 image：图片提交 reset：重置 select：下拉输入项 textarea：文本域 2.在struts2里面对应html表单标签大部分都有 12345678910111213141516&lt;s:form&gt; &lt;s:textfield name="username" label="username"&gt; &lt;/s:textfield&gt; &lt;s:password name="password" label="mima"&gt; &lt;/s:password&gt; // 值和名称一样 &lt;s:radio list="&#123;'nv','nan'&#125;" name="sex" label="xingbie"&gt;&lt;/s:radio&gt; //值和名称不一样 &lt;s:radio list="#&#123;'nv':'女','nan':'男'&#125;" name="sex" label="xingbie"&gt;&lt;/s:radio&gt; &lt;s:checkboxlist list="&#123;'1','2','3','4'&#125;" name="fav" label="随便挑"&gt;&lt;/s:checkboxlist&gt; &lt;s:select list="&#123;'a','b','c','d'&#125;" name="abcd" label="abcd"&gt;&lt;/s:select&gt;&lt;s:textarea rows="3" cols="10" value="jianli" label="jianli"&gt; &lt;/s:textarea&gt;&lt;s:file name="file" label="dakai"&gt; &lt;/s:file&gt;&lt;s:hidden name="hid" value="asdb"&gt; &lt;/s:hidden&gt;&lt;s:submit name="sub" value="tijiao"&gt; &lt;/s:submit&gt;&lt;s:reset value="chongzhi"&gt; &lt;/s:reset&gt;&lt;/s:form&gt;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2学习]]></title>
    <url>%2Fposts%2Fc240a0d6.html</url>
    <content type="text"><![CDATA[主要内容 stuts2入门 struts2数据操作 Struts2 概述 struts2框架应用javaee三层结构中的web层框架 struts2 是struts1和webwork基础上发展全新的框架、 struts2解决问题 struts2 版本 struts2-2.3.24 web层常用框架 struts2 springMVC struts2 框架入门第一个例子 老规矩导入jar包 创建action 123456789public class HelloAction &#123; /* (1)每次访问servlet的时候，都会访问service方法 - 写类继承HTTPServlet，重写类里面的方法 (2)访问action的时候 每次访问action默认执行execute方法 */ public String execute()&#123; return "ok";&#125;&#125; 配置action类访问路径(1)、创建struts2核心配置文件核心配置文件必须是固定名称和位置位置必须是再src下面，名称必须是struts.xml(2)、引入dtd约束 123&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; (3)、action配置 1234567&lt;package name="hellodemo" extends="struts-default" namespace="/"&gt; &lt;!-- name: 访问名称 --&gt; &lt;action name="hello" class="cn.shelhon.action.HelloAction"&gt; &lt;!-- 配置方法的返回值到页面 --&gt; &lt;result name="ok"&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 访问路径http://127.0.0.1:8080/struts2/hello.action (4) 配置struts2过滤器 在Tomcat上面运行的时候，发现一直各种报错 12严重: Exception starting filter struts2java.lang.ClassNotFoundException: org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter 估计是在idea的时候，运行Tomcat时，maven依赖那里出现了问题。导入缺少了jar包，Tomcat运行不起来。最后在项目结构Artifacts里available Elements右键把里面的jar包导入到lib文件夹里。 ！！还有就是一定要把struts2.xml文件放到resources文件夹里 基本流程： 查看源码 class StrutsPrepareAndExecuteFilter implements StrutsStatics, Filter 过滤器在服务启动的时候创建，创建过滤器时候执行init方法 在init方法中主要是加载配置文件包含自己创建的配置文件和struts2自带的配置文件主要注意struts.xml和web.xml struts 配置struts2核心配置文件 名称和位置是固定的固定是在src里面，名字是struts.xml但是由于用了maven，所以位置是在src的resources里面 在配置文件中主要三个标签 package、action、result，标签里面的属性 标签package1、 类似于代码包，区别不同的action，要配置action，必须首先写package标签，在package里面才能 配置action 2、 package标签属性 （1）name属性 name属性值跟功能本身没有关系的， 在一个配置文件中可以写多个package标签，name属性值不能相同的 （2）extends属性 extends = “struts-default” 属性值固定的，struts-default 写了这个属性之后，在package里面配置的类具有action功能 （3）namespace属性 namespace属性值和action标签里面的name属性值构成访问路径 标签action1、action标签配置action访问路径 2 、action标签属性 （1）name属性 namespace属性值和action标签里面的name属性值构成访问路径 在package标签里面写多个action标签，但是action的name属性值不能相同的 （2）class属性 action全路径 （3）method属性 比如在action里面默认执行的方法execute方法，但是在action里面写其他的方法 让action里面多个方法执行，使用method进行配置 标签result1 、根据action的方法返回值，配置到不同的路径里面 2 、result标签属性 （1）name属性 和方法返回值一样 /hello.jsp （2）type属性 配置如何到路径中（转发或者重定向） type属性默认值 做转发操作 struts2常量配置 struts2框架，帮我们实现一部分功能，struts2里面有常量，在常量里面封装一部分功能 struts2默认的常量位置（记住） xxxxxxx/org\apache\struts\struts2-core\2.3.24\struts2-core-2.3.24.jar!\org\apache\struts2\default.properties 修改struts2默认常量值 （1）常用的方式 在struts.xml中进行配置 （2）还有两种方式（了解） 在src下面创建 struts.properties，进行修改 在web.xml进行配置 介绍最常用常量 struts.i18n.encoding=UTF-8 （1）表单提交数据到action里面，在action可以获取表单提交数据， （2）表单提交数据有中文，有乱码问题，解决： post提交直接设置编码 get提交做编码转换 （3）如果在action获取表单通过post方式提交中文，中文乱码问题帮解决了，不需要自己处理问题 分模块开发 单独写配置文件hello.xml，把配置文件引入到核心配置文件中 12&lt;!-- 引入hello.xml --&gt; &lt;include file="hello.xml"&gt;&lt;/include&gt; 这样就可以在工作的时候，大家一起协同办公 action编写方式 action编写有三种方式 第一种 创建普通类，这个不继承任何类，不实现任何接口 1public class HelloAction&#123;&#125; 第二种 创建类，实现接口 Action123456//实现接口 public class UserAction implements Action &#123; public String execute() throws Exception &#123; return null; &#125;&#125; 第三种 创建类，继承类 ActionSupport（一般使用） 123//继承类 public class PersonAction extends ActionSupport &#123;&#125; 访问action里面的方法 有三种方式实现 第一种 使用action标签的method属性，在这个属性里面写执行的action的方法 第二种 使用通配符方式实现 第三种 动态访问实现（不用） 演示错误 （1）如果action方法有返回值，在配置文件中没有配置，出现错误 Message No result defined for action cn.shelhon.action.HelloAction and result success （2）在action里面的方法有返回值，如果有返回值时候类型必须是String （3）action里面的方法可以没有返回值，没有返回值时候，在result标签不需要配置 把方法写成void 让返回值，返回 ”none” 在idea创建新的模块的时候，放到Tomcat上面一直没办法运行新的struts.xml的配置，然后在运行设置里面的把原来的给移除了，加上新创建的就能运行了 使用action标签method属性 (1). 创建action，创建多个方法 123456789101112public class BookAction extends ActionSupport &#123; //添加 public String add()&#123; System.out.println("add----"); return NONE; &#125; //修改 public String update()&#123; System.out.printf("update---"); return NONE; &#125;&#125; (2). 使用method配置 1234567&lt;!-- 配置action的方法访问 --&gt; &lt;package name="demo1" namespace="/" extends="struts-default"&gt; &lt;action name="method" class="cn.shelhon.method.BookAction" method="add"&gt; &lt;/action&gt; &lt;action name="method1" class="cn.shelhon.method.BookAction" method="update"&gt; &lt;/action&gt;&lt;/package&gt; 缺陷：action每个方法都需要配置，如果action里面有多个方法，配置很多的action 使用通配符实现（重点） (1) 在action标签里面name属性，name属性值里面写 符号 * 星号 *理解： 表示匹配任意内容 比如访问hello，* 可以匹配到 比如访问add，* 可以匹配到 12345678910&lt;!-- 配置通配符方法 --&gt; &lt;package name="tongpei" extends="struts-default" namespace="/"&gt;&lt;!-- name属性值里面要写一个符号 *(1)执行 action里面的add方法，访问book_add (2)执行 action里面的update方法，访问book_update 上面两个路径使用book_*可以匹配到 --&gt; &lt;action name="book_*" method="&#123;1&#125;" class="cn.shelhon.method.BookAction"&gt;&lt;/action&gt;&lt;/package&gt; 这种方法的话，访问就是用book_add.action ,或者book_update.action来实现如果name的属性值=”*”的话，那么访问就是输入add.action，或者update.action就可以实现。 结果页面配置 result标签配置action方法的返回值到不同的路径里面 创建两个action，执行默认的方法execute方法，让两个action的方法都返回success，返回success之后，配置到同一个页面里面 （1）如果多个action，方法里面返回值相同的，到页面也是相同的，这个时候可以使用全局结果页面配置 12345678910&lt;package name="demo1" extends="struts-default" namespace="/"&gt;&lt;action name="book" class="cn.shelhon.action.BookAction" method="execute"&gt;&lt;result name="success"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt;&lt;action name="orders" class="cn.shelhon.action.OrdersAction" method="execute"&gt;&lt;result name="success"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt;&lt;/package&gt; 修改后代码12345678910&lt;package name="demo1" extends="struts-default" namespace="/"&gt; &lt;!-- 全局结果页面配置 --&gt; &lt;global-results&gt; &lt;result name="success"&gt;hello.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name="book" class="cn.shelhon.action.BookAction" method="execute"&gt; &lt;/action&gt; &lt;action name="orders" class="cn.shelhon.action.OrdersAction" method="execute"&gt; &lt;/action&gt;&lt;/package&gt; 但是要注意的是，这个全局变量是在package里面用的 局部结果页面 123&lt;action name="book" class="cn.shelhon.action.BookAction" method="execute"&gt;&lt;result name="success"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt; 如果同时配置了局部和全局结果页面，最后以局部变量为准 Result标签的type属性 result标签里面除了name属性之外，还有一个属性 type属性type属性：如何到路径里面（转发还是重定向） type属性值（1）默认值，做转发操作，值是 dispatcher就是说在浏览器上面的地址还是看到http://localhost:8080/struts2Day02/book.action但是实际内容是hello.jsp的内容（2）做重定向操作，值是 redirect输入http://localhost:8080/struts2Day02/book.action然后链接变成了http://localhost:8080/hello.jsp（3）上面两个值dispatcher、redirect，这两个值一般针对到页面中配置 配置到其他的action里面 chain：转发到action，一般不用，缓存问题输入http://localhost:8080/struts2Day02/book.action链接不变，但是实际内容已经是orders的内容 redirectAction：重定向到action比如输入http://localhost:8080/struts2Day02/book.action链接变成http://localhost:8080/orders.action Action获取表单提交数据 之前web阶段，提交表单到servlet里面，在servlet里面使用request对象里面的方法获取，getParameter，getParameterMap 提交表单到action，但是action没有request对象，不能直接使用request对象 action获取表单提交数据主要三种方式（1）使用ActionContext类（2）使用ServletActionContext类（3）使用接口注入方式(一般不用) 使用ActionContext类获取Map getParameters() : 返回一个包含所有HTTPSServletRequest参数信 因为这方法不是静态的方法，所以需要创建ActionContext类的对象 这个ActionContext不是new出来的 static ActionContext getContext() :获取当前线程的ActionContext对象 具体演示 （1）创建表单，提交表单到action里面 （2）在action使用ActionContext获取数据 12345678910111213141516public String execute() throws Exception &#123; // 第一种方式 使用ActionContext类获取 // 1获取Action Context ActionContext context =ActionContext.getContext(); //2 调用方法得到表单数据 // key是表单输入项的name属性值，value值是输入的值 Map&lt;String,Object&gt; map = context.getParameters(); Set&lt;String&gt; keys =map.keySet(); for (String key :keys)&#123; //根据key得到value //数据形式：因为输入项里面可能有复选的情况 Object[] obj = (Object[]) map.get(key); System.out.println(Arrays.toString(obj)); &#125; return NONE;&#125; 123&lt;package name="demo2" namespace="/" extends="struts-default"&gt; &lt;action name="form1" class="cn.shelhon.action.form.Form1Demo"&gt; &lt;/action&gt; 使用ServletActionContext类获取 调用类里面静态方法，得到request对象 12345678910public String execute() throws Exception &#123; //第一种方式，使用ServletActionContext类获取 //1使用ServletActionContext获取request对象 HttpServletRequest request = ServletActionContext.getRequest(); String username = request.getParameter("username"); String password = request.getParameter("password"); String address = request.getParameter("address"); System.out.println(username+password+address); return NONE;&#125; 使用接口注入（了解）1234567891011121314public class Form3Demo extends ActionSupport implements ServletRequestAware &#123; //使用接口方式private HttpServletRequest request;public void setServletRequest(HttpServletRequest request) &#123; this.request=request; &#125; public String execute() throws Exception &#123; String username = request.getParameter("username"); String password = request.getParameter("password"); String address = request.getParameter("address"); System.out.println(username+password+address); return NONE; &#125;&#125; 在action操作域对象12345678910//操作三个域 // 1 request域 HttpServletRequest request = ServletActionContext.getRequest();request.setAttribute("req","reqValue");//2 session域 HttpSession session = request.getSession();session.setAttribute("sess","sessValue");//3 ServletContext域 ServletContext context = ServletActionContext.getServletContext();context.setAttribute("contextname","contextValue");return NONE; Struts2封装获取表单数据方式原始方式获取表单封装到实体类对象123456789101112131415public String execute() throws Exception &#123; // 使用servletActionContext获取表单数据封装到实体类对象里面 // 1获取表单数据 HttpServletRequest request = ServletActionContext.getRequest(); String username = request.getParameter("username"); String password = request.getParameter("password"); String address = request.getParameter("address"); //2 把数据封装到实体类对象里面 User user = new User(); user.setUsername(username); user.setPassword(password); user.setAddress(address); System.out.println(user); return NONE;&#125; 123456789101112131415161718192021222324252627282930public class User &#123; private String username; private String password; private String address; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "username='" + username + '\'' + ", password='" + password + '\'' + ", address='" + address + '\'' + '&#125;'; &#125; 属性封装 实现过程（1）使用表达式封装可以把表单数据封装到实体类对象里面 第一步 在action里面声明实体类1&lt;action name="data1" class="cn.shelhon.data.DataDemo1Action"&gt; &lt;/action&gt; 第二步 生成实体类变量的set和get方法 12345678910111213141516171819202122232425262728293031public class DataDemo1Action extends ActionSupport &#123;//定义变量 //变量的名称和表单的name属性一样 private String username; private String password; private String address; // 生成变量的set和get方法 public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; System.out.println(username+" "+password+" "+address); this.password = password; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String execute() throws Exception &#123; return NONE; &#125;&#125; 模型驱动封装（重点） 使用模型驱动方式，可以直接把表单数据封装到实体类对象里面 实现步骤 （1）action实现接口 ModelDriven 1public class DataDemo2Action extends ActionSupport implements ModelDriven&lt;User&gt; &#123;&#125; （2）实现接口里面的方法 getModel方法 把创建对象返回 12345678910public class DataDemo2Action extends ActionSupport implements ModelDriven&lt;User&gt; &#123; public User getModel() &#123; return user; &#125; @Override public String execute() throws Exception &#123; return NONE; &#125;&#125; （3）在action里面创建实体类对象 123public User getModel() &#123; return user;&#125; 使用模型驱动和属性封装注意问题：在一个action中，获取表单数据可以属性封装，使用模型驱动封装，不能同时使用属性封装和模型驱动封装获取同一个表单数据。如果同时使用，执行模型驱动。 表达式封装（会用） 实现过程（1）使用表达式封装可以把表单数据封装到实体类对象里面第一步 在action里面声明实体类private User user;第二步 生成实体类变量的set和get方法 123456public User getUser() &#123; return user;&#125;public void setUser(User user) &#123; this.user = user;&#125; 第三步 在表单输入项的name属性值里面写表达式形式12345username:&lt;input type="text" name="user.username"/&gt;&lt;br/&gt;password:&lt;input type="text" name="user.password"/&gt;&lt;br/&gt;address:&lt;input type="text" name="user.address"/&gt; 比较表达式封装和模型驱动封装使用表达式封装和模型驱动封装都可以把数据封装到实体类对象里面不同点：（1）使用模型驱动只能把数据封装到一个实体类对象里面在一个action里面不能使用模型驱动把数据封装到不同的实体类对象里面（2）使用表达式封装可以把数据封装到不同的实体类对象里面 12345678910111213141516171819202122public class DataDemo3Action extends ActionSupport &#123; //声明实体类 private User user; private Book book; public Book getBook() &#123; return book; &#125; public void setBook(Book book) &#123; this.book = book; &#125; //生成实体类变量的set和get方法 public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public String execute() throws Exception &#123; System.out.println(user); System.out.println(book.getBname()); return NONE; &#125; 1234567891011&lt;form action="$&#123;pageContext.request.contextPath&#125;/data3.action" method="post"&gt; username:&lt;input type="text" name="user.username"/&gt; &lt;br/&gt; password:&lt;input type="text" name="user.password"/&gt; &lt;br/&gt; address:&lt;input type="text" name="user.address"/&gt; &lt;br/&gt; bname:&lt;input type="text" name="book.bname"/&gt; &lt;br/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; 封装到集合里面 封装数据到List集合 第一步 在action声明List1private List&lt;User&gt; list; 第二步 生成list变量的set和get方法 第三步 在表单输入项里面写表达式123456789101112131415&lt;form action="$&#123;pageContext.request.contextPath&#125;/list.action" method="post"&gt; username:&lt;input type="text" name="list[0].username"/&gt; &lt;br/&gt; password:&lt;input type="text" name="list[0].password"/&gt; &lt;br/&gt; address:&lt;input type="text" name="list[0].address"/&gt; &lt;br/&gt; &lt;br/&gt; username:&lt;input type="text" name="list[1].username"/&gt; &lt;br/&gt; password:&lt;input type="text" name="list[1].password"/&gt; &lt;br/&gt; address:&lt;input type="text" name="list[1].address"/&gt; &lt;br/&gt; &lt;input type="submit" value="提交"/&gt; 封装数据到Map集合 第一步 声明map集合private Map&lt;String,User&gt; map;第二步 生成get和set方法 123456public Map&lt;String,User&gt; getMap() &#123; return map;&#125;public void setMap(Map&lt;String,User&gt; map) &#123; this.map = map;&#125; 第三步 在表单输入项的name属性值里面写表达式123456789101112131415161718&lt;form action="$&#123;pageContext.request.contextPath&#125;/map.action" method="post"&gt; &lt;!-- 设置key的值 ['key值'] 设置value值 --&gt; username:&lt;input type="text" name="map['one'].username"/&gt; &lt;br/&gt; password:&lt;input type="text" name="map['one'].password"/&gt; &lt;br/&gt; address:&lt;input type="text" name="map['one'].address"/&gt; &lt;br/&gt; &lt;br/&gt; username:&lt;input type="text" name="map['two'].username"/&gt; &lt;br/&gt; password:&lt;input type="text" name="map['two'].password"/&gt; &lt;br/&gt; address:&lt;input type="text" name="map['two'].address"/&gt; &lt;br/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 框架学习(二)]]></title>
    <url>%2Fposts%2F14042445.html</url>
    <content type="text"><![CDATA[大概内容 基于aspectj的注解aop操作 spring的jdbcTemplate操作 spring配置连接池 spring事务管理 基于aspectj的注解aop操作 使用注解方式创建aop操作 第一步 ：创建对象123&lt;!-- 1 配置对象 --&gt; &lt;bean id="book" class="cn.shelhon.cn.shelhon.aop.Book"&gt; &lt;/bean&gt; &lt;bean id="myBook" class="cn.shelhon.cn.shelhon.aop.Book"&gt; &lt;/bean&gt; 第二步 ：在spring核心配置文件里面开启AOP操作 12&lt;!-- 开启aop操作 --&gt; &lt;aop:aspectj-autoproxy&gt; &lt;/aop:aspectj-autoproxy&gt; 第三步 ： 在增强类上面使用注解完成aop操作 123@Aspect public class Mybook &#123; //在方法上面使用注解完成增强配置 @Before(value = "execution(* cn.shelhon.aop.Book.*(..)") Spring的jdbcTemplate操作 实现crud操作 - 增加、修改、删除，调用模板update方法 - 查询某个值时候，调用queryForObject方法 - 自己写实现类封装数据 - 查询对象，调用queryForObject方法 - 查询list集合，调用query方法 spring框架一站式框架 针对javaee三层，每一层都有解决技术 在dao层，使用 jdbcTemplate spring对不同的持久化层技术都进行封装 其中jdbcTemplate对jdbc进行封装 jdbcTemplate使用和dbutils使用很相似，都数据库进行crud操作 增加 导入jdbcTemplate使用的jar包 创建对象，设置数据库信息 创建JdbcTemplate对象，设置数据源 调用jdbcTemplate对象里面的方法 操作的时候，记得还要导入驱动数据库的jar包 1234567891011121314151617181920212223// 添加操作 @Test public void add()&#123; //创建对象，设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("conm.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://test"); dataSource.setUsername("root"); dataSource.setPassword("12345"); // 创建JdbcTemplate对象，设置数据源 JdbcTemplate jdbcTempalate = new JdbcTemplate(dataSource); //调用jdbcTemplate对象里面的方法 String sql = "insert into user value(?,?)"; int rows = jdbcTempalate.update(sql,"lucy","22"); System.out.println(rows); &#125; 特别要注意的是，在运行的时候报错出现的问题 1org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Unknown character set index for field &apos;255&apos; received from server. 这个问题是由于我使用的数据库版本比较新，导致旧的mysql-connector-java的版本使用的时候报错。 (1) MYSQL 5.5 之前， UTF8 编码只支持1-3个字节;从MYSQL5.5开始，可支持4个字节UTF编码utf8mb4;如emoji表情需要使用utf8mb4 (2) 如果服务器级使用的编码是utf8mb4(在客户端链接后使用sql语句show variables like ‘char%’可查看所有编码)，而mysql的jar包低版本不支持utf8mb4,连接时报错”Unknown character set index for field ‘224’ received from server.” (3) 建议使用mysql-connector-java-5.1.30-bin.jar (4) 注意：如果数据库不支持utf8mb4，使用mysql-connector-java-5.1.30-bin.jar的jar包时则会报错，此时应该使用低版本的jar包。 然后这个时候我又用了最新版本的mysql-connector的jar包又报错1java.lang.UnsupportedClassVersionError: com/mysql/jdbc/Driver : Unsupported major.minor version 52.0 这种问题是jdk版本和mysql数据库版本不兼容从网上寻找的答案有如下： 1、jdk7+老版5.0驱动com/mysql/jdbc/Driver 2、jdk8+新版6.0驱动com/mysql/cj/jdbc/Driver 所以就是最新的jar是不能跟jdk1.7搭配使用的。最后解决问题的是这样的搭配 jdk1.7.0_80 mysql-connector-java 5.1.46 spring-jdbc 4.2.4.RELEASE 更新更新的方法跟增加差不多。 1234//调用jdbcTemplate对象里面的方法 String sql = "update user set password=? where name=?"; int rows = jdbcTemplate.update(sql,"lucy","99"); System.out.println(rows); 删除删除也是同理1234//调用jdbcTemplate对象里面的方法 String sql = "delete from user where name=?"; int rows = jdbcTemplate.update(sql,"null"); System.out.println(rows); 查询1、查询表中有多少记录12345// 创建JdbcTemplate对象，设置数据源JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);String sql = "select count(*) from user";int count =jdbcTemplate.queryForObject(sql,Integer.class);System.out.println(count); &#125; 2、查询返回对象jdbc底层原理12345678910111213141516171819202122232425262728293031323334353637383940@Test public void testJDBC()&#123;Connection conn = null;PreparedStatement psmt =null;ResultSet rs = null;try &#123; Class.forName("com.mysql.jdbc.Driver");//创建连接conn = DriverManager.getConnection("jdbc:mysql:///test", "root", "12345");//编写sql语句String sql = "select * from user where name =?";//预编译sql语句psmt = conn.prepareStatement(sql);//设置参数值psmt.setString(1, "lucy");//遍历结果集rs =psmt.executeQuery(); while(rs.next())&#123; //得到返回值String username =rs.getString("name");String password = rs.getString("password"); //放到User对象里面User user =new User();user.setUsername(username);user.setPassword(password);System.out.println(user); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try&#123; rs.close();psmt.close();conn.close();; &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125; &#125;&#125; User.java代码 123456789101112131415161718192021222324252627282930package cn.shelhon.jdbc; public class User &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public String getPassword() &#123; return password; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User&#123;" + "username='" + username + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 具体的实现 1234567891011121314151617181920212223242526272829@Test public void testObject()&#123; //创建对象以及设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql:///test"); dataSource.setUsername("root"); dataSource.setPassword("12345"); // 创建JdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); //写sql语句，根据name来查询 String sql ="select * from user where name = ?"; //调用jdbctempla的方法实现 //第二个参数是接口ROWMapper，需要自己写个类,自己做数据封装 User user=jdbcTemplate.queryForObject(sql,new MyRowMapper(),"rose"); System.out.println(user); &#125;&#125;class MyRowMapper implements RowMapper&lt;User&gt;&#123; public User mapRow(ResultSet rs, int i) throws SQLException &#123; //从结果集里把数据拿到 String username = rs.getString("name"); String password = rs.getString("password"); //把得到的数据封装到对象里面 User user = new User(); user.setUsername(username); user.setPassword(password); return user; &#125;&#125; 3、查询返回list集合 1234567891011121314@Test public void testList()&#123; //创建对象以及设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql:///test"); dataSource.setUsername("root"); dataSource.setPassword("12345"); // 创建JdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); //写sql语句，根据name来查询 String sql ="select * from user"; //调用jdbctempla的方法实现 //第二个参数是接口ROWMapper，需要自己写个类,自己做数据封装List&lt;User&gt; list =jdbcTemplate.query(sql,new MyRowMapper()); System.out.println(list); &#125; Spring配置连接池配置c3p0连接池 导入jar包c3p0-0.9.2.1mchange-commons-java-0.2.3.4 创建spring文件，建立连接池 1234567&lt;!-- 配置c3p0连接池 --&gt; &lt;bean id ="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 注入属性值--&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt; &lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://test"&gt; &lt;/property&gt; &lt;property name="user" value="root"&gt; &lt;/property&gt; &lt;property name="password" value="12345"&gt; &lt;/property&gt; &lt;/bean&gt; dao使用jdbcTemplate 创建service和dao，配置service和dao对象，在service注入dao对象 1234&lt;bean id="userService" class="cn.shelhon.c3p0.UserService"&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id="userDao" class="cn.shelhon.c3p0.UserDao"&gt;&lt;/bean&gt; 创建jdbcTemplate对象，把模板对象注入到dao里面创建对象12345private JdbcTemplate jdbcTemplate; //添加操作public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; 注入dao里面123&lt;bean id="userDao" class="cn.shelhon.c3p0.UserDao"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt; &lt;/property&gt;&lt;/bean&gt; 在jdbcTemplate对象里面注入dataSource 1234&lt;!-- 创建JdbcTemplate对象 --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;!-- 把datasource传递到模板对象里面 --&gt; &lt;property name="dataSource" ref="dataSource"&gt; &lt;/property&gt; &lt;/bean&gt; 关于数据库语句因为我的表里用了主键，在插入新的数据的时候 12String sql ="insert into user values(?,?)"; jdbcTemplate.update(sql,"李峰","asd"); 按照这语法就报错了 后来改这样就通过了12String sql="insert into user(id,name,password) values(null,?,?)"; jdbcTemplate.update(sql,"李峰","asd"); Spring事务管理事务概念 什么是事务Spring事务 的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。 理解事务之前，先讲一个你日常生活中最常干的事：取钱。比如你去ATM机取1000块钱，大体有两个步骤：首先输入密码金额，银行卡扣掉1000元钱；然后ATM出1000元钱。这两个步骤必须是要么都执行要么都不执行。如果银行卡扣除了1000块但是ATM出钱失败的话，你将会损失1000元；如果银行卡扣钱失败但是ATM却出了1000块，那么银行将损失1000元。所以，如果一个步骤成功另一个步骤失败对双方都不是好事，如果不管哪一个步骤失败了以后，整个取钱过程都能回滚，也就是完全取消所有操作的话，这对双方都是极好的。事务就是用来解决类似问题的。事务是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。在企业级应用程序开发中，事务管理必不可少的技术，用来确保数据的完整性和一致性。 事务特性：四大特性(简称ACID) 原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 一致性（Consistency）：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 隔离性（Isolation）:隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 持久性（Durability）:持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 不考虑隔离性产生读问题 脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。 不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。 虚读(幻读)： 幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 解决读问题 设置隔离级别数据库隔离级别： ① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 ② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。 ③ Read committed (读已提交)：可避免脏读的发生。 ④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 spring进行事务管理apispring事务管理有两种方法 编程式事务管理（一般不用） 声明式事务管理： 基于xml配置文件实现 基于注解实现 spring事务管理的api介绍spring事务管理高层抽象主要包括3个接口 PlatformTransactionManager事务管理器 TransactionDefinition事务定义信息（隔离、传播、超时、只读） TransactionStatus事务具体运行状态 其中spring针对不同的dao层框架，提供不同的实现类比如： org.springframework.jdbc.datasource.DataSourceTransactionManager是使用springJDBC或者iBatis进行持久化数据时使用。 org.springframework.orm.hibernate5.HibernateTransactionManager使用Hiber5版本进行持久化数据时使用 搭建转账环境首先配置事务管理器 创建数据库的表，添加数据 创建service类和dao类，完成注入关系。 12345678910111213&lt;bean id="ordersService" class="cn.shelhon.service.OrdersService"&gt; &lt;property name="ordersDao" ref="ordersDao"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id="ordersDao" class="cn.shelhon.Dao.OrdersDao"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; service层又叫业务逻辑层 dao层，单独对数据库操作层，在dao层不添加业务 比较齐全的约束 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:context="http://www.springframework.org/schema/context"xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;&lt;/beans&gt; 需求甲 转账给 乙 1000甲 少 1000乙 多 1000 先在dao层写操作数据库的方法 12345678910111213141516public class OrdersDao &#123; //注入jdbcTemplate模板 private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; //提供对数据库操作的方法，不写业务操作 // 少钱的方法 public void lessMoney()&#123; String sql ="update account set salary=salary-? where name = ?"; jdbcTemplate.update(sql,1000,"甲"); &#125; // 加钱的方法 public void addMoney()&#123; String sql ="update account set salary=salary+? where name =?"; jdbcTemplate.update(sql,1000,"乙"); &#125;&#125; 然后再service层调用dao层写业务逻辑 123456789101112public class OrdersService &#123; private OrdersDao ordersDao; public void setOrdersDao(OrdersDao ordersDao) &#123; this.ordersDao = ordersDao; &#125; //调用dao的方法 //业务逻辑层，写转账业务 public void accountMoney()&#123; // 甲少1000 ordersDao.lessMoney();; // 乙多1000 ordersDao.addMoney(); &#125;&#125; 产生的问题 ： 如果甲扣钱了以后，出现异常，乙的钱并没有增加，钱丢失了 解决： -添加事务解决，出现异常进行回滚操作 spring进行事务配置（声明式）基于xml配置文件 配置文件使用aop思想 12345&lt;!-- 第一步配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入datasource --&gt; &lt;property name="dataSource" ref="dataSource"&gt; &lt;/property&gt; &lt;/bean&gt; 配置事务的增强 1234567&lt;!-- 第二步 配置事务增强 --&gt; &lt;tx:advice id ="txadvice" transaction-manager="transactionManager"&gt; &lt;!-- 做事务操作 --&gt; &lt;tx:attributes&gt; &lt;!-- 设置进行事务操作的方法匹配规则 --&gt; &lt;tx:method name="account*"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 配置切面 1234567&lt;!-- 第三步 --&gt; &lt;!-- 配置切面 --&gt; &lt;aop:config&gt; &lt;!-- 切入点 --&gt; &lt;aop:pointcut expression ="execution(* cn.shelhon.service.OrdersService.*(..))" id = "pointcut1"/&gt; &lt;!--切面--&gt; &lt;aop:advisor advice-ref="txadvice" pointcut-ref="pointcut1"/&gt; &lt;/aop:config&gt; 经过上面的配置以后，出现异常就能自动回滚操作 基于注解方式 第一步也是要先配置事务管理器 12345&lt;!-- 配置事务管理器 --&gt; &lt;bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt; &lt;/property&gt;&lt;/bean&gt; 配置事务注解 12&lt;!-- 开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager="dataSourceTransactionManager"/&gt; 要在使用事务的方法所在类上添加注解 12345678910111213141516@Transactional public class OrdersService &#123; private OrdersDao ordersDao; public void setOrdersDao(OrdersDao ordersDao) &#123; this.ordersDao = ordersDao; &#125; //调用dao的方法 //业务逻辑层，写转账业务 public void accountMoney()&#123; // 甲少1000 ordersDao.lessMoney();; //出现异常 // int i =10/0; // 乙多1000 ordersDao.addMoney(); &#125;&#125;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用IDEA遇到的问题记录]]></title>
    <url>%2Fposts%2Fada285ba.html</url>
    <content type="text"><![CDATA[人可以做他想做的，但不能要他想要的 记录在使用idea的过程中遇到的问题 比如 配置环境遇到的问题 导入jar包 依赖 maven Tomcat jdk和jar包版本的问题 将会比较随意的记录 配置环境说到底原本最初是用idea，后来实习公司又要用eclipse，不怎么熟悉这个开发工具，本来就艰难，jdk就用一开始的1.8版本jdk，结果按照公司要求用回jdk1.7和Tomcat1.7的时候，eclipse就无法打开了。因为photon不支持1.8以下的版本。果断回头idea。 关于那个新建项目以后的文件目录格式，可以创建后自己修改。不用太纠结位置。 在创建项目以后，可以再创建模块，一个模块就相当于原来eclipse里面的项目。 在idea里面移除模块以后，不会删除本地硬盘里的文件，如果需要再导入这个模块进入项目里面的话，就找到 xxxx.iml文件，然后导入就会自动加载原来的那个模块了。 在运行的过程中，试过出现以下报错 1org.springframework.beans.factory.BeanDefinitionStoreException: IOException parsing XML document from class path resource [applicationContext.xml]; nested exception is java.io.FileNotFoundException: class path resource [applicationContext.xml] cannot be opened because it does not exist 最后是把applicationContext.xml放入resources文件夹里才成功。包括什么log4j.properties等这类型的文件都是要放进去才能生效。 导入jar包要注意框架的版本，因为不同版本，可能jar包就取消了，或者集合在一起了，这个必须得注意。 配置依赖大概就是maven添加的依赖，在配置到tomcat上的时候，没有关联到jar包，导致服务器 一直出错，如果碰到与maven和Tomcat相关的报错，可以考虑下面的解决方法。 IDEA: 遇到问题Error during artifact deployment. See server log for details.详细的报错是12严重: Exception starting filter struts2java.lang.ClassNotFoundException: prg.apache.struts2.dispatcher.FilterDispatcher 虽然不太懂原因，但是解决方法是打开项目结构，然后在Artifacts上面找到报错模块的地方，接着在output Layout找到WEB-INF文件夹，创建一个lib文件夹，然后右键文件夹添加副本，选择库文件，选择需要的jar包文件，问题就解决了。 maven在配置好系统环境变量以后在idea里的setting里设置maven的东西比如默认读取setting.xml的位置和仓库的位置因为idea自带的maven和我们自己安装位置的会不同 新建的时候就对着模块右键，选择添加框架支持 在里面找到maven然后直接新建就行。 创建pom.xml后好像会提示更新目录什么的，让idea来完成就好 默认的pom.xml里面需要我们自己去添加依赖，但是文件里会少了一些代码 &lt;dependencies&gt; #中间这里把maven依赖网站上面的配置自己找下来，复制上去就行 &lt;/dependencies&gt; 如果要移除依赖的话，直接删除pom.xml就可以了，同时idea会自动调整目录结构的 使用过程中，如果发现项目没有添加依赖，那么在项目结构中，找到这个项目的依赖，然后删除重新导入。 maven的依赖查询网站 ：http://mvnrepository.com/ 在idea右侧的工具栏里是可以找到maven插件的，通过这个可以很快查看每个项目的依赖。 Tomcat tomcat1.7版本不支持Servlet3.0以上的版本 然而idea创建web.xml的时候基本默认是4.0版本 Servlet 3.1 部署描述符Java EE 7 XML schema, namespace is http://xmlns.jcp.org/xml/ns/javaee/ 123456&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaeehttp://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"version="3.1"&gt;&lt;/web-app&gt; Servlet 3.0 部署描述符Java EE 6 XML schema, namespace is http://java.sun.com/xml/ns/javaee 123456&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://java.sun.com/xml/ns/javaeehttp://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"version="3.0"&gt;&lt;/web-app&gt; Servlet 2.5 部署描述符Java EE 5 XML schema, namespace is http://java.sun.com/xml/ns/javaee 123456&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://java.sun.com/xml/ns/javaeehttp://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"version="2.5"&gt;&lt;/web-app&gt; Servlet 2.4 部署描述符J2EE 1.4 XML schema, namespace is http://java.sun.com/xml/ns/j2ee 1234567&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://java.sun.com/xml/ns/j2eehttp://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"version="2.4"&gt; &lt;display-name&gt;Servlet 2.4 Web Application&lt;/display-name&gt;&lt;/web-app&gt; Servlet 2.3 部署描述符J2EE 1.3 DTDs schema. This web.xml file is too old, highly recommend you to upgrade it.123456&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Servlet 2.3 Web Application&lt;/display-name&gt;&lt;/web-app&gt; Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。 idea 快捷键alt+鼠标左键 可以查看源代码 CTRL+shift+i 可以小窗口查看源代码–再加上CTRL+enter可以打开窗口 CTRL+shift+t 可以打开try catch等语句]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>IDEA</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 框架学习]]></title>
    <url>%2Fposts%2F46958.html</url>
    <content type="text"><![CDATA[spring框架的介绍 &nbsp; Spring框架是一个轻量级的控制反转（IOC）和面向切面（AOP）的容器框架。 &nbsp; 记录了一些关于框架特点和特性以及Spring工作流程图。比如： IOC AOP的底层原理 属性注入 注解 bean管理 一、 一些基本特性 轻量：大小与开销轻量级，完整的spring框架可以在大小只有1MB多的JAR文件中发布，且spring框架是非侵入式的，spring应用不依赖于spring特定类。 控制反转：Spring通过一种称为控制反转的（IOC）的技术促进松耦合。当应用了IOC，一个对象依赖的其他对象通过被动的方式传递进来，而不是对象自己创建或者查找依赖对象。不是对象从容器中查找依赖，而是容器在对象初始化的不等对象请求就主动依赖传递过去.把对象的创建不是通过new方式，而是交给spring配置创建类对象。 面向切面：Spring提供面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发（AOP）。 容器：Spring包含并管理应用对象的配置和生命周期，可以配置每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以可以创建一个单独的实例，或每次需要都生成一个新的实例——以及他们是如何相互关联。 框架：Spring框架可以将简单的组件配置，组合成为复杂的应用。在Spring应用对象被声明组合，典型是在一个XML文件里面，Spring也提供许多基础功能（事务管理，持久化框架集成，自己开发应用逻辑） 二、 Spring流程图 解析：这个图在Struts结构图的基础上加了spring流程图，在web.xml配置文件中加入了spring监听器，在Struts配置文件中添加是告知Struts2运行的时候使用spring来创建对象，spring在其中要做就是注入实例，将所有需要类的实例都由spring管理。 三、 深入了解Spring是一站式框架spring在Javaee三层结构： 每一层都提供不同的解决技术。 web层：SpringMVC service层：Spring的IOC DAO层：Spring的jdbcTemplate 该笔记的学习是基于spring4.x版本 业精于勤 ，荒于嬉；行成于思，毁于随 spring的IOC操作把对象创建交给spring进行管理ioc操作两部分： （1）IOC的配置文件方式 （2）IOC的注解方式 IOC的底层原理 xml配置文件 dom4j解决xml 工厂设计模式 反射 1234567public class UserService&#123;&#125;public class UserServlet&#123; //得到UserServlet的对象 //原始：new创建 uersFactory.getService();&#125; 第一步 创建xml配置文件，配置要创建对象类 1&lt;bean id ="userService" class="cn.itcast.Userservice"/&gt; 第三步 创建工厂类，使用dom4j解析配置+反射123456789101112public class Userfacorty&#123; //返回UserService对象的方法&#125;public static UserService getService()&#123; //使用dom4j解析xml文件 //根据id值userService,得到id值对应class属性值 String class = "class属性值"; class clazz= class.forname(classValue); //创建类对象 Userservice service =clazz.newInstance(); return service;&#125; 在创建spring配置文件的时候注意，spring核心配置和位置不是固定的，建议放到src下面，官方建议的名称叫applicationContext.xml 配置的时候引入schema约束可以在docs文档 →spring-framenwork-reference →html里找最后一个configuration.xsd里有 IOC和DI的区别 IOC：控制反转，把对象创建交给spring进行配置 DI ：依赖注入，向类里面的属性中设置值 关系：依赖注入不能单独存在，需要在IOC的基础上完成操作的。 Spring的Bean管理（XML配置文件）Bean实例化的三种方式使用类的无参数构造创建12&lt;!-- ioc入门 --&gt;&lt;bean id ="user" class="cn.itcast.ioc.User"&gt;&lt;/bean&gt; 如果类里面没有无参数的构造，就会出现异常 使用静态工厂创建创建类的方法，返回类的对象123456public class Bean2Factory&#123; //静态方法，返回Bean2对象 public static Bean2 getBean2()&#123; return new Bean2(); &#125;&#125; 12&lt;!-- 使用静态工厂创建对象 --&gt;&lt;bean id="bean2" class="cn.itcast.bean.Bean2Factory" factory-method="getBean2"&gt; 使用实例工厂创建创建不是静态的方法，返回类对象 123456public class Bean3Factory&#123; //普通的方法。返回bean3对象 public Bean3 getBean3()&#123; return new Bean3(); &#125;&#125; Bean的常用标签id属性起名称，不能包含特殊符号根据id值得到配置对象 class属性创建对象所在类的全路径 name属性根据属性值得到配置对象但在name属性里可以包含特殊符号现在不怎么用，都是旧版本的遗留问题 scope属性 singleton：默认值，单例 prototype：多例 request：创建对象把对象放到request域里面(request的生命周期是一次访问，如果登陆信息放在request域的话，第二次访问就丢失了） session：创建对象把对象放到session域里面(session域的生命周期是默认30分钟，也叫一次会话，当浏览器访问的时候，就创建了session，当浏览器关闭了，或者超过30分钟了，session就会关闭。 globalSession：创建对象把对象放到globalSession里面 属性注入介绍创建对象的时候，向类里面属性设置值 属性注入的三种方式 使用set方法123456public class User&#123; private String name; public void setName(String name)&#123; this.name = name; &#125;&#125; 12User user =new User();user.setName("abcd"); 使用有参数的结构注入123456public class User&#123; private String name; public User(String name)&#123; this.name = name; &#125;&#125; 1User user =new User("lucy"); 使用接口注入123public interface Dao&#123; public void delete(String name);&#125; 123456public class DaoImpl implements Dao&#123; private String name; public void delete (String name)&#123; this.name = name; &#125;&#125; 注意的地方在spring框架里面，支持前两种方式 set方法注入（重点） 有参数结构注入 使用有参数构造注入属性 1234&lt;!-- 使用有参数构造注入属性 --&gt;&lt;bean id =&quot;demo&quot; class =&quot;cn.itcast.property.PropertyDemo1&quot;&gt;&lt;!-- 使用有参数构造注入 --&gt;&lt;constructor-arg name=&quot;username&quot; value =&quot;tom&quot;&gt;&lt;/constructor-arg&gt; 1234567private String name ;public PropertyDemo1(String user name)&#123; this.username =username;&#125;public void test1&#123; System.out.println("demo1----"+username);&#125; 使用set方法注入属性（重点）12345private String bookname;//set 方法public void setBookname(String bookname)&#123; this.bookname =bookname;&#125; 1234567&lt;!-- 使用set方法注入属性 --&gt;&lt;bean id =&quot;book&quot; class =&quot;cn.itcast.property.Book&quot;&gt; &lt;!-- 注入属性 name属性值，类里面定义的属性名称 value属性：设置属性的值 --&gt; &lt;property name =&quot;bookname&quot; value =&quot;hamlet&quot;&gt;&lt;/property&gt; 注入 对象类型 属性（重点）创建service类和dao类 在service得到dao对象 具体的实现过程 在service 里面把dao作为类型属性 生成dao类型属性的set方法 12345678public class UserService&#123; //1定义dao类型属性 private UserDao userDao; //2生成set方法 public void setUserDao(UserDao userDao)&#123; this.userDao =userDao; &#125;&#125; 配置文件中注入关系 123456789&lt;!-- 1配置service和dao对象 --&gt;&lt;bean id = "userDao" class ="cn.itcast.ioc.UserDao"&gt;&lt;/bean&gt;&lt;bean id= "userService" class ="cn.itcast.ioc.Userservice"&gt;&lt;!-- 注入dao对象name属性值：service类里面属性名称但是现在不要写value属性，因为之前的是字符串，现在是对象 。写ref属性：dao配置中的bena标签的id值--&gt;&lt;property name ="userDao" ref ="userDao"&gt;&lt;/property&gt; P名称空间注入修改配置文件，加入下面这一条 1xmls : p =&quot;http://www.spring.framework.org/schema/p&quot; 然后再加入这条 12&lt;!-- P名称空间注入 --&gt;&lt;bean id ="person" class= "cn.itcast.property.Person" p :name="Lucy"&gt; 注入复杂类型属性 数组 list集合 map集合 properties类型 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- 注入复杂类型属性 --&gt;&lt;bean id = "person" class ="cn.itcast.property.Person"&gt;&lt;!-- 数组 --&gt;&lt;property name="arrs"&gt; &lt;list&gt; &lt;value&gt;小王&lt;/value&gt; &lt;value&gt;小马&lt;/value&gt; &lt;value&gt;小宋&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!-- list --&gt;&lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;小奥&lt;/value&gt; &lt;value&gt;小金&lt;/value&gt; &lt;value&gt;小普&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!-- map --&gt;&lt;property name="map"&gt; &lt;map&gt; &lt;entry key="aa" value=_lucy"&gt;&lt;/entry&gt; &lt;entry key="bb" value="mary"&gt;&lt;/entry&gt; &lt;entry key="cc" value="tom"&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/property&gt;&lt;!-- properties --&gt;&lt;property name="properties"&gt; &lt;props&gt; &lt;prop key="driverclass"&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key="username"&gt;root&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;/bean&gt; Spring的bean管理（注释）关于注解 代码里特殊的标记，使用注解可以完成功能 注解写法 @ 注解名称（属性名称=属性值） 注解使用在类、方法属性上面 注解开发准备 导入的基本包 导入jar包的时候要多一个sop的包 创建类、创建对象 在创建Spring配置文件，引入约束（1）做ioc基本功能，引入约束beans（2）做Spring的IOC注解发开，引入新的约束 开启注解扫描 注解创建对象 @Component：组件（作用在类上） 三个衍生注解 @ Controller：web层 @Service：业务层 @Repository :持久层目前这个四个功能差不多，只是为了区分用途，都是创建对象 创建是单实例还是多实例 @ scope（value=“prototype”） 注解注入属性第一个注解 @Autowired 创建service类，创建dao类 123@Service (value="userService") public class Userservice &#123;&#125; 12345678@Component (value="userDao") //注解里的value可以不写//写成Component("userService")也是可以的public class UserDao &#123; public void add() &#123; System.out.println("Dao----") &#125;&#125; 在service里面定义dao类型属性 123@Autowired private UserDao userDao; //使用注解的方法不需要set方法 注入属性第二个注解 @Resource123//name的属性值写注解创建dao对象，也就是写value值 @Resource(name="userDao") private UserDao userDao; Autowired和Resource的区别 @Resource默认按照名称方式进行bean匹配，@Autowired默认按照类型方式进行bean匹配,就是Autowired去匹配的时候是找类，不是名称，而Resource是按照名称来寻找。 Spring属于第三方的，J2EE是Java自己的东西。使用@Resource可以减少代码和Spring之间的耦合。 两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。 @Resource装配顺序：①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。 ②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。 ③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。 ④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。 配置文件和注解混合使用 在创建对象操作使用配置文件方式实现 1234&lt;!-- 配置对象 --&gt;&lt;bean id ="bookService" class="cn.itcast.xmlanno.BookService"&gt;&lt;/bean&gt;&lt;bean id ="ordersDao" class= "cn.itcast.xmlanno.OrdersDao"&gt;&lt;/bean&gt;&lt;bean id ="bookDao" class ="cn.itcast.xmlanno.BookDao"&gt;&lt;/bean&gt; 注入属性的操作使用注解方式实现 12345//得到bookdao和ordersdao的对象@Resource(name="bookDao")private BookDao bookDao; @Resource(name="ordersDao")private OrdersDao ordersDao; AOPAOP概念 aop：面向切面（方面）编程，扩展功能不修改源代码实现 AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码 AOP原理下图是最原始方法和纵向抽取机制解决方法 AOP：横向抽取机制底层使用动态代理方式实现看下图 AOP操作术语 Joinpoint(连接点):类里面可以被增强的方法，这些方法称为连接点 Pointcut(切入点):所谓切入点是指我们要对哪些Joinpoint进行拦截的定义. Advice(通知/增强):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) Aspect(切面):是切入点和通知（引介）的结合 Introduction(引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field. Target(目标对象):代理的目标对象(要增强的类) Weaving(织入):是把增强应用到目标的过程.把advice 应用到 target的过程 Proxy（代理）:一个类被AOP织入增强后，就产生一个结果代理类 AOP操作 在Spring里面进行AOP操作，使用aspectj实现 aspectj不是spring一部分，和spring一起使用进行aop操作 Spring2.0以后新增了对AspectJ支持 使用aspectj实现aop有两种方式 基于aspectj的xml配置 基于aspectj的注解方式 AOP操作准备（包含引入约束） 除了最基本的jar包，还需要导入跟AOP相关的jar包 spring-aop-4.2.2.RELEASE.jar spring-aspects-4.2.2.RELEASE.jar后两个是要另外下载，不在spring包里面 aspectjweaver-1.8.7.jar aopalliance-1.0.jar 创建spring核心配置文件，导入aop的约束 在docs文档里面查找AOP的约束 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- bean definitions here --&gt; &lt;/beans&gt; 使用表达式配置切入点 切入点：实际增强的方法 常用的表达式execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;) execution(* cn.itcast.aop.Book.add(..))匹配cn.itcast.aop.Book.add的方法，参数用..表示 execution( cn.itcast.aop.Book.(..))匹配所有cn.itcast.aop.Book.*中的方法 execution( .*(..))匹配所有类中的所有方法 匹配所有save开头的方法 execution( save(..)) AOP配置1234567891011121314151617181920&lt;!-- 配置对象 --&gt;&lt;bean id ="book" class = "cn.itcast.aop.Book" &gt;&lt;/bean&gt;&lt;bean id ="myBook" class ="cn.itcast.aop.MyBook"&gt;&lt;/bean&gt;&lt;!-- 2配置AOP操作 --&gt; &lt;aop:config&gt; &lt;!-- 2.1配置切入点 --&gt; &lt;aop:pointcut expression="execution(* cn.itcast.aop.Book.add(..))" id="pointcut1"/&gt; &lt;!-- 注意在表达式前面第一个修饰符 * 号的后面要加空格 id值可以随便写，相当于起名字 --&gt; &lt;!-- 2.2配置切面,把增强用到方法上面 --&gt; &lt;aop:aspect ref="myBook"&gt; &lt;!-- 配置增强类型 method:增强类里面选择哪个方法做前置 --&gt; &lt;aop:before method="before1" pointcut-ref="pointcut1"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 加入其他配置12public void around() &#123; System.out.println("环绕增强"); 12345&lt;aop:aspect ref="myBook"&gt; &lt;!-- 配置增强类型 method:增强类里面选择哪个方法做环绕 --&gt; &lt;aop:around method="around" pointcut-ref="pointcut1"/&gt; &lt;/aop:aspect&gt; 输出结果 ： 环绕增强 这种方法应该是属于替换了原来的方法，但是如果修改了around的参数的话，效果很不同，就真的是环绕如下12345public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println("环绕增强之前"); proceedingJoinPoint.proceed(); System.out.println("之后");&#125; 然后配置文件不变输出结果： 环绕增强之前 add---------Book.java 之后 log4jlog4j介绍 通过log4j可以看到程序运行过程中更详细的信息 经常使用log4j查看日志 使用方法 导入log4j的jar包 复制log4j的配置文件，复制到src下面配置文件：log4j.properties 其中log4j.properties的内容中 log4j.rootLogger=info, stdout 是代表了日志级别 设置日志级别 info：看到基本信息 debug：看到更详细信息 Spring整合web项目原理基础原理加载Spring核心配置文件 new对象，功能可以实现，但是效率很低 实现思想：把加载配置文件和创建对象过程，在服务器启动时完成 实现原理 serlvletContext 对象 监听器 具体使用（1）在服务器启动时，为每一个项目创建一个servletContext对象（2）在servletContext 对象创建时，可以用监听器具体到servletContext对象在什么时候创建。（3）当使用监听器听到servletContext对象创建的时候，加载spring配置文件，创建配置对象。（4）把创建出来的对象放到ServletContext域对象里面（setAttribute方法）（5）获取对象时候，到ServletContext域得到 （getAttribute方法） web项目演示 演示问题 action 调用service，service调用dao 每次访问action的时候，都会加载spring配置文件功能没问题，可是性能不行123456信息: Deployment of web application directory C:\Program Files\Java\apache-tomcat-7.0.90\webapps\manager has finished in 90 msaction..........21:09:55,491 INFO ClassPathXmlApplicationContext:578 - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@4a3ef897: startup date [Wed Jul 25 21:09:55 CST 2018]; root of context hierarchy21:09:55,492 INFO XmlBeanDefinitionReader:317 - Loading XML bean definitions from class path resource [applicationContext.xml]service..........dao.......... 解决方案 在服务器启动的时候，创建对象加载配置文件 底层使用监听器，servletContext对象 spring里面不需要我们自己写代码，已经封装好了，这就是使用框架的好处 封装了一个监听器，只需要配置监听器就可以了 配置监听器之前，导入spring整合web项目jar包spring-web-4.2.4.RELEASE.jar 12&lt;!-- 配置监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 指定加载spring配置文件，因为默认是找不到位置的。 123&lt;!-- 指定spring配置文件位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立自己的博客]]></title>
    <url>%2Fposts%2F43831.html</url>
    <content type="text"><![CDATA[前言&nbsp; 苦于一直没有一个良好的学习习惯，感觉自己进步的效率太低，用IPad Pro加apple pen来手写也不行，字丑写的慢，即使记下来了也丑的不想回头看了。一天看到同学用 markdown来做笔记，美观而且很有条例，就想着学习着来搭一个博客来做笔记。GitHub上面可以提供代码托管，可以把自己的网站托管到GitHub上面，这样自己的学习成果就能在上面记录下来了。希望这种学习方法能对自己有所帮助。 一、初步准备1.github账户2 .电脑安装node.js、npmnode.js的下载网站一路默认吧 3 .安装了git for windowsgit的下载链接 基本一直next就行 二、搭建github博客1 .注册github账号2 .需要建立一个仓库注意的是仓库名字必须和账号名字一样，如果账号是admin，仓库名字也必须一样。 3 .在setting里面找到options按钮&nbsp; 看看Repository name名字是否改为账号名称，必须一摸一样，不然后面的步骤没法做。&nbsp; 然后往下拉，找到GitHub Pages里的Theme Chooser，随便选择一个主题先，这样就会出现我们的GitHub Pages的地址。 三、安装hexo1 .利用npm命令先桌面右键选择 Git Bash Here输入命令 npm install -g hexo 2 .初始化hexo先在自己想管理hexo博客框架的地方创建文件夹比如在D盘根目录下创建hexo文件夹在Git Bash里面输入命令 cd D:/hexo 然后再输入 hexo init 进行初始化 3 .修改配置文件找到_config.yml文件，然后打开修改里面的设置。并在最后面添加配置 deploy: type: git repo: https://github.com/Shelhon/Shelhon.github.io.git branch: master 其中repo里面的网址是自己的github上面的网址 4 .获取好看的主题在github上面比较高分好评的是next在Git Bash上面运行命令获取 git clone https://github.com/iissnan/hexo-theme-nextthemes/next 然后输入命令 hexo g hexo s 打开本地 localhost:4000 的页面，如果出现页面就成功。 5 .创建文章Git Bash在hexo目录下，输入 new post &quot;文章名称（最好英文）&quot; 就会在 source_posts\下出现 文章名称.md 文件 四、Github上面部署网站1. 安装hexo-deployer-git输入命令 npm install hexo-deployer-git --save 2. 发布到Github输入命令： hexo clean ps:如果修改了配置，打算在本地服务器运行试看的话，就建议每次修改后都clean一下，不然可能生效不了 然后再输入命令： hexo d -g 在第一次部署的时候，会出现下图的验证 这时候打开GitHub网站我们能看到仓库上已经更新了文件 3. 访问测试在浏览器输入：https://(github账户名字).github.io 能出现网页就算大功告成了。 至于如何绑定一个私人域名以及在过程中有些遇到的坑留以后再写一下。]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇]]></title>
    <url>%2Fposts%2F18842.html</url>
    <content type="text"><![CDATA[什么也不写先放一只猫镇楼]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>心情随笔</tag>
      </tags>
  </entry>
</search>
