<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[struts2学习]]></title>
    <url>%2Fposts%2Fc240a0d6.html</url>
    <content type="text"><![CDATA[主要内容 stuts2入门 struts2数据操作 struts2值栈 struts2拦截器]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>学习</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 框架学习(二)]]></title>
    <url>%2Fposts%2F14042445.html</url>
    <content type="text"><![CDATA[大概内容 基于aspectj的注解aop操作 spring的jdbcTemplate操作 spring配置连接池 spring事务管理 基于aspectj的注解aop操作1. 使用注解方式创建aop操作 第一步 ：创建对象1&lt;!-- 1 配置对象 --&gt; &lt;bean id=&quot;book&quot; class=&quot;cn.shelhon.cn.shelhon.aop.Book&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;myBook&quot; class=&quot;cn.shelhon.cn.shelhon.aop.Book&quot;&gt; &lt;/bean&gt; 第二步 ：在spring核心配置文件里面开启AOP操作 1&lt;!-- 开启aop操作 --&gt; &lt;aop:aspectj-autoproxy&gt; &lt;/aop:aspectj-autoproxy&gt; 第三步 ： 在增强类上面使用注解完成aop操作 123@Aspect public class Mybook &#123; //在方法上面使用注解完成增强配置 @Before(value = &quot;execution(* cn.shelhon.aop.Book.*(..)&quot;) Spring的jdbcTemplate操作 实现crud操作 - 增加、修改、删除，调用模板update方法 - 查询某个值时候，调用queryForObject方法 - 自己写实现类封装数据 - 查询对象，调用queryForObject方法 - 查询list集合，调用query方法 spring框架一站式框架 针对javaee三层，每一层都有解决技术 在dao层，使用 jdbcTemplate spring对不同的持久化层技术都进行封装 其中jdbcTemplate对jdbc进行封装 jdbcTemplate使用和dbutils使用很相似，都数据库进行crud操作 增加 导入jdbcTemplate使用的jar包 创建对象，设置数据库信息 创建JdbcTemplate对象，设置数据源 调用jdbcTemplate对象里面的方法 操作的时候，记得还要导入驱动数据库的jar包 1234567891011121314151617181920212223// 添加操作 @Test public void add()&#123; //创建对象，设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("conm.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://test"); dataSource.setUsername("root"); dataSource.setPassword("12345"); // 创建JdbcTemplate对象，设置数据源 JdbcTemplate jdbcTempalate = new JdbcTemplate(dataSource); //调用jdbcTemplate对象里面的方法 String sql = "insert into user value(?,?)"; int rows = jdbcTempalate.update(sql,"lucy","22"); System.out.println(rows); &#125; 特别要注意的是，在运行的时候报错出现的问题1org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Unknown character set index for field &apos;255&apos; received from server. 这个问题是由于我使用的数据库版本比较新，导致旧的mysql-connector-java的版本使用的时候报错。(1) MYSQL 5.5 之前， UTF8 编码只支持1-3个字节;从MYSQL5.5开始，可支持4个字节UTF编码utf8mb4;如emoji表情需要使用utf8mb4 (2) 如果服务器级使用的编码是utf8mb4(在客户端链接后使用sql语句show variables like ‘char%’可查看所有编码)，而mysql的jar包低版本不支持utf8mb4,连接时报错”Unknown character set index for field ‘224’ received from server.” (3) 建议使用mysql-connector-java-5.1.30-bin.jar (4) 注意：如果数据库不支持utf8mb4，使用mysql-connector-java-5.1.30-bin.jar的jar包时则会报错，此时应该使用低版本的jar包。 然后这个时候我又用了最新版本的mysql-connector的jar包又报错1java.lang.UnsupportedClassVersionError: com/mysql/jdbc/Driver : Unsupported major.minor version 52.0 这种问题是jdk版本和mysql数据库版本不兼容从网上寻找的答案有如下： 1、jdk7+老版5.0驱动com/mysql/jdbc/Driver 2、jdk8+新版6.0驱动com/mysql/cj/jdbc/Driver 所以就是最新的jar是不能跟jdk1.7搭配使用的。最后解决问题的是这样的搭配 jdk1.7.0_80 mysql-connector-java 5.1.46 spring-jdbc 4.2.4.RELEASE 更新更新的方法跟增加差不多。 1234//调用jdbcTemplate对象里面的方法 String sql = "update user set password=? where name=?"; int rows = jdbcTemplate.update(sql,"lucy","99"); System.out.println(rows); 删除删除也是同理1234//调用jdbcTemplate对象里面的方法 String sql = "delete from user where name=?"; int rows = jdbcTemplate.update(sql,"null"); System.out.println(rows); 查询1、查询表中有多少记录12345// 创建JdbcTemplate对象，设置数据源JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);String sql = "select count(*) from user";int count =jdbcTemplate.queryForObject(sql,Integer.class);System.out.println(count); &#125; 2、查询返回对象jdbc底层原理12345678910111213141516171819202122232425262728293031323334353637383940@Test public void testJDBC()&#123;Connection conn = null;PreparedStatement psmt =null;ResultSet rs = null;try &#123; Class.forName("com.mysql.jdbc.Driver");//创建连接conn = DriverManager.getConnection("jdbc:mysql:///test", "root", "12345");//编写sql语句String sql = "select * from user where name =?";//预编译sql语句psmt = conn.prepareStatement(sql);//设置参数值psmt.setString(1, "lucy");//遍历结果集rs =psmt.executeQuery(); while(rs.next())&#123; //得到返回值String username =rs.getString("name");String password = rs.getString("password"); //放到User对象里面User user =new User();user.setUsername(username);user.setPassword(password);System.out.println(user); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try&#123; rs.close();psmt.close();conn.close();; &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125; &#125;&#125; User.java代码123456789101112131415161718192021222324252627282930package cn.shelhon.jdbc; public class User &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public String getPassword() &#123; return password; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User&#123;" + "username='" + username + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 具体的实现1234567891011121314151617181920212223242526272829@Test public void testObject()&#123; //创建对象以及设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql:///test"); dataSource.setUsername("root"); dataSource.setPassword("12345"); // 创建JdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); //写sql语句，根据name来查询 String sql ="select * from user where name = ?"; //调用jdbctempla的方法实现 //第二个参数是接口ROWMapper，需要自己写个类,自己做数据封装 User user=jdbcTemplate.queryForObject(sql,new MyRowMapper(),"rose"); System.out.println(user); &#125;&#125;class MyRowMapper implements RowMapper&lt;User&gt;&#123; public User mapRow(ResultSet rs, int i) throws SQLException &#123; //从结果集里把数据拿到 String username = rs.getString("name"); String password = rs.getString("password"); //把得到的数据封装到对象里面 User user = new User(); user.setUsername(username); user.setPassword(password); return user; &#125;&#125; 3、查询返回list集合1234567891011121314@Test public void testList()&#123; //创建对象以及设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql:///test"); dataSource.setUsername("root"); dataSource.setPassword("12345"); // 创建JdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); //写sql语句，根据name来查询 String sql ="select * from user"; //调用jdbctempla的方法实现 //第二个参数是接口ROWMapper，需要自己写个类,自己做数据封装List&lt;User&gt; list =jdbcTemplate.query(sql,new MyRowMapper()); System.out.println(list); &#125; Spring配置连接池配置c3p0连接池 导入jar包c3p0-0.9.2.1mchange-commons-java-0.2.3.4 创建spring文件，建立连接池 12345&lt;!-- 配置c3p0连接池 --&gt; &lt;bean id =&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 注入属性值--&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt; &lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;dbc:mysql:///test&quot;&gt; &lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt; &lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;12345&quot;&gt; &lt;/property&gt; &lt;/bean&gt; dao使用jdbcTemplate 创建service和dao，配置service和dao对象，在service注入dao对象 1234&lt;bean id=&quot;userService&quot; class=&quot;cn.shelhon.c3p0.UserService&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;cn.shelhon.c3p0.UserDao&quot;&gt;&lt;/bean&gt; 创建jdbcTemplate对象，把模板对象注入到dao里面创建对象12345private JdbcTemplate jdbcTemplate; //添加操作public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; 注入dao里面123&lt;bean id=&quot;userDao&quot; class=&quot;cn.shelhon.c3p0.UserDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt; &lt;/property&gt;&lt;/bean&gt; 在jdbcTemplate对象里面注入dataSource 1234&lt;!-- 创建JdbcTemplate对象 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 把datasource传递到模板对象里面 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt; &lt;/property&gt; &lt;/bean&gt; 关于数据库语句因为我的表里用了主键，在插入新的数据的时候12String sql ="insert into user values(?,?)"; jdbcTemplate.update(sql,"李峰","asd"); 按照这语法就报错了 后来改这样就通过了12String sql="insert into user(id,name,password) values(null,?,?)"; jdbcTemplate.update(sql,"李峰","asd"); Spring事务管理事务概念 什么是事务Spring事务 的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。 理解事务之前，先讲一个你日常生活中最常干的事：取钱。比如你去ATM机取1000块钱，大体有两个步骤：首先输入密码金额，银行卡扣掉1000元钱；然后ATM出1000元钱。这两个步骤必须是要么都执行要么都不执行。如果银行卡扣除了1000块但是ATM出钱失败的话，你将会损失1000元；如果银行卡扣钱失败但是ATM却出了1000块，那么银行将损失1000元。所以，如果一个步骤成功另一个步骤失败对双方都不是好事，如果不管哪一个步骤失败了以后，整个取钱过程都能回滚，也就是完全取消所有操作的话，这对双方都是极好的。事务就是用来解决类似问题的。事务是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。在企业级应用程序开发中，事务管理必不可少的技术，用来确保数据的完整性和一致性。 事务特性：四大特性(简称ACID) 原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 一致性（Consistency）：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 隔离性（Isolation）:隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 持久性（Durability）:持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 不考虑隔离性产生读问题 脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。 不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。 虚读(幻读)： 幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 解决读问题 设置隔离级别数据库给力级别： ① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 ② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。 ③ Read committed (读已提交)：可避免脏读的发生。 ④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 spring进行事务管理apispring事务管理有两种方法 编程式事务管理（一般不用） 声明式事务管理： 基于xml配置文件实现 基于注解实现 spring事务管理的api介绍spring事务管理高层抽象主要包括3个接口 PlatformTransactionManager事务管理器 TransactionDefinition事务定义信息（隔离、传播、超时、只读） TransactionStatus事务具体运行状态 其中spring针对不同的dao层框架，提供不同的实现类比如： org.springframework.jdbc.datasource.DataSourceTransactionManager是使用springJDBC或者iBatis进行持久化数据时使用。 org.springframework.orm.hibernate5.HibernateTransactionManager使用Hiber5版本进行持久化数据时使用 搭建转账环境首先配置事务管理器 创建数据库的表，添加数据 创建service类和dao类，完成注入关系。 12345678910111213&lt;bean id=&quot;ordersService&quot; class=&quot;cn.shelhon.service.OrdersService&quot;&gt; &lt;property name=&quot;ordersDao&quot; ref=&quot;ordersDao&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id=&quot;ordersDao&quot; class=&quot;cn.shelhon.Dao.OrdersDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; service层又叫业务逻辑层 dao层，单独对数据库操作层，在dao层不添加业务 比较齐全的约束 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;&lt;/beans&gt; 需求甲 转账给 乙 1000甲 少 1000乙 多 1000 先在dao层写操作数据库的方法12345678910111213141516public class OrdersDao &#123; //注入jdbcTemplate模板 private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; //提供对数据库操作的方法，不写业务操作 // 少钱的方法 public void lessMoney()&#123; String sql ="update account set salary=salary-? where name = ?"; jdbcTemplate.update(sql,1000,"甲"); &#125; // 加钱的方法 public void addMoney()&#123; String sql ="update account set salary=salary+? where name =?"; jdbcTemplate.update(sql,1000,"乙"); &#125;&#125; 然后再service层调用dao层写业务逻辑123456789101112public class OrdersService &#123; private OrdersDao ordersDao; public void setOrdersDao(OrdersDao ordersDao) &#123; this.ordersDao = ordersDao; &#125; //调用dao的方法 //业务逻辑层，写转账业务 public void accountMoney()&#123; // 甲少1000 ordersDao.lessMoney();; // 乙多1000 ordersDao.addMoney(); &#125;&#125; 产生的问题 ： 如果甲扣钱了以后，出现异常，乙的钱并没有增加，钱丢失了 解决： -添加事务解决，出现异常进行回滚操作 spring进行事务配置（声明式）基于xml配置文件 配置文件使用aop思想 12345&lt;!-- 第一步配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入datasource --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt; &lt;/property&gt; &lt;/bean&gt; 配置事务的增强 1234567&lt;!-- 第二步 配置事务增强 --&gt; &lt;tx:advice id =&quot;txadvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 做事务操作 --&gt; &lt;tx:attributes&gt; &lt;!-- 设置进行事务操作的方法匹配规则 --&gt; &lt;tx:method name=&quot;account*&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 配置切面 1234567&lt;!-- 第三步 --&gt; &lt;!-- 配置切面 --&gt; &lt;aop:config&gt; &lt;!-- 切入点 --&gt; &lt;aop:pointcut expression =&quot;execution(* cn.shelhon.service.OrdersService.*(..))&quot; id = &quot;pointcut1&quot;/&gt; &lt;!--切面--&gt; &lt;aop:advisor advice-ref=&quot;txadvice&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:config&gt; 经过上面的配置以后，出现异常就能自动回滚操作 基于注解方式 第一步也是要先配置事务管理器 1234&lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;dataSourceTransactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt; &lt;/property&gt;&lt;/bean&gt; 配置事务注解 1&lt;!-- 开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;dataSourceTransactionManager&quot;/&gt; 要在使用事务的方法所在类上添加注解 12345678910111213141516@Transactional public class OrdersService &#123; private OrdersDao ordersDao; public void setOrdersDao(OrdersDao ordersDao) &#123; this.ordersDao = ordersDao; &#125; //调用dao的方法 //业务逻辑层，写转账业务 public void accountMoney()&#123; // 甲少1000 ordersDao.lessMoney();; //出现异常 // int i =10/0; // 乙多1000 ordersDao.addMoney(); &#125;&#125;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>学习</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用IDEA遇到的问题记录]]></title>
    <url>%2Fposts%2Fada285ba.html</url>
    <content type="text"><![CDATA[人可以做他想做的，但不能要他想要的 记录在使用idea的过程中遇到的问题 比如 配置环境遇到的问题 导入jar包 依赖 maven Tomcat jdk和jar包版本的问题 将会比较随意的记录 配置环境说到底原本最初是用idea，后来实习公司又要用eclipse，不怎么熟悉这个开发工具，本来就艰难，jdk就用一开始的1.8版本jdk，结果按照公司要求用回jdk1.7和Tomcat1.7的时候，eclipse就无法打开了。因为photon不支持1.8以下的版本。果断回头idea。 关于那个新建项目以后的文件目录格式，可以创建后自己修改。不用太纠结位置。 在创建项目以后，可以再创建模块，一个模块就相当于原来eclipse里面的项目。 在idea里面移除模块以后，不会删除本地硬盘里的文件，如果需要再导入这个模块进入项目里面的话，就找到 xxxx.iml文件，然后导入就会自动加载原来的那个模块了。 在运行的过程中，试过出现以下报错 1org.springframework.beans.factory.BeanDefinitionStoreException: IOException parsing XML document from class path resource [applicationContext.xml]; nested exception is java.io.FileNotFoundException: class path resource [applicationContext.xml] cannot be opened because it does not exist 最后是把applicationContext.xml放入resources文件夹里才成功。包括什么log4j.properties等这类型的文件都是要放进去才能生效。 导入jar包要注意框架的版本，因为不同版本，可能jar包就取消了，或者集合在一起了，这个必须得注意。 配置依赖以后补 maven在配置好系统环境变量以后在idea里的setting里设置maven的东西比如默认读取setting.xml的位置和仓库的位置因为idea自带的maven和我们自己安装位置的会不同 新建的时候就对着模块右键，选择添加框架支持 在里面找到maven然后直接新建就行。 创建pom.xml后好像会提示更新目录什么的，让idea来完成就好 默认的pom.xml里面需要我们自己去添加依赖，但是文件里会少了一些代码 &lt;dependencies&gt; #中间这里把maven依赖网站上面的配置自己找下来，复制上去就行 &lt;/dependencies&gt; 如果要移除依赖的话，直接删除pom.xml就可以了，同时idea会自动调整目录结构的 使用过程中，如果发现项目没有添加依赖，那么在项目结构中，找到这个项目的依赖，然后删除重新导入。 maven的依赖查询网站 ：http://mvnrepository.com/ 在idea右侧的工具栏里是可以找到maven插件的，通过这个可以很快查看每个项目的依赖。 Tomcat tomcat1.7版本不支持xml3.0以上的版本 然而idea创建web.xml的时候基本默认是4.0版本 可以通过修改web.xml里面的版本数字来直接改变，改成3就行]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>IDEA</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 框架学习]]></title>
    <url>%2Fposts%2F46958.html</url>
    <content type="text"><![CDATA[spring框架的介绍&nbsp; Spring框架是一个轻量级的控制反转（IOC）和面向切面（AOP）的容器框架。 &nbsp; 记录了一些关于框架特点和特性以及Spring工作流程图。比如：IOC 、AOP的底层原理，属性注入，注解，bean管理 一、 一些基本特性 轻量：大小与开销轻量级，完整的spring框架可以在大小只有1MB多的JAR文件中发布，且spring框架是非侵入式的，spring应用不依赖于spring特定类。控制反转：Spring通过一种称为控制反转的（IOC）的技术促进松耦合。当应用了IOC，一个对象依赖的其他对象通过被动的方式传递进来，而不是对象自己创建或者查找依赖对象。不是对象从容器中查找依赖，而是容器在对象初始化的不等对象请求就主动依赖传递过去.把对象的创建不是通过new方式，而是交给spring配置创建类对象。面向切面：Spring提供面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发（AOP）。容器：Spring包含并管理应用对象的配置和生命周期，可以配置每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以可以创建一个单独的实例，或每次需要都生成一个新的实例——以及他们是如何相互关联。框架：Spring框架可以将简单的组件配置，组合成为复杂的应用。在Spring应用对象被声明组合，典型是在一个XML文件里面，Spring也提供许多基础功能（事务管理，持久化框架集成，自己开发应用逻辑） 二、 Spring流程图 解析：这个图在Struts结构图的基础上加了spring流程图，在web.xml配置文件中加入了spring监听器，在Struts配置文件中添加是告知Struts2运行的时候使用spring来创建对象，spring在其中要做就是注入实例，将所有需要类的实例都由spring管理。 三、 深入了解Spring是一站式框架spring在Javaee三层结构： 每一层都提供不同的解决技术。 web层：SpringMVC service层：Spring的IOC DAO层：Spring的jdbcTemplate 该笔记的学习是基于spring4.x版本 业精于勤 ，荒于嬉；行成于思，毁于随 spring的IOC操作把对象创建交给spring进行管理ioc操作两部分： （1）IOC的配置文件方式 （2）IOC的注解方式 IOC的底层原理 xml配置文件 dom4j解决xml 工厂设计模式 反射 1234567public class UserService&#123;&#125;public class UserServlet&#123; //得到UserServlet的对象 //原始：new创建 uersFactory.getService();&#125; 第一步 创建xml配置文件，配置要创建对象类 &lt;bean id =&quot;userService&quot; class=&quot;cn.itcast.Userservice&quot;/&gt; 第三步 创建工厂类，使用dom4j解析配置+反射123456789101112public class Userfacorty&#123; //返回UserService对象的方法&#125;public static UserService getService()&#123; //使用dom4j解析xml文件 //根据id值userService,得到id值对应class属性值 String class = "class属性值"; class clazz= class.forname(classValue); //创建类对象 Userservice service =clazz.newInstance(); return service;&#125; 在创建spring配置文件的时候注意，spring核心配置和位置不是固定的，建议放到src下面，官方建议的名称叫applicationContext.xml 配置的时候引入schema约束可以在docs文档 →spring-framenwork-reference →html里找最后一个configuration.xsd里有 IOC和DI的区别 IOC：控制反转，把对象创建交给spring进行配置 DI ：依赖注入，向类里面的属性中设置值 关系：依赖注入不能单独存在，需要在IOC的基础上完成操作的。 Spring的Bean管理（XML配置文件）Bean实例化的三种方式使用类的无参数构造创建12&lt;!-- ioc入门 --&gt; &lt;bean id =&quot;user&quot; class=&quot;cn.itcast.ioc.User&quot;&gt;&lt;/bean&gt; 如果类里面没有无参数的构造，就会出现异常 使用静态工厂创建创建类的方法，返回类的对象123456public class Bean2Factory&#123; //静态方法，返回Bean2对象 public static Bean2 getBean2()&#123; return new Bean2(); &#125;&#125; 12&lt;!-- 使用静态工厂创建对象 --&gt;&lt;bean id=&quot;bean2&quot; class=&quot;cn.itcast.bean.Bean2Factory&quot; factory-method=&quot;getBean2&quot;&gt; 使用实例工厂创建创建不是静态的方法，返回类对象 123456public class Bean3Factory&#123; //普通的方法。返回bean3对象 public Bean3 getBean3()&#123; return new Bean3(); &#125;&#125; Bean的常用标签id属性起名称，不能包含特殊符号根据id值得到配置对象 class属性创建对象所在类的全路径 name属性根据属性值得到配置对象但在name属性里可以包含特殊符号现在不怎么用，都是旧版本的遗留问题 scope属性 singleton：默认值，单例 prototype：多例 request：创建对象把对象放到request域里面 session：创建对象把对象放到session域里面 globalSession：创建对象把对象放到globalSession里面 属性注入介绍创建对象的时候，向类里面属性设置值属性注入的三种方式 使用set方法123456public class User&#123; private String name; public void setName(String name)&#123; this.name = name; &#125;&#125; 12User user =new User();user.setName("abcd"); 使用有参数的结构注入123456public class User&#123; private String name; public User(String name)&#123; this.name = name; &#125;&#125; 1User user =new User("lucy"); 使用接口注入123public interface Dao&#123; public void delete(String name);&#125; 123456public class DaoImpl implements Dao&#123; private String name; public void delete (String name)&#123; this.name = name; &#125;&#125; 注意的地方在spring框架里面，支持前两种方式 set方法注入（重点） 有参数结构注入 使用有参数构造注入属性 1234&lt;!-- 使用有参数构造注入属性 --&gt;&lt;bean id =&quot;demo&quot; class =&quot;cn.itcast.property.PropertyDemo1&quot;&gt;&lt;!-- 使用有参数构造注入 --&gt;&lt;constructor-arg name=&quot;username&quot; value =&quot;tom&quot;&gt;&lt;/constructor-arg&gt; 1234567private String name ;public PropertyDemo1(String user name)&#123; this.username =username;&#125;public void test1&#123; System.out.println("demo1----"+username);&#125; 使用set方法注入属性（重点）12345private String bookname;//set 方法public void setBookname(String bookname)&#123; this.bookname =bookname;&#125; 1234567&lt;!-- 使用set方法注入属性 --&gt;&lt;bean id =&quot;book&quot; class =&quot;cn.itcast.property.Book&quot;&gt; &lt;!-- 注入属性 name属性值，类里面定义的属性名称 value属性：设置属性的值 --&gt; &lt;property name =&quot;bookname&quot; value =&quot;hamlet&quot;&gt;&lt;/property&gt; 注入 对象类型 属性（重点）创建service类和dao类 在service得到dao对象 具体的实现过程 在service 里面把dao作为类型属性 生成dao类型属性的set方法 12345678public class UserService&#123; //1定义dao类型属性 private UserDao userDao; //2生成set方法 public void setUserDao(UserDao userDao)&#123; this.userDao =userDao; &#125;&#125; 配置文件中注入关系123456789&lt;!-- 1配置service和dao对象 --&gt;&lt;bean id = &quot;userDao&quot; class =&quot;cn.itcast.ioc.UserDao&quot;&gt;&lt;/bean&gt;&lt;bean id= &quot;userService&quot; class =&quot;cn.itcast.ioc.Userservice&quot;&gt;&lt;!-- 注入dao对象name属性值：service类里面属性名称但是现在不要写value属性，因为之前的是字符串，现在是对象 。写ref属性：dao配置中的bena标签的id值--&gt;&lt;property name =&quot;userDao&quot; ref =&quot;userDao&quot;&gt;&lt;/property&gt; P名称空间注入修改配置文件，加入下面这一条 xmls : p =&quot;http://www.spring.framework.org/schema/p&quot; 然后再加入这条 &lt;!-- P名称空间注入 --&gt; &lt;bean id =&quot;person&quot; class= &quot;cn.itcast.property.Person&quot; p :name=&quot;Lucy&quot;&gt; 注入复杂类型属性 数组 list集合 map集合 properties类型123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- 注入复杂类型属性 --&gt;&lt;bean id = &quot;person&quot; class =&quot;cn.itcast.property.Person&quot;&gt;&lt;!-- 数组 --&gt;&lt;property name=&quot;arrs&quot;&gt; &lt;list&gt; &lt;value&gt;小王&lt;/value&gt; &lt;value&gt;小马&lt;/value&gt; &lt;value&gt;小宋&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!-- list --&gt;&lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;小奥&lt;/value&gt; &lt;value&gt;小金&lt;/value&gt; &lt;value&gt;小普&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!-- map --&gt;&lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;aa&quot; value=_lucy&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;bb&quot; value=&quot;mary&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;cc&quot; value=&quot;tom&quot;&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/property&gt;&lt;!-- properties --&gt;&lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driverclass&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;/bean&gt; Spring的bean管理（注释）关于注解 代码里特殊的标记，使用注解可以完成功能 注解写法 @ 注解名称（属性名称=属性值） 注解使用在类、方法属性上面注解开发准备 导入的基本包 导入jar包的时候要多一个sop的包 创建类、创建对象 在创建Spring配置文件，引入约束（1）做ioc基本功能，引入约束beans（2）做Spring的IOC注解发开，引入新的约束 开启注解扫描 注解创建对象 @Component：组件（作用在类上） 三个衍生注解 @ Controller：web层 @Service：业务层 @Repository :持久层目前这个四个功能差不多，只是为了区分用途，都是创建对象 创建是单实例还是多实例 @ scope（value=“prototype”） 注解注入属性第一个注解 @Autowired 创建service类，创建dao类123@Service (value="userService") public class Userservice &#123;&#125; 12345678@Component (value="userDao") //注解里的value可以不写//写成Component("userService")也是可以的public class UserDao &#123; public void add() &#123; System.out.println("Dao----") &#125;&#125; 在service里面定义dao类型属性123@Autowired private UserDao userDao; //使用注解的方法不需要set方法 注入属性第二个注解 @Resource123//name的属性值写注解创建dao对象，也就是写value值 @Resource(name="userDao") private UserDao userDao; Autowired和Resource的区别 @Resource默认按照名称方式进行bean匹配，@Autowired默认按照类型方式进行bean匹配,就是Autowired去匹配的时候是找类，不是名称，而Resource是按照名称来寻找。 Spring属于第三方的，J2EE是Java自己的东西。使用@Resource可以减少代码和Spring之间的耦合。 两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。 @Resource装配顺序：①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。 ②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。 ③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。 ④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。 配置文件和注解混合使用 在创建对象操作使用配置文件方式实现 1234&lt;!-- 配置对象 --&gt;&lt;bean id =&quot;bookService&quot; class=&quot;cn.itcast.xmlanno.BookService&quot;&gt;&lt;/bean&gt;&lt;bean id =&quot;ordersDao&quot; class= &quot;cn.itcast.xmlanno.OrdersDao&quot;&gt;&lt;/bean&gt;&lt;bean id =&quot;bookDao&quot; class =&quot;cn.itcast.xmlanno.BookDao&quot;&gt;&lt;/bean&gt; 注入属性的操作使用注解方式实现 12345//得到bookdao和ordersdao的对象@Resource(name="bookDao")private BookDao bookDao; @Resource(name="ordersDao")private OrdersDao ordersDao; AOPAOP概念 aop：面向切面（方面）编程，扩展功能不修改源代码实现 AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码 AOP原理下图是最原始方法和纵向抽取机制解决方法 AOP：横向抽取机制底层使用动态代理方式实现看下图 AOP操作术语 Joinpoint(连接点):类里面可以被增强的方法，这些方法称为连接点 Pointcut(切入点):所谓切入点是指我们要对哪些Joinpoint进行拦截的定义. Advice(通知/增强):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) Aspect(切面):是切入点和通知（引介）的结合 Introduction(引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field. Target(目标对象):代理的目标对象(要增强的类) Weaving(织入):是把增强应用到目标的过程.把advice 应用到 target的过程 Proxy（代理）:一个类被AOP织入增强后，就产生一个结果代理类 AOP操作 在Spring里面进行AOP操作，使用aspectj实现 aspectj不是spring一部分，和spring一起使用进行aop操作 Spring2.0以后新增了对AspectJ支持 使用aspectj实现aop有两种方式 基于aspectj的xml配置 基于aspectj的注解方式 AOP操作准备（包含引入约束） 除了最基本的jar包，还需要导入跟AOP相关的jar包 spring-aop-4.2.2.RELEASE.jar spring-aspects-4.2.2.RELEASE.jar后两个是要另外下载，不在spring包里面 aspectjweaver-1.8.7.jar aopalliance-1.0.jar 创建spring核心配置文件，导入aop的约束 在docs文档里面查找AOP的约束 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- bean definitions here --&gt; &lt;/beans&gt; 使用表达式配置切入点 切入点：实际增强的方法 常用的表达式execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;) execution(* cn.itcast.aop.Book.add(..))匹配cn.itcast.aop.Book.add的方法，参数用..表示 execution( cn.itcast.aop.Book.(..))匹配所有cn.itcast.aop.Book.*中的方法 execution( .*(..))匹配所有类中的所有方法 匹配所有save开头的方法 execution( save(..)) AOP配置1234567891011121314151617181920&lt;!-- 配置对象 --&gt;&lt;bean id =&quot;book&quot; class = &quot;cn.itcast.aop.Book&quot; &gt;&lt;/bean&gt;&lt;bean id =&quot;myBook&quot; class =&quot;cn.itcast.aop.MyBook&quot;&gt;&lt;/bean&gt;&lt;!-- 2配置AOP操作 --&gt; &lt;aop:config&gt; &lt;!-- 2.1配置切入点 --&gt; &lt;aop:pointcut expression=&quot;execution(* cn.itcast.aop.Book.add(..))&quot; id=&quot;pointcut1&quot;/&gt; &lt;!-- 注意在表达式前面第一个修饰符 * 号的后面要加空格 id值可以随便写，相当于起名字 --&gt; &lt;!-- 2.2配置切面,把增强用到方法上面 --&gt; &lt;aop:aspect ref=&quot;myBook&quot;&gt; &lt;!-- 配置增强类型 method:增强类里面选择哪个方法做前置 --&gt; &lt;aop:before method=&quot;before1&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 加入其他配置12public void around() &#123; System.out.println("环绕增强"); 12345&lt;aop:aspect ref=&quot;myBook&quot;&gt; &lt;!-- 配置增强类型 method:增强类里面选择哪个方法做环绕 --&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:aspect&gt; 输出结果 ： 环绕增强 这种方法应该是属于替换了原来的方法，但是如果修改了around的参数的话，效果很不同，就真的是环绕如下12345public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println("环绕增强之前"); proceedingJoinPoint.proceed(); System.out.println("之后");&#125; 然后配置文件不变输出结果： 环绕增强之前 add---------Book.java 之后 log4jlog4j介绍 通过log4j可以看到程序运行过程中更详细的信息 经常使用log4j查看日志 使用方法 导入log4j的jar包 复制log4j的配置文件，复制到src下面配置文件：log4j.properties 其中log4j.properties的内容中 log4j.rootLogger=info, stdout 是代表了日志级别 设置日志级别 info：看到基本信息 debug：看到更详细信息 Spring整合web项目原理基础原理加载Spring核心配置文件 new对象，功能可以实现，但是效率很低 实现思想：把加载配置文件和创建对象过程，在服务器启动时完成 实现原理 serlvletContext 对象 监听器 具体使用（1）在服务器启动时，为每一个项目创建一个servletContext对象（2）在servletContext 对象创建时，可以用监听器具体到servletContext对象在什么时候创建。（3）当使用监听器听到servletContext对象创建的时候，加载spring配置文件，创建配置对象。（4）把创建出来的对象放到ServletContext域对象里面（setAttribute方法）（5）获取对象时候，到ServletContext域得到 （getAttribute方法） web项目演示 演示问题 action 调用service，service调用dao 每次访问action的时候，都会加载spring配置文件功能没问题，可是性能不行123456信息: Deployment of web application directory C:\Program Files\Java\apache-tomcat-7.0.90\webapps\manager has finished in 90 msaction..........21:09:55,491 INFO ClassPathXmlApplicationContext:578 - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@4a3ef897: startup date [Wed Jul 25 21:09:55 CST 2018]; root of context hierarchy21:09:55,492 INFO XmlBeanDefinitionReader:317 - Loading XML bean definitions from class path resource [applicationContext.xml]service..........dao.......... 解决方案 在服务器启动的时候，创建对象加载配置文件 底层使用监听器，servletContext对象 spring里面不需要我们自己写代码，已经封装好了，这就是使用框架的好处 封装了一个监听器，只需要配置监听器就可以了 配置监听器之前，导入spring整合web项目jar包spring-web-4.2.4.RELEASE.jar 12&lt;!-- 配置监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 指定加载spring配置文件，因为默认是找不到位置的。 123&lt;!-- 指定spring配置文件位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>学习</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立自己的博客]]></title>
    <url>%2Fposts%2F43831.html</url>
    <content type="text"><![CDATA[前言&nbsp; 苦于一直没有一个良好的学习习惯，感觉自己进步的效率太低，用IPad Pro加apple pen来手写也不行，字丑写的慢，即使记下来了也丑的不想回头看了。一天看到同学用 markdown来做笔记，美观而且很有条例，就想着学习着来搭一个博客来做笔记。GitHub上面可以提供代码托管，可以把自己的网站托管到GitHub上面，这样自己的学习成果就能在上面记录下来了。希望这种学习方法能对自己有所帮助。 一、初步准备1.github账户2 .电脑安装node.js、npmnode.js的下载网站一路默认吧 3 .安装了git for windowsgit的下载链接 基本一直next就行 二、搭建github博客1 .注册github账号2 .需要建立一个仓库注意的是仓库名字必须和账号名字一样，如果账号是admin，仓库名字也必须一样。 3 .在setting里面找到options按钮&nbsp; 看看Repository name名字是否改为账号名称，必须一摸一样，不然后面的步骤没法做。&nbsp; 然后往下拉，找到GitHub Pages里的Theme Chooser，随便选择一个主题先，这样就会出现我们的GitHub Pages的地址。 三、安装hexo1 .利用npm命令先桌面右键选择 Git Bash Here输入命令 npm install -g hexo 2 .初始化hexo先在自己想管理hexo博客框架的地方创建文件夹比如在D盘根目录下创建hexo文件夹在Git Bash里面输入命令 cd D:/hexo 然后再输入 hexo init 进行初始化 3 .修改配置文件找到_config.yml文件，然后打开修改里面的设置。并在最后面添加配置 deploy: type: git repo: https://github.com/Shelhon/Shelhon.github.io.git branch: master 其中repo里面的网址是自己的github上面的网址 4 .获取好看的主题在github上面比较高分好评的是next在Git Bash上面运行命令获取 git clone https://github.com/iissnan/hexo-theme-nextthemes/next 然后输入命令 hexo g hexo s 打开本地 localhost:4000 的页面，如果出现页面就成功。 5 .创建文章Git Bash在hexo目录下，输入 new post &quot;文章名称（最好英文）&quot; 就会在 source_posts\下出现 文章名称.md 文件 四、Github上面部署网站1. 安装hexo-deployer-git输入命令 npm install hexo-deployer-git --save 2. 发布到Github输入命令： hexo clean ps:如果修改了配置，打算在本地服务器运行试看的话，就建议每次修改后都clean一下，不然可能生效不了 然后再输入命令： hexo d -g 在第一次部署的时候，会出现下图的验证 这时候打开GitHub网站我们能看到仓库上已经更新了文件 3. 访问测试在浏览器输入：https://(github账户名字).github.io 能出现网页就算大功告成了。 至于如何绑定一个私人域名以及在过程中有些遇到的坑留以后再写一下。]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇]]></title>
    <url>%2Fposts%2F18842.html</url>
    <content type="text"><![CDATA[什么也不写先放一只猫镇楼]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>心情随笔</tag>
      </tags>
  </entry>
</search>
