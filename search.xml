<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[struts2学习(二）]]></title>
    <url>%2Fposts%2F3a01fcdf.html</url>
    <content type="text"><![CDATA[主要内容 struts2值栈struts2拦截器 struts2值栈ognl概述 EL表达式在jsp中获取域对象里面的值 OGNL也是一种表达式，这个表达式功能更加强大（1）在struts2里面操作值栈数据（2）一般把ognl在struts2操作：和struts2标签一起使用操作值栈 OGNL不是struts2的一部分，单独的项目，经常和struts2一起使用（1）使用ognl时候首先导入jar包，struts2提供jar包 OGNL入门案例 使用ognl+struts2标签实现计算字符串长度支持对象方法调用，比如objName.methodName()在Java代码中，调用字符串length() 使用struts2标签 （1）使用jstl时候，导入jar包之外，在jsp页面中引入标签库使用struts2标签时候，在jsp中引入标签库 &lt;%@ taglib prefix=”s” uri=”/struts-tags” %&gt; （2）使用struts2标签实现操作1&lt;!-- 使用ognl加struts2标签实现计算字符串长度 --&gt; &lt;s:property value=&quot;&apos;asdasd&apos;.length()&quot;/&gt; 什么是值栈 之前在web阶段，在servlet里面进行操作，把数据放到域对象里面，在页面中使用el表达式获取到，域对象在一定范围内，存值和取值 在struts2里面提供本身一种存储机制，类似于域对象，是值栈，可以存值和取值（1）在action里面把数据放到值栈里面，在页面中获取到值栈数据 servlet和action区别（1）Servlet：默认在第一次访问时候创建，创建一次，单实例对象（2）Action：访问时候创建，每次访问action时候，都会创建action对象，创建多次，多实例对象 值栈存储位置（1）每次访问action时候，都会创建action对象，（2）在每个action对象里面都会有一个值栈对象（只有一个） 获取值栈对象 获取值栈对象有多种方式（1）常用方式：使用ActionContext类里面的方法得到值栈对象1234567public String execute() throws Exception &#123; //获取ActionContext类对象 ActionContext context =ActionContext.getContext(); //调用方法得到值栈 ValueStack stack1 = context.getValueStack(); return NONE;&#125; 值栈内部结构 值栈分为两部分： 第一部分 root，结构是list集合 一般操作都是root里面数据 第二部分 context，结构map集合 struts2里面标签 s:debug，使用这个标签可以查看值栈结构和存储值（1）访问action，执行action的方法有返回值，配置返回值到jsp页面中，在jsp页面中使用这个标签 1&lt;!--struts2标签查看值栈结构--&gt; &lt;s:debug&gt;&lt;/s:debug&gt; 就会多一个debug按钮来查看信息 action对象里面有值栈对象值栈对象里面有action引用 向值栈放数据向值栈放数据多种方式第一种 获取值栈对象，调用值栈对象里面的 set 方法 12345678public String execute() throws Exception &#123; //第一种方法 获取值栈对象里面的set方法 //获取值栈对象 ActionContext context = ActionContext.getContext(); ValueStack stack = context.getValueStack(); //调用方法set方法 stack.set("username","shelhon"); return "ok"; debug页面就会多一个入栈 java.util.HashMap 第二种 获取值栈对象，调用值栈对象里面的 push方法12//调用方法push方法 stack.push("abdc"); 又多一个入栈 ：java.lang.String 第三种 在action定义变量，生成变量的get方法 123456789private String name;public String getName() &#123; return name;&#125;@Override public String execute() throws Exception &#123; //在执行方法里面向变量来赋值 name ="asdasd"; return "ok";&#125; 这种方法直接在原来的值栈上面写入数据，不需要生成新的值栈来存储，可以节省空间 向值栈放对象 实现步骤 第一步 定义对象变量1//1定义变量 private User user = new User(); 第二步 生成变量的get方法123public User getUser() &#123; return user;&#125; 第三步 在执行的方法里面向对象中设置值1234567public String execute() throws Exception &#123; //3 向值栈的user里面放数据 user.setUsername(&quot;luck&quot;); user.setPassword(&quot;123&quot;); user.setAddress(&quot;gz&quot;); return &quot;ok&quot;;&#125; 向值栈放list集合第一步 定义list集合变量1private List&lt;User&gt; list = new ArrayList&lt;User&gt;(); 第二步 生成变量的get方法123public List&lt;User&gt; getList() &#123; return list;&#125; 第三步 在执行的方法里面向list集合设置值123456789101112131415public String execute() throws Exception &#123; User user1= new User(); user1.setUsername("ben"); user1.setAddress("gz"); user1.setPassword("111"); User user2 =new User(); user2.setUsername("jack"); user2.setPassword("009"); user2.setAddress("cd"); list.add(user1); list.add(user2); return "ok";&#125; 从值栈获取数据使用struts2的标签+ognl表达式获取值栈数据&lt;s:property value=”ognl表达式”/&gt; 获取字符串 向值栈放字符串 12345678910111213public class ValueStackAction extends ActionSupport &#123; //定义变量 private String username; public String getUsername()&#123; return username; &#125; @Override public String execute() throws Exception &#123; //给变量赋值 username="shelhon"; return "ok"; &#125;&#125; 在jsp使用struts2标签+ognl表达式获取 1&lt;s:property value=&quot;username&quot;/&gt; 获取对象 向值栈放对象 123456789101112131415public void setUser(User user) &#123; this.user = user;&#125;private User user =new User();public User getUser() &#123; return user;&#125;public String execute() throws Exception &#123; user.setUsername("asd"); user.setPassword("222"); user.setAddress("gz"); return "ok"; 在页面中获取值123&lt;s:property value=&quot;user.username&quot;/&gt;&lt;s:property value=&quot;user.password&quot;/&gt;&lt;s:property value=&quot;user.address&quot;/&gt; 获取list集合三种方法一开始先把list放到值栈去1234567891011121314151617private List&lt;User&gt; list = new ArrayList&lt;User&gt;();public List&lt;User&gt; getList() &#123; return list;&#125;@Override public String execute() throws Exception &#123; User user1= new User(); user1.setUsername("qsx"); user1.setAddress("gz"); user1.setPassword("111"); User user2 =new User(); user2.setUsername("jack"); user2.setPassword("009"); user2.setAddress("cd"); list.add(user1); list.add(user2); return "ok"; 第一种 1234567&lt;!-- 第一种方式 --&gt; &lt;s:property value=&quot;list[0].username&quot;/&gt;&lt;s:property value=&quot;list[0].possword&quot;/&gt;&lt;s:property value=&quot;list[0].address&quot;/&gt;&lt;s:property value=&quot;list[1].username&quot;/&gt;&lt;s:property value=&quot;list[1].possword&quot;/&gt;&lt;s:property value=&quot;list[1].address&quot;/&gt; 第二种 1234567&lt;!-- 使用struts2标签，类似jst1的foreach标签 &lt;s:iterator&gt;遍历值栈的list集合--&gt;&lt;s:iterator value=&quot;list&quot;&gt;&lt;!-- 遍历list得到list里面每一个user对象 --&gt; &lt;s:property value=&quot;username&quot;/&gt; &lt;s:property value=&quot;password&quot;/&gt; &lt;s:property value=&quot;address&quot;/&gt; &lt;/s:iterator&gt; 第三种1234567&lt;s:iterator value=&quot;list&quot; var=&quot;user&quot;&gt; &lt;!-- 遍历值栈list集合，得到每个user对象 机制：把每次遍历出来的user对象放到context里面 获取context里面的数据特点：写ognl表达式， 使用特殊符号 # --&gt; &lt;s:property value=&quot;#user.username&quot;/&gt; &lt;s:property value=&quot;#user.username&quot;/&gt; &lt;s:property value=&quot;#user.username&quot;/&gt;&lt;/s:iterator&gt;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2学习]]></title>
    <url>%2Fposts%2Fc240a0d6.html</url>
    <content type="text"><![CDATA[主要内容 stuts2入门 struts2数据操作 Struts2 概述 struts2框架应用javaee三层结构中的web层框架 struts2 是struts1和webwork基础上发展全新的框架、 struts2解决问题 struts2 版本 struts2-2.3.24 web层常用框架 struts2 springMVC struts2 框架入门第一个例子 老规矩导入jar包 创建action 123456789public class HelloAction &#123; /* (1)每次访问servlet的时候，都会访问service方法 - 写类继承HTTPServlet，重写类里面的方法 (2)访问action的时候 每次访问action默认执行execute方法 */ public String execute()&#123; return "ok";&#125;&#125; 配置action类访问路径(1)、创建struts2核心配置文件核心配置文件必须是固定名称和位置位置必须是再src下面，名称必须是struts.xml(2)、引入dtd约束 123&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; (3)、action配置 1234567&lt;package name=&quot;hellodemo&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;!-- name: 访问名称 --&gt; &lt;action name=&quot;hello&quot; class=&quot;cn.shelhon.action.HelloAction&quot;&gt; &lt;!-- 配置方法的返回值到页面 --&gt; &lt;result name=&quot;ok&quot;&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 访问路径http://127.0.0.1:8080/struts2/hello.action (4) 配置struts2过滤器 在Tomcat上面运行的时候，发现一直各种报错 12严重: Exception starting filter struts2java.lang.ClassNotFoundException: org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter 估计是在idea的时候，运行Tomcat时，maven依赖那里出现了问题。导入缺少了jar包，Tomcat运行不起来。最后在项目结构Artifacts里available Elements右键把里面的jar包导入到lib文件夹里。 ！！还有就是一定要把struts2.xml文件放到resources文件夹里 基本流程： 查看源码 class StrutsPrepareAndExecuteFilter implements StrutsStatics, Filter 过滤器在服务启动的时候创建，创建过滤器时候执行init方法 在init方法中主要是加载配置文件包含自己创建的配置文件和struts2自带的配置文件主要注意struts.xml和web.xml struts 配置struts2核心配置文件 名称和位置是固定的固定是在src里面，名字是struts.xml但是由于用了maven，所以位置是在src的resources里面 在配置文件中主要三个标签 package、action、result，标签里面的属性 标签package1、 类似于代码包，区别不同的action，要配置action，必须首先写package标签，在package里面才能 配置action 2、 package标签属性（1）name属性 - name属性值根功能本身没有关系的， - 在一个配置文件中可以写多个package标签，name属性值不能相同的 （2）extends属性 extends = “struts-default” 属性值固定的，struts-default 写了这个属性之后，在package里面配置的类具有action功能 （3）namespace属性 namespace属性值和action标签里面的name属性值构成访问路径 标签action1、action标签配置action访问路径 2 、action标签属性 （1）name属性 namespace属性值和action标签里面的name属性值构成访问路径 在package标签里面写多个action标签，但是action的name属性值不能相同的 （2）class属性 action全路径 （3）method属性 比如在action里面默认执行的方法execute方法，但是在action里面写其他的方法 让action里面多个方法执行，使用method进行配置 标签result1 、根据action的方法返回值，配置到不同的路径里面 2 result标签属性 （1）name属性 和方法返回值一样 /hello.jsp （2）type属性 配置如何到路径中（转发或者重定向） type属性默认值 做转发操作 struts2常量配置 struts2框架，帮我们实现一部分功能，struts2里面有常量，在常量里面封装一部分功能 struts2默认的常量位置（记住） xxxxxxx/org\apache\struts\struts2-core\2.3.24\struts2-core-2.3.24.jar!\org\apache\struts2\default.properties 修改struts2默认常量值 （1）常用的方式 在struts.xml中进行配置 （2）还有两种方式（了解） 在src下面创建 struts.properties，进行修改 在web.xml进行配置 介绍最常用常量 struts.i18n.encoding=UTF-8 （1）表单提交数据到action里面，在action可以获取表单提交数据， （2）表单提交数据有中文，有乱码问题，解决： post提交直接设置编码 get提交做编码转换 （3）如果在action获取表单通过post方式提交中文，中文乱码问题帮解决了，不需要自己处理问题 分模块开发 单独写配置文件hello.xml，把配置文件引入到核心配置文件中 12&lt;!-- 引入hello.xml --&gt; &lt;include file=&quot;hello.xml&quot;&gt;&lt;/include&gt; 这样就可以在工作的时候，大家一起协同办公 action编写方式 action编写有三种方式第一种 创建普通类，这个不继承任何类，不实现任何接口 1public class HelloAction&#123;&#125; 第二种 创建类，实现接口 Action123456//实现接口 public class UserAction implements Action &#123; public String execute() throws Exception &#123; return null; &#125;&#125; 第三种 创建类，继承类 ActionSupport（一般使用） 123//继承类 public class PersonAction extends ActionSupport &#123;&#125; 访问action里面的方法 有三种方式实现 第一种 使用action标签的method属性，在这个属性里面写执行的action的方法 第二种 使用通配符方式实现 第三种 动态访问实现（不用） 演示错误 （1）如果action方法有返回值，在配置文件中没有配置，出现错误 Message No result defined for action cn.shelhon.action.HelloAction and result success （2）在action里面的方法有返回值，如果有返回值时候类型必须是String （3）action里面的方法可以没有返回值，没有返回值时候，在result标签不需要配置 把方法写成void 让返回值，返回 ”none” 在idea创建新的模块的时候，放到Tomcat上面一直没办法运行新的struts.xml的配置，然后在运行设置里面的把原理的给移除了，加上新创建的就能运行了 使用action标签method属性 (1). 创建action，创建多个方法 123456789101112public class BookAction extends ActionSupport &#123; //添加 public String add()&#123; System.out.println("add----"); return NONE; &#125; //修改 public String update()&#123; System.out.printf("update---"); return NONE; &#125;&#125; (2). 使用method配置 1234567&lt;!-- 配置action的方法访问 --&gt; &lt;package name=&quot;demo1&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;method&quot; class=&quot;cn.shelhon.method.BookAction&quot; method=&quot;add&quot;&gt; &lt;/action&gt; &lt;action name=&quot;method1&quot; class=&quot;cn.shelhon.method.BookAction&quot; method=&quot;update&quot;&gt; &lt;/action&gt;&lt;/package&gt; 缺陷：action每个方法都需要配置，如果action里面有多个方法，配置很多的action 使用通配符实现（重点） (1) 在action标签里面name属性，name属性值里面写 符号 * 星号 *理解： 表示匹配任意内容 比如访问hello，* 可以匹配到 比如访问add，* 可以匹配到 1234567&lt;!-- 配置通配符方法 --&gt; &lt;package name=&quot;tongpei&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;!-- name属性值里面要写一个符号 * (1)执行 action里面的add方法，访问book_add (2)执行 action里面的update方法，访问book_update 上面两个路径使用book_*可以匹配到 --&gt; &lt;action name=&quot;book_*&quot; method=&quot;&#123;1&#125;&quot; class=&quot;cn.shelhon.method.BookAction&quot;&gt;&lt;/action&gt;&lt;/package&gt; 这种方法的话，访问就是用book_add.action ,或者book_update.action来实现如果name的属性值=”*”的话，那么访问就是输入add.action，或者update.action就可以实现。 结果页面配置 result标签配置action方法的返回值到不同的路径里面 创建两个action，执行默认的方法execute方法，让两个action的方法都返回success，返回success之后，配置到同一个页面里面 （1）如果多个action，方法里面返回值相同的，到页面也是相同的，这个时候可以使用全局结果页面配置 12345678910&lt;package name=&quot;demo1&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt;&lt;action name=&quot;book&quot; class=&quot;cn.shelhon.action.BookAction&quot; method=&quot;execute&quot;&gt;&lt;result name=&quot;success&quot;&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt;&lt;action name=&quot;orders&quot; class=&quot;cn.shelhon.action.OrdersAction&quot; method=&quot;execute&quot;&gt;&lt;result name=&quot;success&quot;&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt;&lt;/package&gt; 修改后代码12345678910&lt;package name=&quot;demo1&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;!-- 全局结果页面配置 --&gt; &lt;global-results&gt; &lt;result name=&quot;success&quot;&gt;hello.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name=&quot;book&quot; class=&quot;cn.shelhon.action.BookAction&quot; method=&quot;execute&quot;&gt; &lt;/action&gt; &lt;action name=&quot;orders&quot; class=&quot;cn.shelhon.action.OrdersAction&quot; method=&quot;execute&quot;&gt; &lt;/action&gt;&lt;/package&gt; 但是要注意的是，这个全局变量是在package里面用的 局部结果页面 123&lt;action name=&quot;book&quot; class=&quot;cn.shelhon.action.BookAction&quot; method=&quot;execute&quot;&gt;&lt;result name=&quot;success&quot;&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt; 如果同时配置了局部和全局结果页面，最后以局部变量为准 Result标签的type属性 result标签里面除了name属性之外，还有一个属性 type属性type属性：如何到路径里面（转发还是重定向） type属性值（1）默认值，做转发操作，值是 dispatcher就是说在浏览器上面的地址还是看到http://localhost:8080/struts2Day02/book.action但是实际内容是hello.jsp的内容（2）做重定向操作，值是 redirect输入http://localhost:8080/struts2Day02/book.action然后链接变成了http://localhost:8080/hello.jsp（3）上面两个值dispatcher、redirect，这两个值一般针对到页面中配置 配置到其他的action里面 chain：转发到action，一般不用，缓存问题输入http://localhost:8080/struts2Day02/book.action链接不变，但是实际内容已经是orders的内容 redirectAction：重定向到action比如输入http://localhost:8080/struts2Day02/book.action链接变成http://localhost:8080/orders.action Action获取表单提交数据 之前web阶段，提交表单到servlet里面，在servlet里面使用request对象里面的方法获取，getParameter，getParameterMap 提交表单到action，但是action没有request对象，不能直接使用request对象 action获取表单提交数据主要三种方式（1）使用ActionContext类（2）使用ServletActionContext类（3）使用接口注入方式(一般不用) 使用ActionContext类获取Map getParameters() : 返回一个包含所有HTTPSServletRequest参数信 因为这方法不是静态的方法，所以需要创建ActionContext类的对象 这个ActionContext不是new出来的static ActionContext getContext() :获取当前线程的ActionContext对象 具体演示（1）创建表单，提交表单到action里面 （2）在action使用ActionContext获取数据 12345678910111213141516public String execute() throws Exception &#123; // 第一种方式 使用ActionContext类获取 // 1获取Action Context ActionContext context =ActionContext.getContext(); //2 调用方法得到表单数据 // key是表单输入项的name属性值，value值是输入的值 Map&lt;String,Object&gt; map = context.getParameters(); Set&lt;String&gt; keys =map.keySet(); for (String key :keys)&#123; //根据key得到value //数据形式：因为输入项里面可能有复选的情况 Object[] obj = (Object[]) map.get(key); System.out.println(Arrays.toString(obj)); &#125; return NONE;&#125; 123&lt;package name=&quot;demo2&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;form1&quot; class=&quot;cn.shelhon.action.form.Form1Demo&quot;&gt; &lt;/action&gt; 使用ServletActionContext类获取 调用类里面静态方法，得到request对象 12345678910public String execute() throws Exception &#123; //第一种方式，使用ServletActionContext类获取 //1使用ServletActionContext获取request对象 HttpServletRequest request = ServletActionContext.getRequest(); String username = request.getParameter("username"); String password = request.getParameter("password"); String address = request.getParameter("address"); System.out.println(username+password+address); return NONE;&#125; 使用接口注入（了解）1234567891011121314public class Form3Demo extends ActionSupport implements ServletRequestAware &#123; //使用接口方式private HttpServletRequest request;public void setServletRequest(HttpServletRequest request) &#123; this.request=request; &#125; public String execute() throws Exception &#123; String username = request.getParameter("username"); String password = request.getParameter("password"); String address = request.getParameter("address"); System.out.println(username+password+address); return NONE; &#125;&#125; 在action操作域对象12345678910//操作三个域 // 1 request域 HttpServletRequest request = ServletActionContext.getRequest();request.setAttribute("req","reqValue");//2 session域 HttpSession session = request.getSession();session.setAttribute("sess","sessValue");//3 ServletContext域 ServletContext context = ServletActionContext.getServletContext();context.setAttribute("contextname","contextValue");return NONE; Struts2封装获取表单数据方式原始方式获取表单封装到实体类对象123456789101112131415public String execute() throws Exception &#123; // 使用servletActionContext获取表单数据封装到实体类对象里面 // 1获取表单数据 HttpServletRequest request = ServletActionContext.getRequest(); String username = request.getParameter("username"); String password = request.getParameter("password"); String address = request.getParameter("address"); //2 把数据封装到实体类对象里面 User user = new User(); user.setUsername(username); user.setPassword(password); user.setAddress(address); System.out.println(user); return NONE;&#125; 123456789101112131415161718192021222324252627282930public class User &#123; private String username; private String password; private String address; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "username='" + username + '\'' + ", password='" + password + '\'' + ", address='" + address + '\'' + '&#125;'; &#125; 属性封装 实现过程（1）使用表达式封装可以把表单数据封装到实体类对象里面第一步 在action里面声明实体类1&lt;action name=&quot;data1&quot; class=&quot;cn.shelhon.data.DataDemo1Action&quot;&gt; &lt;/action&gt; 第二步 生成实体类变量的set和get方法 123456789101112131415161718192021222324252627282930public class DataDemo1Action extends ActionSupport &#123;//定义变量 //变量的名称和表单的name属性一样 private String username; private String password; private String address; // 生成变量的set和get方法 public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; System.out.println(username+" "+password+" "+address); this.password = password; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String execute() throws Exception &#123; return NONE; &#125;&#125; 模型驱动封装（重点） 使用模型驱动方式，可以直接把表单数据封装到实体类对象里面 实现步骤 （1）action实现接口 ModelDriven1public class DataDemo2Action extends ActionSupport implements ModelDriven&lt;User&gt; &#123;&#125; （2）实现接口里面的方法 getModel方法 把创建对象返回 12345678910public class DataDemo2Action extends ActionSupport implements ModelDriven&lt;User&gt; &#123; public User getModel() &#123; return user; &#125; @Override public String execute() throws Exception &#123; return NONE; &#125;&#125; （3）在action里面创建实体类对象 123public User getModel() &#123; return user;&#125; 使用模型驱动和属性封装注意问题：在一个action中，获取表单数据可以属性封装，使用模型驱动封装，不能同时使用属性封装和模型驱动封装获取同一个表单数据。如果同时使用，执行模型驱动。 表达式封装（会用） 实现过程（1）使用表达式封装可以把表单数据封装到实体类对象里面第一步 在action里面声明实体类private User user;第二步 生成实体类变量的set和get方法123456public User getUser() &#123; return user;&#125;public void setUser(User user) &#123; this.user = user;&#125; 第三步 在表单输入项的name属性值里面写表达式形式12345username:&lt;input type=&quot;text&quot; name=&quot;user.username&quot;/&gt;&lt;br/&gt;password:&lt;input type=&quot;text&quot; name=&quot;user.password&quot;/&gt;&lt;br/&gt;address:&lt;input type=&quot;text&quot; name=&quot;user.address&quot;/&gt; 比较表达式封装和模型驱动封装使用表达式封装和模型驱动封装都可以把数据封装到实体类对象里面不同点：（1）使用模型驱动只能把数据封装到一个实体类对象里面在一个action里面不能使用模型驱动把数据封装到不同的实体类对象里面（2）使用表达式封装可以把数据封装到不同的实体类对象里面12345678910111213141516171819202122public class DataDemo3Action extends ActionSupport &#123; //声明实体类 private User user; private Book book; public Book getBook() &#123; return book; &#125; public void setBook(Book book) &#123; this.book = book; &#125; //生成实体类变量的set和get方法 public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public String execute() throws Exception &#123; System.out.println(user); System.out.println(book.getBname()); return NONE; &#125; 1234567891011&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/data3.action&quot; method=&quot;post&quot;&gt; username:&lt;input type=&quot;text&quot; name=&quot;user.username&quot;/&gt; &lt;br/&gt; password:&lt;input type=&quot;text&quot; name=&quot;user.password&quot;/&gt; &lt;br/&gt; address:&lt;input type=&quot;text&quot; name=&quot;user.address&quot;/&gt; &lt;br/&gt; bname:&lt;input type=&quot;text&quot; name=&quot;book.bname&quot;/&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt; 封装到集合里面 封装数据到List集合 第一步 在action声明List1private List&lt;User&gt; list; 第二步 生成list变量的set和get方法 第三步 在表单输入项里面写表达式123456789101112131415&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/list.action&quot; method=&quot;post&quot;&gt; username:&lt;input type=&quot;text&quot; name=&quot;list[0].username&quot;/&gt; &lt;br/&gt; password:&lt;input type=&quot;text&quot; name=&quot;list[0].password&quot;/&gt; &lt;br/&gt; address:&lt;input type=&quot;text&quot; name=&quot;list[0].address&quot;/&gt; &lt;br/&gt; &lt;br/&gt; username:&lt;input type=&quot;text&quot; name=&quot;list[1].username&quot;/&gt; &lt;br/&gt; password:&lt;input type=&quot;text&quot; name=&quot;list[1].password&quot;/&gt; &lt;br/&gt; address:&lt;input type=&quot;text&quot; name=&quot;list[1].address&quot;/&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; 封装数据到Map集合 第一步 声明map集合private Map&lt;String,User&gt; map;第二步 生成get和set方法 123456public Map&lt;String,User&gt; getMap() &#123; return map;&#125;public void setMap(Map&lt;String,User&gt; map) &#123; this.map = map;&#125; 第三步 在表单输入项的name属性值里面写表达式1234567891011121314151617&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/map.action&quot; method=&quot;post&quot;&gt; &lt;!-- 设置key的值 [&apos;key值&apos;] 设置value值 --&gt; username:&lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].username&quot;/&gt; &lt;br/&gt; password:&lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].password&quot;/&gt; &lt;br/&gt; address:&lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].address&quot;/&gt; &lt;br/&gt; &lt;br/&gt; username:&lt;input type=&quot;text&quot; name=&quot;map[&apos;two&apos;].username&quot;/&gt; &lt;br/&gt; password:&lt;input type=&quot;text&quot; name=&quot;map[&apos;two&apos;].password&quot;/&gt; &lt;br/&gt; address:&lt;input type=&quot;text&quot; name=&quot;map[&apos;two&apos;].address&quot;/&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 框架学习(二)]]></title>
    <url>%2Fposts%2F14042445.html</url>
    <content type="text"><![CDATA[大概内容 基于aspectj的注解aop操作 spring的jdbcTemplate操作 spring配置连接池 spring事务管理 基于aspectj的注解aop操作1. 使用注解方式创建aop操作 第一步 ：创建对象1&lt;!-- 1 配置对象 --&gt; &lt;bean id=&quot;book&quot; class=&quot;cn.shelhon.cn.shelhon.aop.Book&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;myBook&quot; class=&quot;cn.shelhon.cn.shelhon.aop.Book&quot;&gt; &lt;/bean&gt; 第二步 ：在spring核心配置文件里面开启AOP操作 1&lt;!-- 开启aop操作 --&gt; &lt;aop:aspectj-autoproxy&gt; &lt;/aop:aspectj-autoproxy&gt; 第三步 ： 在增强类上面使用注解完成aop操作 123@Aspect public class Mybook &#123; //在方法上面使用注解完成增强配置 @Before(value = &quot;execution(* cn.shelhon.aop.Book.*(..)&quot;) Spring的jdbcTemplate操作 实现crud操作 - 增加、修改、删除，调用模板update方法 - 查询某个值时候，调用queryForObject方法 - 自己写实现类封装数据 - 查询对象，调用queryForObject方法 - 查询list集合，调用query方法 spring框架一站式框架 针对javaee三层，每一层都有解决技术 在dao层，使用 jdbcTemplate spring对不同的持久化层技术都进行封装 其中jdbcTemplate对jdbc进行封装 jdbcTemplate使用和dbutils使用很相似，都数据库进行crud操作 增加 导入jdbcTemplate使用的jar包 创建对象，设置数据库信息 创建JdbcTemplate对象，设置数据源 调用jdbcTemplate对象里面的方法 操作的时候，记得还要导入驱动数据库的jar包 1234567891011121314151617181920212223// 添加操作 @Test public void add()&#123; //创建对象，设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("conm.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://test"); dataSource.setUsername("root"); dataSource.setPassword("12345"); // 创建JdbcTemplate对象，设置数据源 JdbcTemplate jdbcTempalate = new JdbcTemplate(dataSource); //调用jdbcTemplate对象里面的方法 String sql = "insert into user value(?,?)"; int rows = jdbcTempalate.update(sql,"lucy","22"); System.out.println(rows); &#125; 特别要注意的是，在运行的时候报错出现的问题1org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Unknown character set index for field &apos;255&apos; received from server. 这个问题是由于我使用的数据库版本比较新，导致旧的mysql-connector-java的版本使用的时候报错。(1) MYSQL 5.5 之前， UTF8 编码只支持1-3个字节;从MYSQL5.5开始，可支持4个字节UTF编码utf8mb4;如emoji表情需要使用utf8mb4 (2) 如果服务器级使用的编码是utf8mb4(在客户端链接后使用sql语句show variables like ‘char%’可查看所有编码)，而mysql的jar包低版本不支持utf8mb4,连接时报错”Unknown character set index for field ‘224’ received from server.” (3) 建议使用mysql-connector-java-5.1.30-bin.jar (4) 注意：如果数据库不支持utf8mb4，使用mysql-connector-java-5.1.30-bin.jar的jar包时则会报错，此时应该使用低版本的jar包。 然后这个时候我又用了最新版本的mysql-connector的jar包又报错1java.lang.UnsupportedClassVersionError: com/mysql/jdbc/Driver : Unsupported major.minor version 52.0 这种问题是jdk版本和mysql数据库版本不兼容从网上寻找的答案有如下： 1、jdk7+老版5.0驱动com/mysql/jdbc/Driver 2、jdk8+新版6.0驱动com/mysql/cj/jdbc/Driver 所以就是最新的jar是不能跟jdk1.7搭配使用的。最后解决问题的是这样的搭配 jdk1.7.0_80 mysql-connector-java 5.1.46 spring-jdbc 4.2.4.RELEASE 更新更新的方法跟增加差不多。 1234//调用jdbcTemplate对象里面的方法 String sql = "update user set password=? where name=?"; int rows = jdbcTemplate.update(sql,"lucy","99"); System.out.println(rows); 删除删除也是同理1234//调用jdbcTemplate对象里面的方法 String sql = "delete from user where name=?"; int rows = jdbcTemplate.update(sql,"null"); System.out.println(rows); 查询1、查询表中有多少记录12345// 创建JdbcTemplate对象，设置数据源JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);String sql = "select count(*) from user";int count =jdbcTemplate.queryForObject(sql,Integer.class);System.out.println(count); &#125; 2、查询返回对象jdbc底层原理12345678910111213141516171819202122232425262728293031323334353637383940@Test public void testJDBC()&#123;Connection conn = null;PreparedStatement psmt =null;ResultSet rs = null;try &#123; Class.forName("com.mysql.jdbc.Driver");//创建连接conn = DriverManager.getConnection("jdbc:mysql:///test", "root", "12345");//编写sql语句String sql = "select * from user where name =?";//预编译sql语句psmt = conn.prepareStatement(sql);//设置参数值psmt.setString(1, "lucy");//遍历结果集rs =psmt.executeQuery(); while(rs.next())&#123; //得到返回值String username =rs.getString("name");String password = rs.getString("password"); //放到User对象里面User user =new User();user.setUsername(username);user.setPassword(password);System.out.println(user); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try&#123; rs.close();psmt.close();conn.close();; &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125; &#125;&#125; User.java代码123456789101112131415161718192021222324252627282930package cn.shelhon.jdbc; public class User &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public String getPassword() &#123; return password; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User&#123;" + "username='" + username + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 具体的实现1234567891011121314151617181920212223242526272829@Test public void testObject()&#123; //创建对象以及设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql:///test"); dataSource.setUsername("root"); dataSource.setPassword("12345"); // 创建JdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); //写sql语句，根据name来查询 String sql ="select * from user where name = ?"; //调用jdbctempla的方法实现 //第二个参数是接口ROWMapper，需要自己写个类,自己做数据封装 User user=jdbcTemplate.queryForObject(sql,new MyRowMapper(),"rose"); System.out.println(user); &#125;&#125;class MyRowMapper implements RowMapper&lt;User&gt;&#123; public User mapRow(ResultSet rs, int i) throws SQLException &#123; //从结果集里把数据拿到 String username = rs.getString("name"); String password = rs.getString("password"); //把得到的数据封装到对象里面 User user = new User(); user.setUsername(username); user.setPassword(password); return user; &#125;&#125; 3、查询返回list集合1234567891011121314@Test public void testList()&#123; //创建对象以及设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql:///test"); dataSource.setUsername("root"); dataSource.setPassword("12345"); // 创建JdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); //写sql语句，根据name来查询 String sql ="select * from user"; //调用jdbctempla的方法实现 //第二个参数是接口ROWMapper，需要自己写个类,自己做数据封装List&lt;User&gt; list =jdbcTemplate.query(sql,new MyRowMapper()); System.out.println(list); &#125; Spring配置连接池配置c3p0连接池 导入jar包c3p0-0.9.2.1mchange-commons-java-0.2.3.4 创建spring文件，建立连接池 12345&lt;!-- 配置c3p0连接池 --&gt; &lt;bean id =&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 注入属性值--&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt; &lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;dbc:mysql:///test&quot;&gt; &lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt; &lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;12345&quot;&gt; &lt;/property&gt; &lt;/bean&gt; dao使用jdbcTemplate 创建service和dao，配置service和dao对象，在service注入dao对象 1234&lt;bean id=&quot;userService&quot; class=&quot;cn.shelhon.c3p0.UserService&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;cn.shelhon.c3p0.UserDao&quot;&gt;&lt;/bean&gt; 创建jdbcTemplate对象，把模板对象注入到dao里面创建对象12345private JdbcTemplate jdbcTemplate; //添加操作public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; 注入dao里面123&lt;bean id=&quot;userDao&quot; class=&quot;cn.shelhon.c3p0.UserDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt; &lt;/property&gt;&lt;/bean&gt; 在jdbcTemplate对象里面注入dataSource 1234&lt;!-- 创建JdbcTemplate对象 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 把datasource传递到模板对象里面 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt; &lt;/property&gt; &lt;/bean&gt; 关于数据库语句因为我的表里用了主键，在插入新的数据的时候12String sql ="insert into user values(?,?)"; jdbcTemplate.update(sql,"李峰","asd"); 按照这语法就报错了 后来改这样就通过了12String sql="insert into user(id,name,password) values(null,?,?)"; jdbcTemplate.update(sql,"李峰","asd"); Spring事务管理事务概念 什么是事务Spring事务 的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。 理解事务之前，先讲一个你日常生活中最常干的事：取钱。比如你去ATM机取1000块钱，大体有两个步骤：首先输入密码金额，银行卡扣掉1000元钱；然后ATM出1000元钱。这两个步骤必须是要么都执行要么都不执行。如果银行卡扣除了1000块但是ATM出钱失败的话，你将会损失1000元；如果银行卡扣钱失败但是ATM却出了1000块，那么银行将损失1000元。所以，如果一个步骤成功另一个步骤失败对双方都不是好事，如果不管哪一个步骤失败了以后，整个取钱过程都能回滚，也就是完全取消所有操作的话，这对双方都是极好的。事务就是用来解决类似问题的。事务是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。在企业级应用程序开发中，事务管理必不可少的技术，用来确保数据的完整性和一致性。 事务特性：四大特性(简称ACID) 原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 一致性（Consistency）：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 隔离性（Isolation）:隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 持久性（Durability）:持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 不考虑隔离性产生读问题 脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。 不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。 虚读(幻读)： 幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 解决读问题 设置隔离级别数据库给力级别： ① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 ② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。 ③ Read committed (读已提交)：可避免脏读的发生。 ④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 spring进行事务管理apispring事务管理有两种方法 编程式事务管理（一般不用） 声明式事务管理： 基于xml配置文件实现 基于注解实现 spring事务管理的api介绍spring事务管理高层抽象主要包括3个接口 PlatformTransactionManager事务管理器 TransactionDefinition事务定义信息（隔离、传播、超时、只读） TransactionStatus事务具体运行状态 其中spring针对不同的dao层框架，提供不同的实现类比如： org.springframework.jdbc.datasource.DataSourceTransactionManager是使用springJDBC或者iBatis进行持久化数据时使用。 org.springframework.orm.hibernate5.HibernateTransactionManager使用Hiber5版本进行持久化数据时使用 搭建转账环境首先配置事务管理器 创建数据库的表，添加数据 创建service类和dao类，完成注入关系。 12345678910111213&lt;bean id=&quot;ordersService&quot; class=&quot;cn.shelhon.service.OrdersService&quot;&gt; &lt;property name=&quot;ordersDao&quot; ref=&quot;ordersDao&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id=&quot;ordersDao&quot; class=&quot;cn.shelhon.Dao.OrdersDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; service层又叫业务逻辑层 dao层，单独对数据库操作层，在dao层不添加业务 比较齐全的约束 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;&lt;/beans&gt; 需求甲 转账给 乙 1000甲 少 1000乙 多 1000 先在dao层写操作数据库的方法12345678910111213141516public class OrdersDao &#123; //注入jdbcTemplate模板 private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; //提供对数据库操作的方法，不写业务操作 // 少钱的方法 public void lessMoney()&#123; String sql ="update account set salary=salary-? where name = ?"; jdbcTemplate.update(sql,1000,"甲"); &#125; // 加钱的方法 public void addMoney()&#123; String sql ="update account set salary=salary+? where name =?"; jdbcTemplate.update(sql,1000,"乙"); &#125;&#125; 然后再service层调用dao层写业务逻辑123456789101112public class OrdersService &#123; private OrdersDao ordersDao; public void setOrdersDao(OrdersDao ordersDao) &#123; this.ordersDao = ordersDao; &#125; //调用dao的方法 //业务逻辑层，写转账业务 public void accountMoney()&#123; // 甲少1000 ordersDao.lessMoney();; // 乙多1000 ordersDao.addMoney(); &#125;&#125; 产生的问题 ： 如果甲扣钱了以后，出现异常，乙的钱并没有增加，钱丢失了 解决： -添加事务解决，出现异常进行回滚操作 spring进行事务配置（声明式）基于xml配置文件 配置文件使用aop思想 12345&lt;!-- 第一步配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入datasource --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt; &lt;/property&gt; &lt;/bean&gt; 配置事务的增强 1234567&lt;!-- 第二步 配置事务增强 --&gt; &lt;tx:advice id =&quot;txadvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 做事务操作 --&gt; &lt;tx:attributes&gt; &lt;!-- 设置进行事务操作的方法匹配规则 --&gt; &lt;tx:method name=&quot;account*&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 配置切面 1234567&lt;!-- 第三步 --&gt; &lt;!-- 配置切面 --&gt; &lt;aop:config&gt; &lt;!-- 切入点 --&gt; &lt;aop:pointcut expression =&quot;execution(* cn.shelhon.service.OrdersService.*(..))&quot; id = &quot;pointcut1&quot;/&gt; &lt;!--切面--&gt; &lt;aop:advisor advice-ref=&quot;txadvice&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:config&gt; 经过上面的配置以后，出现异常就能自动回滚操作 基于注解方式 第一步也是要先配置事务管理器 1234&lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;dataSourceTransactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt; &lt;/property&gt;&lt;/bean&gt; 配置事务注解 1&lt;!-- 开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;dataSourceTransactionManager&quot;/&gt; 要在使用事务的方法所在类上添加注解 12345678910111213141516@Transactional public class OrdersService &#123; private OrdersDao ordersDao; public void setOrdersDao(OrdersDao ordersDao) &#123; this.ordersDao = ordersDao; &#125; //调用dao的方法 //业务逻辑层，写转账业务 public void accountMoney()&#123; // 甲少1000 ordersDao.lessMoney();; //出现异常 // int i =10/0; // 乙多1000 ordersDao.addMoney(); &#125;&#125;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用IDEA遇到的问题记录]]></title>
    <url>%2Fposts%2Fada285ba.html</url>
    <content type="text"><![CDATA[人可以做他想做的，但不能要他想要的 记录在使用idea的过程中遇到的问题 比如 配置环境遇到的问题 导入jar包 依赖 maven Tomcat jdk和jar包版本的问题 将会比较随意的记录 配置环境说到底原本最初是用idea，后来实习公司又要用eclipse，不怎么熟悉这个开发工具，本来就艰难，jdk就用一开始的1.8版本jdk，结果按照公司要求用回jdk1.7和Tomcat1.7的时候，eclipse就无法打开了。因为photon不支持1.8以下的版本。果断回头idea。 关于那个新建项目以后的文件目录格式，可以创建后自己修改。不用太纠结位置。 在创建项目以后，可以再创建模块，一个模块就相当于原来eclipse里面的项目。 在idea里面移除模块以后，不会删除本地硬盘里的文件，如果需要再导入这个模块进入项目里面的话，就找到 xxxx.iml文件，然后导入就会自动加载原来的那个模块了。 在运行的过程中，试过出现以下报错 1org.springframework.beans.factory.BeanDefinitionStoreException: IOException parsing XML document from class path resource [applicationContext.xml]; nested exception is java.io.FileNotFoundException: class path resource [applicationContext.xml] cannot be opened because it does not exist 最后是把applicationContext.xml放入resources文件夹里才成功。包括什么log4j.properties等这类型的文件都是要放进去才能生效。 导入jar包要注意框架的版本，因为不同版本，可能jar包就取消了，或者集合在一起了，这个必须得注意。 配置依赖 IDEA: 遇到问题Error during artifact deployment. See server log for details.详细的报错是12严重: Exception starting filter struts2java.lang.ClassNotFoundException: prg.apache.struts2.dispatcher.FilterDispatcher 虽然不太懂原因，但是解决方法是打开项目结构，然后在Artifacts上面找到报错模块的地方，接着在output Layout找到WEB-INF文件夹，创建一个lib文件夹，然后右键文件夹添加副本，选择库文件，问题就解决了。 maven在配置好系统环境变量以后在idea里的setting里设置maven的东西比如默认读取setting.xml的位置和仓库的位置因为idea自带的maven和我们自己安装位置的会不同 新建的时候就对着模块右键，选择添加框架支持 在里面找到maven然后直接新建就行。 创建pom.xml后好像会提示更新目录什么的，让idea来完成就好 默认的pom.xml里面需要我们自己去添加依赖，但是文件里会少了一些代码 &lt;dependencies&gt; #中间这里把maven依赖网站上面的配置自己找下来，复制上去就行 &lt;/dependencies&gt; 如果要移除依赖的话，直接删除pom.xml就可以了，同时idea会自动调整目录结构的 使用过程中，如果发现项目没有添加依赖，那么在项目结构中，找到这个项目的依赖，然后删除重新导入。 maven的依赖查询网站 ：http://mvnrepository.com/ 在idea右侧的工具栏里是可以找到maven插件的，通过这个可以很快查看每个项目的依赖。 Tomcat tomcat1.7版本不支持Servlet3.0以上的版本 然而idea创建web.xml的时候基本默认是4.0版本 Servlet 3.1 部署描述符Java EE 7 XML schema, namespace is http://xmlns.jcp.org/xml/ns/javaee/ 123456&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaeehttp://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"version="3.1"&gt;&lt;/web-app&gt; Servlet 3.0 部署描述符Java EE 6 XML schema, namespace is http://java.sun.com/xml/ns/javaee 123456&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://java.sun.com/xml/ns/javaeehttp://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"version="3.0"&gt;&lt;/web-app&gt; Servlet 2.5 部署描述符Java EE 5 XML schema, namespace is http://java.sun.com/xml/ns/javaee 123456&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://java.sun.com/xml/ns/javaeehttp://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"version="2.5"&gt;&lt;/web-app&gt; Servlet 2.4 部署描述符J2EE 1.4 XML schema, namespace is http://java.sun.com/xml/ns/j2ee 1234567&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://java.sun.com/xml/ns/j2eehttp://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"version="2.4"&gt; &lt;display-name&gt;Servlet 2.4 Web Application&lt;/display-name&gt;&lt;/web-app&gt; Servlet 2.3 部署描述符J2EE 1.3 DTDs schema. This web.xml file is too old, highly recommend you to upgrade it.123456&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Servlet 2.3 Web Application&lt;/display-name&gt;&lt;/web-app&gt; Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。 idea 快捷键alt+鼠标左键 可以查看源代码 CTRL+shift+i 可以小窗口查看源代码–再加上CTRL+enter可以打开窗口]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>踩坑</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 框架学习]]></title>
    <url>%2Fposts%2F46958.html</url>
    <content type="text"><![CDATA[spring框架的介绍&nbsp; Spring框架是一个轻量级的控制反转（IOC）和面向切面（AOP）的容器框架。 &nbsp; 记录了一些关于框架特点和特性以及Spring工作流程图。比如：IOC 、AOP的底层原理，属性注入，注解，bean管理 一、 一些基本特性 轻量：大小与开销轻量级，完整的spring框架可以在大小只有1MB多的JAR文件中发布，且spring框架是非侵入式的，spring应用不依赖于spring特定类。控制反转：Spring通过一种称为控制反转的（IOC）的技术促进松耦合。当应用了IOC，一个对象依赖的其他对象通过被动的方式传递进来，而不是对象自己创建或者查找依赖对象。不是对象从容器中查找依赖，而是容器在对象初始化的不等对象请求就主动依赖传递过去.把对象的创建不是通过new方式，而是交给spring配置创建类对象。面向切面：Spring提供面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发（AOP）。容器：Spring包含并管理应用对象的配置和生命周期，可以配置每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以可以创建一个单独的实例，或每次需要都生成一个新的实例——以及他们是如何相互关联。框架：Spring框架可以将简单的组件配置，组合成为复杂的应用。在Spring应用对象被声明组合，典型是在一个XML文件里面，Spring也提供许多基础功能（事务管理，持久化框架集成，自己开发应用逻辑） 二、 Spring流程图 解析：这个图在Struts结构图的基础上加了spring流程图，在web.xml配置文件中加入了spring监听器，在Struts配置文件中添加是告知Struts2运行的时候使用spring来创建对象，spring在其中要做就是注入实例，将所有需要类的实例都由spring管理。 三、 深入了解Spring是一站式框架spring在Javaee三层结构： 每一层都提供不同的解决技术。 web层：SpringMVC service层：Spring的IOC DAO层：Spring的jdbcTemplate 该笔记的学习是基于spring4.x版本 业精于勤 ，荒于嬉；行成于思，毁于随 spring的IOC操作把对象创建交给spring进行管理ioc操作两部分： （1）IOC的配置文件方式 （2）IOC的注解方式 IOC的底层原理 xml配置文件 dom4j解决xml 工厂设计模式 反射 1234567public class UserService&#123;&#125;public class UserServlet&#123; //得到UserServlet的对象 //原始：new创建 uersFactory.getService();&#125; 第一步 创建xml配置文件，配置要创建对象类 &lt;bean id =&quot;userService&quot; class=&quot;cn.itcast.Userservice&quot;/&gt; 第三步 创建工厂类，使用dom4j解析配置+反射123456789101112public class Userfacorty&#123; //返回UserService对象的方法&#125;public static UserService getService()&#123; //使用dom4j解析xml文件 //根据id值userService,得到id值对应class属性值 String class = "class属性值"; class clazz= class.forname(classValue); //创建类对象 Userservice service =clazz.newInstance(); return service;&#125; 在创建spring配置文件的时候注意，spring核心配置和位置不是固定的，建议放到src下面，官方建议的名称叫applicationContext.xml 配置的时候引入schema约束可以在docs文档 →spring-framenwork-reference →html里找最后一个configuration.xsd里有 IOC和DI的区别 IOC：控制反转，把对象创建交给spring进行配置 DI ：依赖注入，向类里面的属性中设置值 关系：依赖注入不能单独存在，需要在IOC的基础上完成操作的。 Spring的Bean管理（XML配置文件）Bean实例化的三种方式使用类的无参数构造创建12&lt;!-- ioc入门 --&gt; &lt;bean id =&quot;user&quot; class=&quot;cn.itcast.ioc.User&quot;&gt;&lt;/bean&gt; 如果类里面没有无参数的构造，就会出现异常 使用静态工厂创建创建类的方法，返回类的对象123456public class Bean2Factory&#123; //静态方法，返回Bean2对象 public static Bean2 getBean2()&#123; return new Bean2(); &#125;&#125; 12&lt;!-- 使用静态工厂创建对象 --&gt;&lt;bean id=&quot;bean2&quot; class=&quot;cn.itcast.bean.Bean2Factory&quot; factory-method=&quot;getBean2&quot;&gt; 使用实例工厂创建创建不是静态的方法，返回类对象 123456public class Bean3Factory&#123; //普通的方法。返回bean3对象 public Bean3 getBean3()&#123; return new Bean3(); &#125;&#125; Bean的常用标签id属性起名称，不能包含特殊符号根据id值得到配置对象 class属性创建对象所在类的全路径 name属性根据属性值得到配置对象但在name属性里可以包含特殊符号现在不怎么用，都是旧版本的遗留问题 scope属性 singleton：默认值，单例 prototype：多例 request：创建对象把对象放到request域里面 session：创建对象把对象放到session域里面 globalSession：创建对象把对象放到globalSession里面 属性注入介绍创建对象的时候，向类里面属性设置值属性注入的三种方式 使用set方法123456public class User&#123; private String name; public void setName(String name)&#123; this.name = name; &#125;&#125; 12User user =new User();user.setName("abcd"); 使用有参数的结构注入123456public class User&#123; private String name; public User(String name)&#123; this.name = name; &#125;&#125; 1User user =new User("lucy"); 使用接口注入123public interface Dao&#123; public void delete(String name);&#125; 123456public class DaoImpl implements Dao&#123; private String name; public void delete (String name)&#123; this.name = name; &#125;&#125; 注意的地方在spring框架里面，支持前两种方式 set方法注入（重点） 有参数结构注入 使用有参数构造注入属性 1234&lt;!-- 使用有参数构造注入属性 --&gt;&lt;bean id =&quot;demo&quot; class =&quot;cn.itcast.property.PropertyDemo1&quot;&gt;&lt;!-- 使用有参数构造注入 --&gt;&lt;constructor-arg name=&quot;username&quot; value =&quot;tom&quot;&gt;&lt;/constructor-arg&gt; 1234567private String name ;public PropertyDemo1(String user name)&#123; this.username =username;&#125;public void test1&#123; System.out.println("demo1----"+username);&#125; 使用set方法注入属性（重点）12345private String bookname;//set 方法public void setBookname(String bookname)&#123; this.bookname =bookname;&#125; 1234567&lt;!-- 使用set方法注入属性 --&gt;&lt;bean id =&quot;book&quot; class =&quot;cn.itcast.property.Book&quot;&gt; &lt;!-- 注入属性 name属性值，类里面定义的属性名称 value属性：设置属性的值 --&gt; &lt;property name =&quot;bookname&quot; value =&quot;hamlet&quot;&gt;&lt;/property&gt; 注入 对象类型 属性（重点）创建service类和dao类 在service得到dao对象 具体的实现过程 在service 里面把dao作为类型属性 生成dao类型属性的set方法 12345678public class UserService&#123; //1定义dao类型属性 private UserDao userDao; //2生成set方法 public void setUserDao(UserDao userDao)&#123; this.userDao =userDao; &#125;&#125; 配置文件中注入关系123456789&lt;!-- 1配置service和dao对象 --&gt;&lt;bean id = &quot;userDao&quot; class =&quot;cn.itcast.ioc.UserDao&quot;&gt;&lt;/bean&gt;&lt;bean id= &quot;userService&quot; class =&quot;cn.itcast.ioc.Userservice&quot;&gt;&lt;!-- 注入dao对象name属性值：service类里面属性名称但是现在不要写value属性，因为之前的是字符串，现在是对象 。写ref属性：dao配置中的bena标签的id值--&gt;&lt;property name =&quot;userDao&quot; ref =&quot;userDao&quot;&gt;&lt;/property&gt; P名称空间注入修改配置文件，加入下面这一条 xmls : p =&quot;http://www.spring.framework.org/schema/p&quot; 然后再加入这条 &lt;!-- P名称空间注入 --&gt; &lt;bean id =&quot;person&quot; class= &quot;cn.itcast.property.Person&quot; p :name=&quot;Lucy&quot;&gt; 注入复杂类型属性 数组 list集合 map集合 properties类型123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- 注入复杂类型属性 --&gt;&lt;bean id = &quot;person&quot; class =&quot;cn.itcast.property.Person&quot;&gt;&lt;!-- 数组 --&gt;&lt;property name=&quot;arrs&quot;&gt; &lt;list&gt; &lt;value&gt;小王&lt;/value&gt; &lt;value&gt;小马&lt;/value&gt; &lt;value&gt;小宋&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!-- list --&gt;&lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;小奥&lt;/value&gt; &lt;value&gt;小金&lt;/value&gt; &lt;value&gt;小普&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!-- map --&gt;&lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;aa&quot; value=_lucy&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;bb&quot; value=&quot;mary&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;cc&quot; value=&quot;tom&quot;&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/property&gt;&lt;!-- properties --&gt;&lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driverclass&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;/bean&gt; Spring的bean管理（注释）关于注解 代码里特殊的标记，使用注解可以完成功能 注解写法 @ 注解名称（属性名称=属性值） 注解使用在类、方法属性上面注解开发准备 导入的基本包 导入jar包的时候要多一个sop的包 创建类、创建对象 在创建Spring配置文件，引入约束（1）做ioc基本功能，引入约束beans（2）做Spring的IOC注解发开，引入新的约束 开启注解扫描 注解创建对象 @Component：组件（作用在类上） 三个衍生注解 @ Controller：web层 @Service：业务层 @Repository :持久层目前这个四个功能差不多，只是为了区分用途，都是创建对象 创建是单实例还是多实例 @ scope（value=“prototype”） 注解注入属性第一个注解 @Autowired 创建service类，创建dao类123@Service (value="userService") public class Userservice &#123;&#125; 12345678@Component (value="userDao") //注解里的value可以不写//写成Component("userService")也是可以的public class UserDao &#123; public void add() &#123; System.out.println("Dao----") &#125;&#125; 在service里面定义dao类型属性123@Autowired private UserDao userDao; //使用注解的方法不需要set方法 注入属性第二个注解 @Resource123//name的属性值写注解创建dao对象，也就是写value值 @Resource(name="userDao") private UserDao userDao; Autowired和Resource的区别 @Resource默认按照名称方式进行bean匹配，@Autowired默认按照类型方式进行bean匹配,就是Autowired去匹配的时候是找类，不是名称，而Resource是按照名称来寻找。 Spring属于第三方的，J2EE是Java自己的东西。使用@Resource可以减少代码和Spring之间的耦合。 两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。 @Resource装配顺序：①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。 ②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。 ③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。 ④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。 配置文件和注解混合使用 在创建对象操作使用配置文件方式实现 1234&lt;!-- 配置对象 --&gt;&lt;bean id =&quot;bookService&quot; class=&quot;cn.itcast.xmlanno.BookService&quot;&gt;&lt;/bean&gt;&lt;bean id =&quot;ordersDao&quot; class= &quot;cn.itcast.xmlanno.OrdersDao&quot;&gt;&lt;/bean&gt;&lt;bean id =&quot;bookDao&quot; class =&quot;cn.itcast.xmlanno.BookDao&quot;&gt;&lt;/bean&gt; 注入属性的操作使用注解方式实现 12345//得到bookdao和ordersdao的对象@Resource(name="bookDao")private BookDao bookDao; @Resource(name="ordersDao")private OrdersDao ordersDao; AOPAOP概念 aop：面向切面（方面）编程，扩展功能不修改源代码实现 AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码 AOP原理下图是最原始方法和纵向抽取机制解决方法 AOP：横向抽取机制底层使用动态代理方式实现看下图 AOP操作术语 Joinpoint(连接点):类里面可以被增强的方法，这些方法称为连接点 Pointcut(切入点):所谓切入点是指我们要对哪些Joinpoint进行拦截的定义. Advice(通知/增强):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) Aspect(切面):是切入点和通知（引介）的结合 Introduction(引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field. Target(目标对象):代理的目标对象(要增强的类) Weaving(织入):是把增强应用到目标的过程.把advice 应用到 target的过程 Proxy（代理）:一个类被AOP织入增强后，就产生一个结果代理类 AOP操作 在Spring里面进行AOP操作，使用aspectj实现 aspectj不是spring一部分，和spring一起使用进行aop操作 Spring2.0以后新增了对AspectJ支持 使用aspectj实现aop有两种方式 基于aspectj的xml配置 基于aspectj的注解方式 AOP操作准备（包含引入约束） 除了最基本的jar包，还需要导入跟AOP相关的jar包 spring-aop-4.2.2.RELEASE.jar spring-aspects-4.2.2.RELEASE.jar后两个是要另外下载，不在spring包里面 aspectjweaver-1.8.7.jar aopalliance-1.0.jar 创建spring核心配置文件，导入aop的约束 在docs文档里面查找AOP的约束 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- bean definitions here --&gt; &lt;/beans&gt; 使用表达式配置切入点 切入点：实际增强的方法 常用的表达式execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;) execution(* cn.itcast.aop.Book.add(..))匹配cn.itcast.aop.Book.add的方法，参数用..表示 execution( cn.itcast.aop.Book.(..))匹配所有cn.itcast.aop.Book.*中的方法 execution( .*(..))匹配所有类中的所有方法 匹配所有save开头的方法 execution( save(..)) AOP配置1234567891011121314151617181920&lt;!-- 配置对象 --&gt;&lt;bean id =&quot;book&quot; class = &quot;cn.itcast.aop.Book&quot; &gt;&lt;/bean&gt;&lt;bean id =&quot;myBook&quot; class =&quot;cn.itcast.aop.MyBook&quot;&gt;&lt;/bean&gt;&lt;!-- 2配置AOP操作 --&gt; &lt;aop:config&gt; &lt;!-- 2.1配置切入点 --&gt; &lt;aop:pointcut expression=&quot;execution(* cn.itcast.aop.Book.add(..))&quot; id=&quot;pointcut1&quot;/&gt; &lt;!-- 注意在表达式前面第一个修饰符 * 号的后面要加空格 id值可以随便写，相当于起名字 --&gt; &lt;!-- 2.2配置切面,把增强用到方法上面 --&gt; &lt;aop:aspect ref=&quot;myBook&quot;&gt; &lt;!-- 配置增强类型 method:增强类里面选择哪个方法做前置 --&gt; &lt;aop:before method=&quot;before1&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 加入其他配置12public void around() &#123; System.out.println("环绕增强"); 12345&lt;aop:aspect ref=&quot;myBook&quot;&gt; &lt;!-- 配置增强类型 method:增强类里面选择哪个方法做环绕 --&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:aspect&gt; 输出结果 ： 环绕增强 这种方法应该是属于替换了原来的方法，但是如果修改了around的参数的话，效果很不同，就真的是环绕如下12345public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println("环绕增强之前"); proceedingJoinPoint.proceed(); System.out.println("之后");&#125; 然后配置文件不变输出结果： 环绕增强之前 add---------Book.java 之后 log4jlog4j介绍 通过log4j可以看到程序运行过程中更详细的信息 经常使用log4j查看日志 使用方法 导入log4j的jar包 复制log4j的配置文件，复制到src下面配置文件：log4j.properties 其中log4j.properties的内容中 log4j.rootLogger=info, stdout 是代表了日志级别 设置日志级别 info：看到基本信息 debug：看到更详细信息 Spring整合web项目原理基础原理加载Spring核心配置文件 new对象，功能可以实现，但是效率很低 实现思想：把加载配置文件和创建对象过程，在服务器启动时完成 实现原理 serlvletContext 对象 监听器 具体使用（1）在服务器启动时，为每一个项目创建一个servletContext对象（2）在servletContext 对象创建时，可以用监听器具体到servletContext对象在什么时候创建。（3）当使用监听器听到servletContext对象创建的时候，加载spring配置文件，创建配置对象。（4）把创建出来的对象放到ServletContext域对象里面（setAttribute方法）（5）获取对象时候，到ServletContext域得到 （getAttribute方法） web项目演示 演示问题 action 调用service，service调用dao 每次访问action的时候，都会加载spring配置文件功能没问题，可是性能不行123456信息: Deployment of web application directory C:\Program Files\Java\apache-tomcat-7.0.90\webapps\manager has finished in 90 msaction..........21:09:55,491 INFO ClassPathXmlApplicationContext:578 - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@4a3ef897: startup date [Wed Jul 25 21:09:55 CST 2018]; root of context hierarchy21:09:55,492 INFO XmlBeanDefinitionReader:317 - Loading XML bean definitions from class path resource [applicationContext.xml]service..........dao.......... 解决方案 在服务器启动的时候，创建对象加载配置文件 底层使用监听器，servletContext对象 spring里面不需要我们自己写代码，已经封装好了，这就是使用框架的好处 封装了一个监听器，只需要配置监听器就可以了 配置监听器之前，导入spring整合web项目jar包spring-web-4.2.4.RELEASE.jar 12&lt;!-- 配置监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 指定加载spring配置文件，因为默认是找不到位置的。 123&lt;!-- 指定spring配置文件位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立自己的博客]]></title>
    <url>%2Fposts%2F43831.html</url>
    <content type="text"><![CDATA[前言&nbsp; 苦于一直没有一个良好的学习习惯，感觉自己进步的效率太低，用IPad Pro加apple pen来手写也不行，字丑写的慢，即使记下来了也丑的不想回头看了。一天看到同学用 markdown来做笔记，美观而且很有条例，就想着学习着来搭一个博客来做笔记。GitHub上面可以提供代码托管，可以把自己的网站托管到GitHub上面，这样自己的学习成果就能在上面记录下来了。希望这种学习方法能对自己有所帮助。 一、初步准备1.github账户2 .电脑安装node.js、npmnode.js的下载网站一路默认吧 3 .安装了git for windowsgit的下载链接 基本一直next就行 二、搭建github博客1 .注册github账号2 .需要建立一个仓库注意的是仓库名字必须和账号名字一样，如果账号是admin，仓库名字也必须一样。 3 .在setting里面找到options按钮&nbsp; 看看Repository name名字是否改为账号名称，必须一摸一样，不然后面的步骤没法做。&nbsp; 然后往下拉，找到GitHub Pages里的Theme Chooser，随便选择一个主题先，这样就会出现我们的GitHub Pages的地址。 三、安装hexo1 .利用npm命令先桌面右键选择 Git Bash Here输入命令 npm install -g hexo 2 .初始化hexo先在自己想管理hexo博客框架的地方创建文件夹比如在D盘根目录下创建hexo文件夹在Git Bash里面输入命令 cd D:/hexo 然后再输入 hexo init 进行初始化 3 .修改配置文件找到_config.yml文件，然后打开修改里面的设置。并在最后面添加配置 deploy: type: git repo: https://github.com/Shelhon/Shelhon.github.io.git branch: master 其中repo里面的网址是自己的github上面的网址 4 .获取好看的主题在github上面比较高分好评的是next在Git Bash上面运行命令获取 git clone https://github.com/iissnan/hexo-theme-nextthemes/next 然后输入命令 hexo g hexo s 打开本地 localhost:4000 的页面，如果出现页面就成功。 5 .创建文章Git Bash在hexo目录下，输入 new post &quot;文章名称（最好英文）&quot; 就会在 source_posts\下出现 文章名称.md 文件 四、Github上面部署网站1. 安装hexo-deployer-git输入命令 npm install hexo-deployer-git --save 2. 发布到Github输入命令： hexo clean ps:如果修改了配置，打算在本地服务器运行试看的话，就建议每次修改后都clean一下，不然可能生效不了 然后再输入命令： hexo d -g 在第一次部署的时候，会出现下图的验证 这时候打开GitHub网站我们能看到仓库上已经更新了文件 3. 访问测试在浏览器输入：https://(github账户名字).github.io 能出现网页就算大功告成了。 至于如何绑定一个私人域名以及在过程中有些遇到的坑留以后再写一下。]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇]]></title>
    <url>%2Fposts%2F18842.html</url>
    <content type="text"><![CDATA[什么也不写先放一只猫镇楼]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>心情随笔</tag>
      </tags>
  </entry>
</search>
