<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线性代数笔记]]></title>
    <url>%2Fposts%2F35508c6a.html</url>
    <content type="text"><![CDATA[到底意难平 基于麻省理工公开课的线性代数这是一门关于矩阵理论和线性代数的基础课程。重点是在其他学科中有用的主题，包括方程组，向量空间，行列式，特征值，相似度，正定矩阵。 线性代数的概念对于理解机器学习背后的原理非常重要，尤其是在深度学习领域中。所以为了以后在工业大数据的方向里少一些疑惑，特地先预习一遍线性代数作为一个打基础的过程。 以下的每一章内容就按公开课的每一课时的内容来划分。 方程组的几何解释post18]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>数学</tag>
        <tag>预备知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC]]></title>
    <url>%2Fposts%2Fae0f95e0.html</url>
    <content type="text"><![CDATA[SpringMVC框架学习 一、SpringMVC框架 二、入门程序 三、SpringMVC与Mybatis整合 四、SpringMVC注解开发 五、SpringMVC与structs2的区别 post17 SpringMVC框架什么是SpringMVCspringmvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。 springmvc是一个基于mvc的web框架。 MVC在b/s系统下的应用MVC就是一个设计模式 SpringMVC框架 第一步：发起请求到前端控制器(DispatcherServlet) 第二步：前端控制器请求HandlerMapping查找 Handler 可以根据xml配置、注解进行查找 第三步：处理器映射器HandlerMapping向前端控制器返回Handler 第四步：前端控制器调用处理器适配器去执行Handler 第五步：处理器适配器去执行Handler 第六步：Handler执行完成给适配器返回ModelAndView 第七步：处理器适配器向前端控制器返回ModelAndViewModelAndView是springmvc框架的一个底层对象，包括 Model和view 第八步：前端控制器请求视图解析器去进行视图解析根据逻辑视图名解析成真正的视图(jsp) 第九步：视图解析器向前端控制器返回View 第十步：前端控制器进行视图渲染视图渲染将模型数据(在ModelAndView对象中)填充到request域 第十一步：前端控制器向用户响应结果 组件： 前端控制器DispatcherServlet（不需要程序员开发）作用接收请求，响应结果，相当于转发器，中央处理器。有了DispatcherServlet减少了其它组件之间的耦合度。 处理器映射器HandlerMapping(不需要程序员开发)作用：根据请求的url查找Handler 处理器适配器HandlerAdapter作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler 处理器Handler(需要程序员开发)注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler 视图解析器View resolver(不需要程序员开发)作用：进行视图解析，根据逻辑视图名解析成真正的视图（view） 视图View(需要程序员开发jsp)View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…） 入门程序准备需求：SpringMVC和Mybatis的商品订单案例模型 开发环境：Java 1.7ide：idea 数据库环境：四个表，items、orderdetail、orders、user spingmvc版本：3.2需求将spring3.2所有jar一起加进去 配置前端控制器在web.xml中配置 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;springmvcfirst1208&lt;/display-name&gt; &lt;!-- springmvc前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:/../config/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 第一种：*.action，访问以.action结尾 由DispatcherServlet进行解析 第二种：/，所以访问的地址都由DispatcherServlet进行解析，对于静态文件的解析需要配置不让DispatcherServlet进行解析 使用此种方式可以实现 RESTful风格的url 第三种：/*，这样配置不对，使用这种配置，最终要转发到一个jsp页面时， 仍然会由DispatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错。 --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 配置处理器适配器在classpath下的springmvc.xml中配置处理器适配器 12&lt;!-- 处理器适配器 所有处理器适配器都实现 HandlerAdapter接口 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter" /&gt; 通过查看原代码：123public boolean supports(Object handler) &#123; return handler instanceof Controller;&#125; 此适配器能执行实现 Controller接口的Handler。 123public interface Controller &#123; ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;&#125;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>数据库 - 学习 - SpringMVC - 框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis（二）]]></title>
    <url>%2Fposts%2Fc574728f.html</url>
    <content type="text"><![CDATA[Mybatis框架学习一、关联查询二、查询缓存三、与Spring整合四、Mybatis 逆向工程 关联查询商品订单数据模型数据模型分析思路 每张表记录的数据内容分模块对每张表记录的内容进行熟悉，相当于学习系统需求（功能）的过程 每张表数据库字段设置非空字段，外键字段 数据库级别表与表之间的关系外键关系 表与表之间的业务关系在分析表与表之间的业务关系时一定要建立在某个业务意义基础上去分析 数据模型的分析用户表User：记录了购买商品的用户信息 订单表orders:记录了用户所创建的订单 订单明细表odersdetail：记录了订单的详细信息，即购买的商品信息 商品表：items记录了商品信息 一对一查询查询订单信息，管理查询创建订单的与用户信息 注意：因为一个订单信息只会是一个人下的订单，所以从查询订单信息出发关联查询用户信 息为一对一查询。如果从用户信息出发查询用户下的订单信息则为一对多查询，因为一个用 户可以下多个订单。 方法一：使用 resultType定义订单信息 po 类，此 po 类中包括了订单信息和用户信息 sql语句 123SELECT orders.*, user.username, userss.address FROM orders, user WHERE orders.user_id=user.id 定义 po 类 1234public class OrdersCustom extends Orders &#123; private String username;// 用户名称 private String address;// 用户地址 get/set。。。 OrdersCustom 类继承 Orders 类后 OrdersCustom 类包括了 Orders 类的所有字段，只需要定义 用户的信息字段即可 Mapper.xml123456&lt;!-- 查询所有订单信息 --&gt; &lt;select id="findOrdersList" resultType="cn.itcast.mybatis.po.OrdersCustom"&gt; SELECT orders.*, user.username, user.address FROM orders,user WHERE orders.user_id = user.id &lt;/select&gt; Mapper 接口public List findOrdersList() throws Exception; 测试：12345678910Public void testfindOrdersList()throws Exception&#123; //获取session SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 UserMapper userMapper = session.getMapper(UserMapper.class); //查询订单信息 List&lt;OrdersCustom&gt; list = userMapper.findOrdersList(); System.out.println(list); //关闭session session.close(); 方法二：使用 resultMap定义专门的 resultMap 用于映射一对一查询结果。 SQL语句 123SELECT orders.*, user.username, user.address FROM orders, user WHERE orders.user_id=user.id 定义 po 类 在 Orders 类中加入 User 属性，user 属性中用于存储关联查询的用户信息，因为订单关联查询用户是一对一关系，所以这里使用单个 User 对象存储关联查询的用户信息。 Mapper.xml12345&lt;select id="findOrdersListResultMap" resultMap="userordermap"&gt; SELECT orders.*, user.username, user.address FROM orders,user WHERE orders.user_id = user.id &lt;/select&gt; 这里 resultMap 指定 userordermap 。 定义 resultMap:需要关联查询映射的是用户信息，使用 association 将用户信息映射到订单对象的用户属性中。12345678910111213&lt;!-- 订单信息resultmap --&gt; &lt;resultMap type=&quot;cn.itcast.mybatis.po.Orders&quot; id=&quot;userordermap&quot;&gt; &lt;!-- 这里的id，是mybatis在进行一对一查询时将user字段映射为user对象时要使用， 必须写 --&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;user_id&quot; column=&quot;user_id&quot;/&gt; &lt;result property=&quot;number&quot; column=&quot;number&quot;/&gt; &lt;association property=&quot;user&quot; javaType=&quot;cn.itcast.mybatis.po.User&quot;&gt; &lt;!-- 这里的id为user的id，如果写上表示给user的id属性赋值 --&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; association：表示进行关联查询单条记录property：表示关联查询的结果存储在 cn.itcast.mybatis.po.Orders 的 user 属性中javaType：表示关联查询的结果类型 ：查询结果的 user_id 列对应关联对象的 id 属性，这里是表示 user_id 是关联查询对象的唯一标识。 ：查询结果的 username 列对应 关联对象的 username 属性。 resultType 和resultMap小结实现一对一查询resultType：使用resultType简单，如果pojo中没有包括查询出来的列名，需要增加列名对应的属性，即可完成映射。如果没有查询结果的特殊要求，建议使用 resultMap：需要单独定义resultMap，实现有点麻烦，如果有对查询结果的特殊要求，使用resultMap可以完成将关联查询映射pojo的属性中 resultMap可以实现延迟加载，resultType不行。 一对多查询案例：查询所有订单信息及订单下的订单明细信息。订单信息与订单明细为一对多关系。使用 resultMap 实现如下： Sql 语句：123456789SELECT orders.*, user.username, user.address, orderdetail.idorderdetail_id, orderdetail.items_id, orderdetail.items_num FROM orders,user,orderdetailWHEREorders.user_id=user.id AND orders.id=orderdetail.orders_id 定义 po 类在 Orders 类中加入 User 属性。 在 Orders 类中加入 Listorderdetails 属性 Mapper.xml12345678910&lt;select id="findOrdersDetailList" resultMap="userorderdetailmap"&gt; SELECT orders.*, user.username, user.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num FROM orders,user,orderdetail WHERE orders.user_id = user.id AND orders.id = orderdetail.orders_id &lt;/select&gt; 定义 resultMap123456789101112131415161718&lt;!-- 订单信息resultmap --&gt; &lt;resultMap type="cn.itcast.mybatis.po.Orders" id="userorderdetailmap"&gt; &lt;id property="id"column="id"/&gt; &lt;result property="user_id" column="user_id"/&gt; &lt;result property="number" column="number"/&gt; &lt;association property="user" javaType="cn.itcast.mybatis.po.User"&gt; &lt;id property="id" column="user_id"/&gt; &lt;result property="username" column="username"/&gt; &lt;result property="address" column="address"/&gt; &lt;/association&gt; &lt;collection property="orderdetails" ofType="cn.itcast.mybatis.po.Orderdetail"&gt; &lt;id property="id" column="orderdetail_id"/&gt; &lt;result property="items_id" column="items_id"/&gt; &lt;result property="items_num" column="items_num"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; 前半部分和上边一对一查询订单及用户信息定义的 resultMap 相同， collection 部分定义了查询订单明细信息。 collection：表示关联查询结果集property=”orderdetails” ： 关联查询的结果集存储在 cn.itcast.mybatis.po.Orders 上哪个属性。ofType=”cn.itcast.mybatis.po.Orderdetail” ： 指定关联查询的结果集中的对象类型 即 List 中的对象类型。 及的意义同一对一查询。 resultMap 使用继承 上边定义的 resultMap 中上半部分和一对一查询订单信息的 resultMap 相同，这里使用继承 可以不再填写重复的内容，如下： 1234567&lt;resultMap type="cn.itcast.mybatis.po.Orders" id="userorderdetailmap" extends="userordermap"&gt; &lt;collection property="orderdetails" ofType="cn.itcast.mybatis.po.Orderdetail"&gt; &lt;id property="id" column="orderdetail_id"/&gt; &lt;result property="items_id" column="items_id"/&gt; &lt;result property="items_num" column="items_num"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; 使用 extends 继承订单信息 userordermap 。 Mapper 接口：public ListfindOrdersDetailList () throws Exception; 测试：1234567891011Public void testfindOrdersDetailList()throws Exception&#123; //获取session SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 UserMapper userMapper = session.getMapper(UserMapper.class); //查询订单信息List&lt;Orders&gt; list = userMapper.findOrdersDetailList(); System.out.println(list); //关闭session session.close();&#125; 小结使用 collection 完成关联查询，将关联查询信息映射到集合对象。 多对多查询查询用户和商品之间的信息 需求查询用户购买的商品信息。 SQL需要查询所有用户信息，关联查询订单及订单明细信息，订单明细信息中关联查询商品信息 123456789101112131415SELECT orders.*, USER.username, USER.address, orderdetail.idorderdetail_id, orderdetail.items_id, orderdetail.items_num, items.nameitems_name, items.detailitems_detail FROM orders, USER, orderdetail, items WHERE orders.user_id=USER.id AND orders.id=orderdetail.orders_id AND orderdetail.items_id=items.id po 定义在 User 中 添 加 List orders 属 性 ， 在 Orders 类 中 加 入 List orderdetails 属性 resultMap需要关联查询映射的信息是：订单、订单明细、商品信息订单：一个用户对应多个订单，使用 collection 映射到用户对象的订单列表属性中订单明细：一个订单对应多个明细，使用 collection 映射到订单对象中的明细属性中商品信息：一个订单明细对应一个商品，使用 association 映射到订单明细对象的商品属性中。 12345678910111213141516171819&lt;!-- 一对多查询 查询用户信息、关联查询订单、订单明细信息、商品信息 --&gt; &lt;resultMap type="cn.itcast.mybatis.po.User" id="userOrderListResultMap"&gt; &lt;id column="user_id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;collection property="orders" ofType="cn.itcast.mybatis.po.Orders"&gt; &lt;id column="id" property="id"/&gt; &lt;result property="number" column="number"/&gt; &lt;collection property="orderdetails" ofType="cn.itcast.mybatis.po.Orderdetail"&gt; &lt;id column="orderdetail_id" property="id"/&gt; &lt;result property="ordersId" column="id"/&gt; &lt;result property="itemsId" column="items_id"/&gt; &lt;result property="itemsNum" column="items_num"/&gt; &lt;association property="items" javaType="cn.itcast.mybatis.po.Items"&gt; &lt;id column="items_id" property="id"/&gt; &lt;result column="items_name" property="name"/&gt; &lt;result column="items_detail" property="detail"/&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/collection&gt; 小结一对多是多对多的特例，如下需求： 查询用户购买的商品信息，用户和商品的关系是多对多关系。需求 1： 查询字段：用户账号、用户名称、用户性别、商品名称、商品价格(最常见) 企业开发中常见明细列表，用户购买商品明细列表， 使用 resultType 将上边查询列映射到 pojo 输出。 需求 2： 查询字段：用户账号、用户名称、购买商品数量、商品明细（鼠标移上显示明细） 使用 resultMap 将用户购买的商品明细列表映射到 user 对象中。 resultMap 小结resultType： 作用： 将查询结果按照 sql 列名 pojo 属性名一致性映射到 pojo 中。场合： 常见一些明细记录的展示，比如用户购买商品明细，将关联查询信息全部展示在页面时， 此时可直接使用 resultType 将每一条记录映射到 pojo 中，在前端页面遍历 list（list 中是 pojo） 即可。 resultMap： 使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。association：作用： 将关联查询信息映射到一个 pojo 对象中。场合： 为了方便查询关联信息可以使用 association 将关联订单信息映射为用户对象的 pojo 属 性中，比如：查询订单及关联用户信息。使用 resultType 无法将查询结果映射到 pojo 对象的 pojo 属性中，根据对结果集查询遍 历的需要选择使用 resultType 还是 resultMap。collection：作用： 将关联查询信息映射到一个 list 集合中。场合：为了方便查询遍历关联信息可以使用 collection 将关联信息映射到 list 集合中，比如： 查询用户权限范围模块及模块下的菜单，可使用 collection 将模块映射到模块 list 中，将菜 单列表映射到模块对象的菜单 list 属性中，这样的作的目的也是方便对查询结果集进行遍历 查询。如果使用 resultType 无法将查询结果映射到 list 集合中。 延迟加载需要查询关联信息时，使用 mybatis 延迟加载特性可有效的减少数据库压力，首次查询 只查询主要信息，关联信息等用户获取时再加载。 打开延迟加载开关在 mybatis 核心配置文件中配置： lazyLoadingEnabled、aggressiveLazyLoading 设置项 描述 允许值 默认值 lazyLoadingEnabled 全局性设置懒加载，如果设为‘FALSE’，则所有相关联的都会被初始化加载 TRUE或FALSE FALSE aggressiveLazyLoading 当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载，否则，每个属性都按需加载 true 或false true 1234&lt;settings&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;/settings&gt; 一对一查询延迟加载查询订单信息，关联查询用户信息。 默认只查询订单信息当需要查询用户信息时再去查询用户信息。在查询订单的statement中使用association去延迟加载下边的statement关联查询用户信息 关联查询用户信息通过上边查询到的订单信息中的User_id去关联查询用户信息 Sql 语句：SELECT orders.* FROM orders 定义 po 类在 Orders 类中加入 User 属性。 Mapper.xml1234&lt;select id="findOrdersList3" resultMap="userordermap2"&gt; SELECT orders.* FROM orders &lt;/select&gt; 定义 resultMap1234567&lt;!-- 订单信息resultmap --&gt; &lt;resultMap type="cn.itcast.mybatis.po.Orders" id="userordermap2"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="user_id" column="user_id"/&gt; &lt;result property="number" column="number"/&gt; &lt;association property="user" javaType="cn.itcast.mybatis.po.User" select="findUserById" column="user_id"/&gt; &lt;/resultMap&gt; association： select=”findUserById”：指定关联查询 sql 为 findUserByIdcolumn=”user_id”：关联查询时将 users_id 列的值传入 findUserById最后将关联查询结果映射至 cn.itcast.mybatis.po.User 。 Mapper 接口：public List findOrdersList3() throws Exception; 测试：123456789101112131415Public void testfindOrdersList3()throws Exception&#123; //获取session SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 UserMapper userMapper = session.getMapper(UserMapper.class); //查询订单信息 List&lt;Orders&gt; list = userMapper.findOrdersList3(); System.out.println(list); //开始加载，通过orders.getUser方法进行加载 for(Orders orders:list)&#123; System.out.println(orders.getUser()); &#125; //关闭session session.close(); &#125; 延迟加载的思考不使用 mybatis 提供的延迟加载功能是否可以实现延迟加载？实现方法： 针对订单和用户两个表定义两个 mapper 方法。1、订单查询 mapper 方法2、根据用户 id 查询用户信息 mapper 方法默认使用订单查询 mapper 方法只查询订单信息。当需要关联查询用户信息时再调用根据用户 id 查询用户信息 mapper 方法查询用户信息。 查询缓存mybatis 缓存介绍 Mybatis 一级缓存的作用域是同一个 SqlSession，在同一个 sqlSession 中两次执行相同的 sql 语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取 数据将不再从数据库查询，从而提高查询效率。当一个 sqlSession 结束后该 sqlSession 中的 一级缓存也就不存在了。Mybatis 默认开启一级缓存。 Mybatis 二级缓存是多个 SqlSession 共享的，其作用域是 mapper 的同一个 namespace，不同 的 sqlSession 两次执行相同 namespace 下的 sql 语句且向 sql 中传递参数也相同即最终执行 相同的 sql 语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从 缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis 默认没有开启二级缓存 需要在 setting 全局参数中配置开启二级缓存。 一级缓存原理 下图是根据 id 查询用户的一级缓存图解： 一级缓存区域是根据 SqlSession 为单位划分的。每次查询会先从缓存区域找，如果找不到从数据库查询，查询到数据将数据写入缓存。 Mybatis 内部存储缓存使用一个 HashMap，key 为 hashCode+sqlId+Sql 语句。value 为 从查询出来映射生成的 java 对象 sqlSession 执行 insert、update、delete 等操作 commit 提交后会清空缓存区域。 测试 1123456789101112//获取session SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 UserMapper userMapper = session.getMapper(UserMapper.class); //第一次查询 User user1 = userMapper.findUserById(1); System.out.println(user1); //第二次查询，由于是同一个session则不再向数据发出语句直接从缓存取出 User user2 = userMapper.findUserById(1); System.out.println(user2); //关闭session session.close(); 测试 212345678910111213141516//获取session SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 UserMapper userMapper = session.getMapper(UserMapper.class); //第一次查询 User user1 = userMapper.findUserById(1); System.out.println(user1); //在同一个session执行更新 User user_update = new User(); user_update.setId(1); user_update.setUsername("李奎"); userMapper.updateUser(user_update); session.commit(); //第二次查询，虽然是同一个session但是由于执行了更新操作session的缓存被 清空，这里重新发出sql操作 User user2 = userMapper.findUserById(1); System.out.println(user2); 二级缓存原理下图是多个 sqlSession 请求 UserMapper 的二级缓存图解。 二级缓存区域是根据 mapper 的 namespace 划分的，相同 namespace 的 mapper 查询数据放 在同一个区域，如果使用 mapper 代理方法每个 mapper 的 namespace 都不同，此时可以理 解为二级缓存区域是根据 mapper 划分。 每次查询会先从缓存区域找，如果找不到从数据库查询，查询到数据将数据写入缓存。 Mybatis 内部存储缓存使用一个 HashMap，key 为 hashCode+sqlId+Sql 语句。value 为 从查询出来映射生成的 java 对象 sqlSession 执行 insert、update、delete 等操作 commit 提交后会清空缓存区域。 开启二级缓存：在核心配置文件 SqlMapConfig.xml 中加入 描述 允许值 默认值 cacheEnabled 对在此配置文件下的所有cache进行全局性开/关设置 true/false true 要在你Mapper 映射文件中添加一行： ，表示此 mapper 开启二级缓存。 实现序列化二级缓存需要查询结果映射的 pojo 对象实现 java.io.Serializable 接口实现序列化和反序 列化操作，注意如果存在父类、成员 pojo 都需要实现序列化接口。123publicclassOrdersimplementsSerializablepublicclassUserimplementsSerializable ... 测试12345678910111213141516//获取session1 SqlSession session1 = sqlSessionFactory.openSession(); UserMapper userMapper = session1.getMapper(UserMapper.class); //使用session1执行第一次查询 User user1 = userMapper.findUserById(1); System.out.println(user1); //关闭session1 session1.close(); //获取session2 SqlSession session2 = sqlSessionFactory.openSession(); UserMapper userMapper2 = session2.getMapper(UserMapper.class); //使用session2执行第二次查询，由于开启了二级缓存这里从缓存中获取数据不 再向数据库发出sql User user2 = userMapper2.findUserById(1); System.out.println(user2); //关闭session2 session2.close(); 禁用二级缓存在 statement 中设置 useCache=false 可以禁用当前 select 语句的二级缓存，即每次查询都会 发出 sql 去查询，默认情况是 true，即该 sql 使用二级缓存。 &lt;selectid=”findOrderListResultMap”resultMap=”ordersUserMap”useCache=”false”&gt; 刷新缓存在 mapper 的同一个 namespace 中，如果有其它 insert、update、delete 操作数据后需要刷新 缓存，如果不执行刷新缓存会出现脏读。 设置 statement 配置中的 flushCache=”true” 属性，默认情况下为 true 即刷新缓存，如果改成 false 则不会刷新。使用缓存时如果手动修改数据库表中的查询数据会出现脏读。 如下： &lt;insertid=”insertUser”parameterType=”cn.itcast.mybatis.po.User”flushCache=”true”&gt; MybatisCache 参数flushInterval（刷新间隔）可以被设置为任意的正整数，而且它们代表一个合理的毫秒形式 的时间段。默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新。 size（引用数目）可以被设置为任意正整数，要记住你缓存的对象数目和你运行环境的可用 内存资源数目。默认值是 1024。 readOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象 的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存会返回 缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。 如下例子： 这个更高级的配置创建了一个FIFO 缓存,并每隔60 秒刷新,存数结果对象或列表的 512 个引 用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会导致冲突。 可用的收回策略有,默认的是 LRU: LRU– 最近最少使用的:移除最长时间不被使用的对象。 FIFO– 先进先出:按对象进入缓存的顺序来移除它们。 SOFT– 软引用:移除基于垃圾回收器状态和软引用规则的对象。 WEAK– 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。 mybatis 整合 ehcacheEhCache 是一个纯 Java 的进程内缓存框架，是一种广泛使用的开源 Java 分布式缓存， 具有快速、精干等特点，是 Hibernate 中默认的 CacheProvider。原理： 通过实现 Cache 接口可以实现 mybatis 缓存数据通过其它缓存数据库整合，mybatis 的特长 是 sql 操作，缓存数据的管理不是 mybatis 的特长，为了提高缓存的性能将 mybatis 和第三方 的缓存数据库整合，比如 ehcache、memcache、redis 等。 第一步：引入缓存的依赖包 ehcache-core-2.6.5.jarmybatis-ehcache-1.0.2.jar Maven坐标： 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;/dependency&gt; 第二步：引入缓存配置文件 classpath 下添加：ehcache.xml 内容如下： 12345678910111213&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../config/ehcache.xsd"&gt; &lt;diskStore path="F:\develop\ehcache" /&gt; &lt;defaultCachemaxElementsInMemory="1000" maxElementsOnDisk="10000000" eternal="false" overflowToDisk="false" timeToIdleSeconds="120" timeToLiveSeconds="120" diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU"&gt; &lt;/defaultCache&gt; &lt;/ehcache&gt; 属性说明：diskStore ：指定数据在磁盘中的存储位置。defaultCache ：当借助 CacheManager.add(“demoCache”)创建 Cache 时，EhCache 便 会采用指定的的管理策略 以下属性是必须的： maxElementsInMemory - 在内存中缓存的 element 的最大数目 maxElementsOnDisk - 在磁盘上缓存的 element 的最大数目，若是 0 表示无穷大 eternal- 设定缓存的 elements 是否永远不过期。如果为 true，则缓存的数据始终有效， 如果为 false 那么还要根据 timeToIdleSeconds，timeToLiveSeconds 判断overflowToDisk - 设定当内存缓存溢出的时候是否将过期的 element 缓存到磁盘上 以下属性是可选的： timeToIdleSeconds - 当 缓 存 在 EhCache 中 的 数 据 前 后 两 次 访 问 的 时 间 超 过 timeToIdleSeconds 的属性取值时，这些数据便会删除，默认值是 0,也就是可闲置时间无穷 大 timeToLiveSeconds - 缓存 element 的有效生命期，默认是 0.,也就是 element 存活时间 无穷大 diskSpoolBufferSizeMB 这个参数设置 DiskStore(磁盘缓存)的缓存区大小.默认是 30MB.每个 Cache 都应该有自己的一个缓冲区. diskPersistent- 在 VM 重启的时候是否启用磁盘保存 EhCache 中的数据，默认是 false。 diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是 120 秒。每 个 120s，相应的线程会进行一次 EhCache 中数据的清理工作 memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的 element 加入的时候， 移 除缓存中 element 的策略。默认是 LRU（最近最少使用），可选的有 LFU（最不常使用）和 FIFO（先进先出） 第三步：开启 ehcache 缓存 EhcacheCache是ehcache对Cache接口的实现 修改mapper.xml文件，在cache中指定EhcacheCache1&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt; 根据需求调整缓存参数：123456789&lt;cache type="org.mybatis.caches.ehcache.EhcacheCache" &gt; &lt;property name="timeToIdleSeconds" value="3600"/&gt; &lt;property name="timeToLiveSeconds" value="3600"/&gt; &lt;!-- 同ehcache参数maxElementsInMemory --&gt; &lt;property name="maxEntriesLocalHeap" value="1000"/&gt; &lt;!-- 同ehcache参数maxElementsOnDisk --&gt; &lt;property name="maxEntriesLocalDisk" value="10000000"/&gt; &lt;property name="memoryStoreEvictionPolicy" value="LRU"/&gt; &lt;/cache&gt; 应用场景对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用 mybatis 二级缓 存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析 sql、电话 账单查询 sql 等。 实现方法如下：通过设置刷新间隔时间，由 mybatis 每隔一段时间自动清空缓存，根据 数据变化频率设置缓存刷新间隔 flushInterval，比如设置为 30 分钟、60 分钟、24 小时等， 根据需求而定。 局限性mybatis 二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进 行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如 果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新 其它商品的信息，因为 mybaits 的二级缓存区域以 mapper 为单位划分，当一个商品信息变 化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针 对性缓存。 spring与Mybatis整合实现 mybatis 与 spring 进行整合，通过 spring 管理 SqlSessionFactory、mapper 接口。 mybatis 与 spring 整合 jarmybatis 官方提供与 mybatis 与 spring 整合 jar 包：mybatis_spring-1.2.2.jar以及：spring3.2.0mybatis3.2.7dbcp连接池数据库驱动等 Mybatis配置文件在classpath下创建mybatis/SqlMapConfig.xml 12345678&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt;&lt;!-- 使用自动扫描器时，mapper.xml文件如果和mapper.java接口在一个目录则此处不用 定义mappers --&gt; &lt;mappers&gt; &lt;package name="cn.itcast.mybatis.mapper" /&gt; &lt;/mappers&gt; &lt;/configuration&gt; Spring 配置文件：在 classpath 下创建 applicationContext.xml，定义数据库链接池、SqlSessionFactory。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/contex t" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-3. 2.xsd http://www.springframework.org/schema/mvchttp://www.springframework.org/schema/mvc/spring-mvc-3.2.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-contex t-3.2.xsd http://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-3.2.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-3.2.xsd"&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location="classpath:db.properties"/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt;&lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="maxActive" value="10"/&gt; &lt;property name="maxIdle" value="5"/&gt; &lt;/bean&gt; &lt;!-- mapper配置 --&gt; &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包 中的 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 加载mybatis的全局配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis/SqlMapConfig.xml" /&gt; &lt;/bean&gt;&lt;/beans&gt; 注意：在定义 sqlSessionFactory 时指定数据源 dataSource 和 mybatis 的配置文件。 Mapper 编写的三种方法Dao 接口实现类继承 SqlSessionDaoSupport使用此种方法即原始 dao 开发方法，需要编写 dao 接口，dao 接口实现类、映射文件。 1、 在 sqlMapConfig.xml 中配置映射文件的位置 1234&lt;mappers&gt; &lt;mapperresource="mapper.xml 文 件 的 地 址 "/&gt;&lt;mapperresource="mapper.xml 文 件 的 地 址 "/&gt;&lt;/mappers&gt; 2、 定义 dao 接口3、dao 接口实现类集成 SqlSessionDaoSupportdao 接口实现类方法中可以 this.getSqlSession()进行数据增删改查。4、spring 配置 1234&lt;bean id=" "class="mapper 接 口 的 实 现 "&gt;&lt;property name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; 使用 org.mybatis.spring.mapper.MapperFactoryBean此方法即 mapper 接口开发方法，只需定义 mapper 接口，不用编写 mapper 接口实现类。 每个 mapper 接口都需要在 spring 配置文件中定义。 1、 在 sqlMapConfig.xml 中配置 mapper.xml 的位置 如果 mapper.xml 和 mappre 接口的名称相同且在同一个目录，这里可以不用配置 123&lt;mappers&gt; &lt;mapperresource="mapper.xml 文 件 的 地 址 "/&gt;&lt;mapperresource="mapper.xml 文 件 的 地 址 "/&gt;&lt;/mappers&gt; 2、 定义 mapper 接口 3、Spring 中定义 1234&lt;bean id="" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="mapper 接 口 地 址 "/&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"/&gt; &lt;/bean&gt; 使用 mapper 扫描器此方法即 mapper 接口开发方法，只需定义 mapper 接口，不用编写 mapper 接口实现类。 只需要在 spring 配置文件中定义一个 mapper 扫描器，自动扫描包中的 mapper 接口生成代 代理对象。 1、mapper.xml 文件编写，2、 定义 mapper 接口注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录 3、 配置 mapper 扫描器 1234&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="mapper 接 口 包 地 址 "&gt;&lt;/property&gt;&lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;/bean&gt; basePackage ： 扫 描 包 路 径 ， 中 间 可 以 用 逗 号 或 分 号 分 隔 定 义 多 个 包 4、 使用扫描器后从 spring 容器中获取 mapper 的实现对象 如果将 mapper.xml 和 mapper 接口的名称保持一致且放在一个目录 则不用在 sqlMapConfig.xml 中进行配置 Mybatis逆向工程Mybatis需要程序员自己编写SQL语句，Mybatis官方提供逆向工程，可以针对表单自动生成Mybatis执行所需要的代码（mappe.java ，mapper.xml ,po） 使用官方网站的 mapper 自动生成工具 mybatis-generator-core-1.3.2 来生成 po 类和 mapper 映射文件。 第一步：mapper 生成配置文件：在 generatorConfig.xml 中配置 mapper 生成的详细信息，注意改下几点： 1、 添加要生成的数据库表2、po 文件所在包路径3、mapper 文件所在包路径 配置文件如下： 详见 generatorSqlmapCustom 工程 第二步：使用 java 类生成 mapper 文件：123456789101112131415161718Public void generator() throws Exception&#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File("generatorConfig.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator (config, callback, warnings); myBatisGenerator.generate(null); &#125; Public static void main(String[] args) throws Exception &#123; try &#123; GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap(); generatorSqlmap.generator(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 第三步：拷贝生成的 mapper 文件到工程中指定的目录中Mapper.xml 的文件拷贝至 mapper 目录内 Mapper.java 的文件拷贝至 mapper 目录内 注意：mapperxml 文件和 mapper.java文件在一个目录内且文件名相同。 第四步 Mapper 接口测试学会使用 mapper 自动生成的增、删、改、查方法。 12345678910111213141516//删除符合条件的记录 int deleteByExample(UserExample example);//根据主键删除 int deleteByPrimaryKey(String id); //插入对象所有字段 int insert(User record); //插入对象不为空的字段 int insertSelective(User record); //自定义查询条件查询结果集 List&lt;User&gt; selectByExample(UserExample example); //根据主键查询 UserselectByPrimaryKey(String id); //根据主键将对象中不为空的值更新至数据库 int updateByPrimaryKeySelective(User record); //根据主键将对象中所有字段的值更新至数据库 int updateByPrimaryKey(User record); 逆向工程注意事项Mapper 文件内容不覆盖而是追加XXXMapper.xml 文件已经存在时，如果进行重新生成则 mapper.xml 文件内容不被覆盖而是进 行内容追加，结果导致 mybatis 解析失败。 解决方法：删除原来已经生成的 mapperxml 文件再进行生成。 Mybatis 自动生成的 po 及 mapper.java 文件不是内容而是直接覆盖没有此问题。 Tableschema 问题下边是关于针对 oracle 数据库表生成代码的 schema 问题： Schma 即数据库模式，oracle 中一个用户对应一个 schema，可以理解为用户就是 schema。 当 Oralce 数据库存在多个 schema 可以访问相同的表名时，使用 mybatis 生成该表的 mapper.xml 将会出现 mapper.xml 内容重复的问题，结果导致 mybatis 解析错误。 解决方法：在 table 中填写 schema，如下： &lt;tableschema=”XXXX”tableName=””&gt; XXXX 即为一个 schema 的名称，生成后将 mapper.xml 的 schema 前缀批量去掉，如果不去掉 当 oracle 用户变更了 sql 语句将查询失败。 快捷操作方式：mapper.xml 文件中批量替换：“fromXXXX.”为空 Oracle 查询对象的 schema 可从 dba_objects 中查询，如下： select * from dba_objects]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>Mybatis</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis（一）]]></title>
    <url>%2Fposts%2Fda3e1361.html</url>
    <content type="text"><![CDATA[Mybatis框架学习一、Mybatis入门二、Dao开发方法三、SqlMapConfig.xml 配置文件四、Mapper.xml 映射文件 Mybatis入门Mybatis开发dao两种方法：一、原始dao开发方法，需要编写dao接口和dao实现类（跟ibatis一样）二、Mybatis的mapper接口（相当于dao接口）代理开发方法。 原生JDBC程序的总结环境学习用的是JDK 1.7mysql:5.146 创建实验数据库从传智的课件里导入sql脚本生成数据库的表和数据里面有一些用户表、订单、订单细节、价格表 jdbc程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.sql.*;/** * @author: Shelhon * @create： 2018/9/17 14:31 * DESCRIPTION:通过单独的JDBC程序来总结其中的问题 */ public class JdbcTest &#123; public static void main(String[] args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; //加载数据库驱动 Class.forName("com.mysql.jdbc.Driver"); //通过驱动管理类获取数据库链接 connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mybatis?charac terEncoding=utf-8", "root", "12345"); //定义sql语句 ?表示占位符 String sql = "select * from user where username = ?"; //获取预处理statement preparedStatement = connection.prepareStatement(sql); //设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个 参数为设置的参数值 preparedStatement.setString(1, "王五"); //向数据库发出sql执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); //遍历查询结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString("id") + " " + resultSet.getString("username")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //释放资源 if(resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if (preparedStatement != null) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; //TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; jdbc编程步骤1、 加载数据库驱动2、 创建并获取数据库链接3、 创建 jdbcstatement 对象4、 设置 sql 语句5、 设置 sql 语句中的参数(使用 preparedStatement)6、 通过 statement 执行 sql 并获取结果7、 对 sql 执行结果进行解析处理 8、 释放资源(resultSet、preparedstatement、connection) 问题总结 数据库连接，使用时才创建，不用就立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响了数据库性能解决方案：使用数据库连接池来管理数据库连接 将sql语句硬编码到Java代码中，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动 需要改变 java 代码。 使用 preparedStatement 向占有位符号传参数存在硬编码，因为 sql 语句的 where 条件不 一定，可能多也可能少，修改 sql 还要修改代码，系统不易维护。 对结果集解析存在硬编码（查询列名） ，sql 变化导致解析代码变化，系统不易维护，如 果能将数据库记录封装成 pojo 对象解析比较方便。 Mybatis框架whatMyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者 只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建 statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。 Mybatis通过xml或注解的方式将要执行的各种statement（statement、 preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql 进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并 返回。 Mybatis 架构 1、mybatis 配置 SqlMapConfig.xml，此文件作为 mybatis 的全局配置文件，配置了 mybatis 的运行环境等信息。 mapper.xml 文件即 sql 映射文件，文件中配置了操作数据库的 sql 语句。此文件需要在 SqlMapConfig.xml 中加载。 2、 通过 mybatis 环境等配置信息构造 SqlSessionFactory 即会话工厂 3、 由会话工厂创建 sqlSession 即会话，操作数据库需要通过 sqlSession 进行。 4、mybatis 底层自定义了 Executor 执行器接口操作数据库，Executor 接口有两个实现，一个 是基本执行器、一个是缓存执行器。 5、Mapped Statement 也是 mybatis 一个底层封装对象，它包装了 mybatis 配置信息及 sql 映射信息等。mapper.xml 文件中一个 sql 对应一个 MappedStatement 对象，sql 的 id 即 是 Mappedstatement 的 id。 6、MappedStatement对sql执行输入参数进行定义，包括HashMap、基本类型、 pojo， Executor 通过 MappedStatement 在执行 sql 前将输入的 java 对象映射至 sql 中，输入参数映射就 是 jdbc 编程中对 preparedStatement 设置参数。 7、MappedStatement对sql执行输出结果进行定义，包括HashMap、基本类型、 pojo， Executor 通过 MappedStatement 在执行 sql 后将输出结果映射至 java 对象中，输出结果映射过程 相当于 jdbc 编程中对结果的解析处理过程。 入门程序需求根据用户 id 查询一个用户信息根据用户名称模糊查询用户信息列表添加用户更新用户删除用户 环境用jdk1.7idea创建Java工程，加入 mybatis 核心包、依赖包、数据驱动包。 基本配置文件log4j.properties：日志功能在 classpath 下创建 log4j.properties 如下： 12345# Global logging configuration log4j.rootLogger=DEBUG, stdout # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n mybatis 默认使用 log4j 作为输出日志信息。 SqlMapConfig.xml 在 classpath 下创建 SqlMapConfig.xml，如下： 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理--&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?characterEncoding=u tf-8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="mysql" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; SqlMapConfig.xml 是 mybatis 核心配置文件，上边文件的配置内容为数据源、事务管理。 po 类Po 类作为 mybatis 进行 sql 映射使用，po 类通常与数据库表对应，User.java 如下： 12345678public class User &#123; private int id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址//get/set……&#125; 接着就是程序编写 在 classpath 下的 sqlmap 目录下创建 sql 映射文件 Users.xml（这是属于ibatis的命名方式）： 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="test"&gt; &lt;!-- 在映射文件中配置很多sql语句 --&gt; &lt;!-- 需求：通过id查询用户表的记录 --&gt; &lt;!-- 通过select执行数据库查询 id:标识 映射文件中的sql 将sql语句封装到mappedStatement对象中，所以将id称为Statement的id parameterType :指定输入参数的类型，这里指定int型 #&#123;&#125;表示一个占位符 #&#123;id&#125;:其中的id是表示接入输入的参数，参数名称就是id，如果输入参数是简单类型，#&#123;&#125;中的参数名可以任意可以value或者其他名称 resultType ：指定sql输出结果的所映射的Java对象类型，select指定resultType表示单条记录映射的Java对象 --&gt; &lt;select id="findUserById" parameterType="int" resultType="mybatis.first.User"&gt; SELECT * FROM USER WHERE id=#&#123;id&#125; &lt;/select&gt;&lt;!-- 根据用户名称模糊查询用户信息，可能返回多条$&#123;&#125;：表示拼接sql串，将接受到的参数内容不加任何修饰拼接在sql中使用$&#123;&#125;拼接sql，可能会引起sql注入$&#123;value&#125;：接收输入参数的内容，如果传入类型是简单类型，$&#123;&#125;中只能使用value --&gt; &lt;select id="findUserByUsername" parameterType="String" resultType="mybatis.first.User"&gt; SELECT * FROM USER WHERE username LIKE '%$&#123;value&#125;%' &lt;/select&gt;&lt;/mapper&gt; namespace ：命名空间，用于隔离sql语句，在使用mapper代理开发的时候，namespace有特殊重要作用。 在SqlMapConfig.xml中配置User.xml123&lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;&lt;/mappers&gt; 测试程序MybatisFirst.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MybatisFirst &#123; //会话工厂 private SqlSessionFactory sqlSessionFactory; @Before public void createSqlSessionFactory() throws IOException &#123; // 配置文件 String resource = "SqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); // 使用SqlSessionFactoryBuilder从xml配置文件中创建 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; // 根据 id查询用户信息 @Test public void testFindUserById() &#123; // 数据库会话实例 SqlSession sqlSession = null; try &#123; // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 查询单个记录，根据用户id查询用户信息 User user = sqlSession.selectOne("test.findUserById", 10); // 输出用户信息 System.out.println(user); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; // 根据用户名称模糊查询用户信息 @Test public void testFindUserByUsername() &#123; // 数据库会话实例 SqlSession sqlSession = null; try &#123; // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 查询单个记录，根据用户id查询用户信息 List&lt;User&gt; list =sqlSession.selectList("test.findUserByUsername", "张"); System.out.println(list.size()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125;&#125; 添加用户在 SqlMapConfig.xml 中添加1234&lt;!-- 添加用户 --&gt; &lt;insert id="insertUser" parameterType="mybatis.first.User"&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 测试程序1234567891011121314@Test public void insertUserTest() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); // 插入用户对象 User user=new User(); user.setUsername("王小军"); user.setBirthday(new Date()); user.setSex("1"); user.setAddress("河南"); sqlSession.insert("test.insertUser",user); sqlSession.commit(); sqlSession.close(); &#125;&#125; 删除用户映射文件12345&lt;!-- 删除用户 根据id删除用户，需要输入id值 --&gt; &lt;delete id="deleteUser" parameterType="java.lang.Integer"&gt; delete from user where id =#&#123;id&#125; &lt;/delete&gt; 测试程序123456789// 删除id=30的用户 @Test public void deleteUserTest() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); // 删除用户对象 sqlSession.insert("test.deleteUser",30); sqlSession.commit(); sqlSession.close();&#125; 更新用户映射文件12345&lt;!-- 更新用户 需要传入用户id和更新信息 parameterType指定User对象，包括id和更新信息，id必须存在 #&#123;id&#125;:从输入User对象中获取id属性值 --&gt; &lt;update id="updateUser" parameterType="mybatis.first.User"&gt; update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; where id=#&#123;id&#125; &lt;/update&gt; 测试程序 12345678910111213141516// 更新用户 @Test public void updateUserTest() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); //更新用户 User user=new User(); user.setId(29); user.setUsername("王小军update"); user.setBirthday(new Date()); user.setSex("1"); user.setAddress("河南111"); sqlSession.insert("test.updateUser",user); System.out.println(user); sqlSession.commit(); sqlSession.close();&#125; 小结一、 #{}和${} #{}表示一个占位符号，通过#{}可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换，#{}可以有效防止 sql 注入。 #{}可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类型值，#{}括号中可以是 value 或其它名称。 $ {}表示拼接 sql 串，通过$ {}可以将 parameterType 传入的内容拼接在 sql 中且不进行 jdbc 类 型转换，${}可以接收简单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值， $ {}括号中只能是 value。 二、 parameterType 和 resultType parameterType：指定输入参数类型，mybatis 通过 ognl 从输入对象中获取参数值拼接在 sql 中。resultType：指定输出结果类型，mybatis 将 sql 查询结果的一行记录数据映射为 resultType 指定类型的对象。 三、 selectOne 和 selectList selectOne 查询一条记录，如果使用 selectOne 查询多条记录则抛出异常：123org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3 at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultS qlSession.java:70) selectList 可以查询一条或多条记录。 四、 mysql 自增主键返回12345678&lt;insert id="insertUser" parameterType="mybatis.first.User"&gt; &lt;!-- selectKey将主键返回，需要再返回 --&gt; &lt;selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer"&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;); &lt;/insert&gt; 添加 selectKey 实现将主键返回 keyProperty:返回的主键存储在 pojo 中的哪个属性order：selectKey 的执行顺序，是相对与 insert 语句来说，由于 mysql 的自增原理执行 完 insert 语句之后才将主键生成，所以这里 selectKey 的执行顺序为 after resultType:返回的主键是什么类型 LAST_INSERT_ID():是 mysql 的函数，返回 auto_increment 自增列新记录 id 值。 五、 Mysql 使用 uuid 实现主键 需要增加通过 selectuuid()得到 uuid 值执行过程：首先通过uuid()得到主键，将主键设置到User对象的id属性中其次在insert执行时，从User对象中取出id属性值 1234567&lt;insert id="insertUser" parameterType="mybatis.first.User"&gt; &lt;selectKey resultType="java.lang.String" order="BEFORE" keyProperty="id"&gt; select uuid() &lt;/selectKey&gt; insert into user(id,username,birthday,sex,address) values(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;/insert&gt; 注意这里使用的 order 是“BEFORE” 六、 Oracle 使用序列生成主键 首先自定义一个序列且用于生成主键，selectKey 使用如下：1234567&lt;insert id="insertUser" parameterType="mybatis.first.User"&gt; &lt;selectKey resultType="java.lang.String" order="BEFORE" keyProperty="id"&gt; SELECT 自定义序列.NEXTVAL FROM DUAL &lt;/selectKey&gt; insert into user(id,username,birthday,sex,address) values(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;/insert&gt; mybatis与hibernate的区别和应用hibernate：是一个标准的orm框架（对象关系映射），入门门槛比较高，不需要程序写sql，sql语句自动生成了。对SQL语句进行优化、修改比较困难。应用场景：适用于需求变化不多的中小型项目，比如：后台管理系统，erp,orm,oa等 Mybatis：专注sql本身，需要程序员自己编写SQL语句，SQL修改，优化比较方便，Mybatis是一个不完全的orm框架，虽然程序员自己写sql，但是Mybatis也可以实现映射（输入映射，输出映射）。应用场景：适用于需求变化较多的项目，比如，互联网项目 Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己 编写 Sql 语句，不过mybatis可以通过XML 或注解方式灵活配置要运行的 sql语句， 并将 java 对象和 sql 语句映射生成最终执行的 sql，最后将 sql 执行的结果再映射生成 java 对象。 Mybatis 学习门槛低，简单易学，程序员直接编写原生态 sql，可严格控制 sql 执行性能， 灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软 件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是 mybatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 sql映射文件，工作量大。 Hibernate 对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如 需求固定的定制化软件）如果用 hibernate 开发可以节省很多代码，提高效率。但是 Hibernate 的学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象模型之间如何权 衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行。 总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构 都是好架构，所以框架只有适合才是最好。 Dao 开发方法使用 Mybatis 开发 Dao，通常有两个方法，即原始 Dao 开发方法和 Mapper 接口开发方法 需求将下边的功能实现 Dao： 根据用户 id 查询一个用户信息根据用户名称模糊查询用户信息列表添加用户信息 SqlSession 的使用范围SqlSession 中封装了对数据库的操作，如：查询、插入、更新、删除等。 通过 SqlSessionFactory 创建 SqlSession，而 SqlSessionFactory 是通过 SqlSessionFactoryBuilder 进行创建。 SqlSessionFactoryBuilderSqlSessionFactoryBuilder 用于创建 SqlSessionFacoty，SqlSessionFacoty 一旦创建完成就不 需要 SqlSessionFactoryBuilder 了，因为 SqlSession 是通过 SqlSessionFactory 生产，所以可以 将 SqlSessionFactoryBuilder 当成一个工具类使用，不需要使用单例管理SqlSessionFactoryBuilder，在需要创建SqlSessionFactory的时候，只需要new一次SqlSessionFactoryBuilder即可，最佳使用范围是方法范围即方法体内局部变量。 SqlSessionFactorySqlSessionFactory是一个接口，接口中定义了openSession的不同重载方法 ， SqlSessionFactory 的最佳使用范围是整个应用运行期间，一旦创建后可以重复使用，通常以 单例模式管理 SqlSessionFactory。 SqlSessionSqlSession 是一个面向用户的接口， sqlSession 中定义了数据库操作，如：selectont（返回单个对象）、selectList（返回单个或多个对象）默认使用 DefaultSqlSession 实现类。 执行过程如下：1、 加载数据源等配置信息 Environmentenvironment=configuration.getEnvironment();2、 创建数据库链接3、 创建事务对象4、 创建 Executor，SqlSession 所有操作都是通过 Executor 完成，mybatis 源码如下： 12345678910if (ExecutorType.BATCH == executorType) &#123; executor = newBatchExecutor(this, transaction); &#125; elseif (ExecutorType.REUSE == executorType) &#123; executor = new ReuseExecutor(this, transaction); &#125; else &#123; executor = new SimpleExecutor(this, transaction);&#125;if (cacheEnabled) &#123; executor = new CachingExecutor(executor, autoCommit);&#125; 5、SqlSession 的实现类即 DefaultSqlSession，此对象中对操作数据库实质上用的是 Executor 结论： 每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不能共享使用，它也是 线程不安全的。因此最佳的范围是请求或方法范围。绝对不能将 SqlSession 实例的引用放在 一个类的静态字段或实例字段中。打开一个 SqlSession；使用完毕就要关闭它。通常把这个关闭操作放到 finally 块中以 确保每次都能执行关闭。如下： 123456SqlSessionsession=sqlSessionFactory.openSession(); try&#123; //dowork &#125;finally&#123; session.close();&#125; 原始 Dao 开发方式原始 Dao 开发方法需要程序员编写 Dao 接口和 Dao 实现类。 映射文件 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="test"&gt; &lt;!-- 根据id获取用户信息 --&gt; &lt;select id="findUserById" parameterType="int" resultType="cn.itcast.mybatis.po.User"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 添加用户 --&gt; &lt;insert id="insertUser" parameterType="cn.itcast.mybatis.po.User"&gt; &lt;selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer"&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;/insert&gt; &lt;/mapper&gt; Dao 接口123456789public interface UserDao &#123; //根据id查询用户信息 public User findUserById(int id) throws Exception; //添加用户信息 public void insertUser(User user) throws Exception; //删除用户信息 public void deleteUser(int id) throws Exception; 接口写完就写实现类 12345678910111213141516171819202122232425262728293031Public class UserDaoImpl implements UserDao &#123;//注入SqlSessionFactory public UserDaoImpl(SqlSessionFactory sqlSessionFactory)&#123; this.setSqlSessionFactory(sqlSessionFactory);&#125; private SqlSessionFactory sqlSessionFactory; @Override public User getUserById(int id) throws Exception &#123; SqlSession session = sqlSessionFactory.openSession(); User user = null; try &#123; //通过sqlsession调用selectOne方法获取一条结果集 //参数1：指定定义的statement的id,参数2：指定向statement中传递的参数 user = session.selectOne("test.findUserById", 1); System.out.println(user); &#125; finally&#123; session.close(); &#125; return user;&#125;@Override Public void insertUser(User user) throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); try &#123; sqlSession.insert("insertUser", user); sqlSession.commit(); &#125; finally&#123; session.close(); &#125; &#125;&#125; 测试程序 12345678910111213141516171819202122232425262728293031323334353637383940public class UserDaoImplTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void setUp() throws Exception&#123; //创建sqlSessionFactory //mabatis配置文件 String resource ="SqlMapConfig.xml"; //得到配置文件流 InputStream inputStream= Resources.getResourceAsStream(resource); //创建会话工厂，传入Mybatis的配置文件信息 sqlSessionFactory= new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void findUserById() throws Exception&#123; //创建UserDao对象 UserDao userDao= new UserDaoImpl(sqlSessionFactory); //调用UserDao方法 User user =userDao.findUserById(31); System.out.println(user); &#125; @Test public void insertUser() throws Exception&#123; UserDao userDao =new UserDaoImpl(sqlSessionFactory); //调用UserDao方法 User user= new User(); user.setAddress("gz"); user.setBirthday(new Date()); user.setUsername("abc1"); user.setSex("女"); userDao.insertUser(user); &#125; @Test public void deleteUser() throws Exception&#123; UserDao userDao =new UserDaoImpl(sqlSessionFactory); userDao.deleteUser(31); &#125;&#125; 原始 Dao 开发中存在以下问题： Dao 方法体存在重复代码：通过 SqlSessionFactory 创建SqlSession，调用 SqlSession的数据库操作方法 调用sqlSession的数据库操作方法需要指定statement的 id，这里存在硬编码，不利于开发维护。 mapper代理方法程序员只需要mapper接口，还需要编写mapper.xml映射文件 程序员编写mapper接口需要遵循一些开发规范，这样Mybatis可以自动生成mapper接口实现类代理对象 Mapper 接口开发需要遵循以下规范： Mapper.xml 文件中的 namespace 与 mapper 接口的类路径相同。 Mapper 接口方法名和 Mapper.xml 中定义的每个 statement 的 id 相同 Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的 parameterType 的 类型相同 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相 Mapper.xml(映射文件)12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="mybatis.mapper.UserMapper"&gt;&lt;!-- 在映射文件中配置很多sql语句 --&gt;&lt;!-- 需求：通过id查询用户表的记录 --&gt; &lt;select id="findUserById" parameterType="int" resultType="mybatis.first.User"&gt; SELECT * FROM USER WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id="findUserByUsername" parameterType="String" resultType="mybatis.first.User"&gt; SELECT * FROM USER WHERE username LIKE '%$&#123;value&#125;%' &lt;/select&gt; &lt;!-- 添加用户 --&gt; &lt;insert id="insertUser" parameterType="mybatis.first.User"&gt; &lt;!-- selectKey将主键返回，需要再返回 --&gt; &lt;selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer"&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;); &lt;/insert&gt; &lt;!-- 删除用户 根据id删除用户，需要输入id值 --&gt; &lt;delete id="deleteUser" parameterType="java.lang.Integer"&gt; delete from user where id =#&#123;id&#125;&lt;/delete&gt; &lt;!-- 更新用户 需要传入用户id和更新信息 parameterType指定User对象，包括id和更新信息，id必须存在 #&#123;id&#125;:从输入User对象中获取id属性值 --&gt; &lt;update id="updateUser" parameterType="mybatis.first.User"&gt; update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&lt;/update&gt;&lt;/mapper&gt; Mapper.java(接口文件)1234567891011121314package mybatis.mapper;import mybatis.first.User; public interface UserMapper &#123; //根据id查询用户信息 public User findUserById(int id) throws Exception; //添加用户信息 public void insertUser(User user) throws Exception; //删除用户信息 public void deleteUser(int id) throws Exception;&#125; 加载 UserMapper.xml 文件修改 SqlMapConfig.xml 文件： 123&lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="mapper/UserMapper.xml"/&gt;&lt;/mappers&gt; 测试程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class UserMapperTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void setUp() throws Exception &#123; //创建sqlSessionFactory //mabatis配置文件 String resource ="SqlMapConfig.xml"; //得到配置文件流 InputStream inputStream= Resources.getResourceAsStream(resource); //创建会话工厂，传入Mybatis的配置文件信息 sqlSessionFactory= new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void findUserById() throws Exception &#123; SqlSession sqlSession=sqlSessionFactory.openSession(); //创建UserMapper对象,mybatis自动生成mapper代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //调用UserMapper的方法 User user=userMapper.findUserById(1); System.out.println(user); &#125; @Test public void insertUser() &#123; SqlSession sqlSession=sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user=new User(); user.setSex("难"); user.setUsername("nan"); user.setBirthday(new Date()); user.setAddress("Bj"); userMapper.insertUser(user); sqlSession.commit();//少了这步会提交失败 sqlSession.close(); &#125; @Test public void deleteUser() &#123; SqlSession sqlSession=sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); userMapper.deleteUser(35); sqlSession.commit();//少了这步会提交失败 sqlSession.close(); &#125;&#125; 总结 selectOne 和 selectList动态代理对象调用sqlSession.selectOne()和sqlSession.selectList()是根据mapper接口方法的返 回值决定，如果返回 list 则调用 selectList 方法，如果返回单个对象则调用 selectOne 方法。 namespacemybatis 官方推荐使用 mapper 代理方法开发 mapper 接口，程序员不用编写 mapper 接口实 现类，使用 mapper 代理方法时，输入参数可以使用 pojo 包装对象或 map 对象，保证 dao 的通用性。 SqlMapConfig.xml配置内容SqlMapConfig.xml 中配置的内容和顺序如下： properties（属性） settings（全局配置参数） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境集合属性对象） environment（环境子属性对象） transactionManager（事务管理） dataSource（数据源） mappers（映射器） properties（属性）需求：将数据库连接参数单独配置在db.properties中，只需要在SqlMapConfig.xml中加载db.properties的属性值。在SqlMapConfig.xml中不需要对数据库连接参数硬编码。 db.properties文件123jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mybatis？characterEncoding=utf-8 jdbc.username=root jdbc.password=12345 SqlMapConfig.xml部分配置内容 12345678910111213141516171819&lt;configuration&gt; &lt;!-- 加载属性文件 --&gt; &lt;properties resource="db.properties"&gt; &lt;!-- properties中还可以配置一些属性名和属性值 --&gt; &lt;!-- 比如&lt;property name="jdbc.driver" value=""/&gt; --&gt; &lt;/properties&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理--&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 注意： MyBatis 将按照下面的顺序来加载属性： 在 properties 元素体内定义的属性首先被读取。 然后会读取 properties 元素中 resource 或 url 加载的属性，它会覆盖已读取的同名属 性。 最后读取 parameterType 传递的属性，它会覆盖已读取的同名属性。 因此，通过 parameterType 传递的属性具有最高优先级，resource 或 url 加载的属性次之， 最低优先级的是 properties 元素体内定义的属性。 建议：不要在properties元素体内体检任何属性值，只将属性值定义在properties文件中，在properties文件中定义属性名也要有一定的特殊性。 settings全局参数配置（配置）Mybatis在运行时可以调整一些运行参数 mybatis 全局配置参数，全局参数将会影响 mybatis 的运行行为。 比如：开启二级缓存，开启延迟加载 typeAliases(别名)在mapper.xml中，定义很多statement，statement需要parameterType指定输入参数的类型，需要resultType指定输出结果的映射类型。 如果在指定类型时输入类型全路径，不方便开发，可以针对parameterType或resultType指定类型定义一些别名，在mapper.xml中通过别名定义，方便开发 mybatis 支持别名：别名 映射的类型_byte byte_long long_short short_int int_integer int_double double_float float_boolean booleanstring Stringbyte Bytelong Longshort Shortint Integerinteger Integerdouble Doublefloat Floatboolean Booleandate Datedecimal BigDecimalbigdecimal BigDecimal 自定义别名在 SqlMapConfig.xml 中配置 1234567&lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias="user" type="cn.itcast.mybatis.po.User"/&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以）--&gt; &lt;package name="cn.itcast.mybatis.po"/&gt; &lt;package name=" 其 它 包 "/&gt;&lt;/typeAliases&gt; 1234567&lt;typeAliases&gt; &lt;!-- 批量别名定义 指定包名，Mybatis自动扫描包中的po类，自动定义别名，别名就是类名（首字母大写小写都可以） --&gt; &lt;package name="mybatis.first"/&gt;&lt;/typeAliases&gt; 也就是说只需要写到包名里，不用写到具体的类 typeHandlers类型处理器类型处理器用于 java 类型和 jdbc 类型映射，如下： 123&lt;select id="findUserById" parameterType="int" resultType="user"&gt; select * from user where id = #&#123;id&#125;&lt;/select&gt; mybatis 自带的类型处理器基本上满足日常需求，不需要单独定义。 mybatis 支持类型处理器： mappers(映射器)Mapper 配置的几种方法：使用相对于类路径的资源如： 使用完全限定路径如： 使用 mapper 接口类路径如： 注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。就是将mapper.java和mapper.xml放在一起且同名。 批量加载注册指定包下的所有 mapper 接口 如：实际测试似乎：这样也是可以加载的。注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。 Mapper.xml映射文件Mapper.xml 映射文件中定义了操作数据库的 sql，每个 sql 是一个 statement，映射文件 是 mybatis 的核心。 输入映射传递pojo对象Mybatis 使用 ognl 表达式解析对象字段的值，如下例子： 1234&lt;!—传递pojo对象综合查询用户信息 --&gt;&lt;select id="findUserByUser" parameterType="user" resultType="user"&gt; select * from user where id=#&#123;id&#125; and username like '%$&#123;username&#125;%' &lt;/select&gt; 上面的id和username是 user 对象中的字段名称。 传递pojo的包装对象开发中通过 pojo 传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件 还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对 象传递输入参数。 定义包装对象定义包装对象将查询条件(pojo)以类组合的方式包装起来。 1234public class UserQueryVo &#123; private User user; //自定义用户扩展类 private UserCustom userCustom; mapper.xml 映射文件在userMapper.xml中定义用户信息综合查询（查询条件复杂，通过高级查询进行）1234&lt;!-- 用户信息综合查询 --&gt; &lt;select id="findUserList" parameterType="mybatis.first.UserQueryVo" resultType="mybatis.first.UserCustom"&gt; select * from user where user.sex =#&#123;userCustom.sex&#125; and USER .username like '%$&#123;userCustom.username&#125;%'&lt;/select&gt; UserMapper.java12//用户信息综合查询 public List&lt;UserCustom&gt; findUserList(UserQueryVo userQueryVo) throws Exception; 测试程序12345678910111213141516@Test public void findUserList() throws Exception&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //创建包装对象，设置查询条件 UserQueryVo userQueryVo= new UserQueryVo(); UserCustom userCustom =new UserCustom(); userCustom.setSex("1"); userCustom.setUsername("张三丰"); userQueryVo.setUserCustom(userCustom); List&lt;UserCustom&gt; userCustoms=userMapper.findUserList(userQueryVo); System.out.println(userCustoms);&#125; 传递hashmapSql 映射文件定义如下:1234&lt;!-- 传递hashmap综合查询用户信息 --&gt;&lt;select id="findUserByHashmap" parameterType="hashmap" resultType="user"&gt; select * from user where id=#&#123;id&#125; and username like '%$&#123;username&#125;%' &lt;/select&gt; 其中id和username是hashmap的key 输出映射输出简单类型Mapper.xml 文件1234&lt;!-- 获取用户列表总数 --&gt; &lt;select id="findUserCount" parameterType="user" resultType="int"&gt; select count(1) from user &lt;/select&gt; 调用12345678910111213Public void testFindUserCount() throws Exception&#123; //获取session SqlSession session = sqlSessionFactory.openSession(); //获取mapper接口实例 UserMapper userMapper = session.getMapper(UserMapper.class);User user = new User(); user.setUsername("管理员");//传递Hashmap对象查询用户列表 int count = userMapper.findUserCount(user);//关闭session session.close();&#125; 总结： 输出简单类型必须查询出来的结果集有一条记录，最终将第一个字段的值转换为输出类型。 使用 session 的 selectOne 可查询单条记录。 输出 pojo 对象Mapper.xml 1234&lt;!-- 根据id查询用户信息 --&gt; &lt;select id="findUserById" parameterType="int" resultType="user"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; Mapper 接口1public User findUserById(int id) throws Exception; 测试123456789101112Public void testFindUserById() throws Exception &#123; //获取session SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 UserMapper userMapper = session.getMapper(UserMapper.class);//通过mapper接口调用statement User user = userMapper.findUserById(1); System.out.println(user); //关闭session session.close();&#125; 使用 session 调用 selectOne 查询单条记录。 输出 pojo 列表参考 selectUserByName 的定义： Mapper.xml1234&lt;!-- 根据名称模糊查询用户信息 --&gt; &lt;select id="findUserByUsername" parameterType="string" resultType="user"&gt; select * from user where username like '%$&#123;value&#125;%' &lt;/select&gt; Mapper 接口： 1public List&lt;User&gt; findUserByUsername(String username) throws Exception; 测试 1234567891011Public void testFindUserByUsername()throws Exception&#123; //获取session SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 UserMapper userMapper = session.getMapper(UserMapper.class); //如果使用占位符号则必须人为在传参数中加% //List&lt;User&gt; list = userMapper.selectUserByName("%管理员%"); //如果使用$&#123;&#125;原始符号则不用人为在参数中加% List&lt;User&gt; list = userMapper.findUserByUsername("管理员"); //关闭session session.close(); &#125; 使用 session 的 selectList 方法获取 pojo 列表。 resultType 总结：输出 pojo 对象和输出 pojo 列表在 sql 中定义的 resultType 是一样的。 返回单个 pojo 对象要保证 sql 查询出来的结果集为单条，内部使用 session.selectOne 方法调 用，mapper 接口使用 pojo 对象作为方法返回值。返回 pojo 列表表示查询出来的结果集可能为多条，内部使用 session.selectList 方法，mapper 接口使用 List对象作为方法返回值。 resultMapMybatis中使用resultMap完成高级输出结果映射 resultType 可以指定 pojo 将查询结果映射为 pojo，但需要 pojo 的属性名和 sql 查询的列 名一致方可映射成功。 如果 sql 查询字段名和 pojo 的属性名不一致，可以通过 resultMap 将字段名和属性名作 一个对应关系 ，resultMap 实质上还需要将查询结果映射到 pojo 对象中。 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包 括 pojo 和 list 实现一对一查询和一对多查询。 1、定义resultMap 2、使用resultMap作为statement的输出映射类型 动态sqlmybatis核心，对sql语句进行灵活操作，通过表达式判断，对sql进行灵活拼凑、组装 需求：用户信息综合查询列表和用户信息查询列表总数这两个statement的定义使用动态sql 对查询条件进行判断，如果输入参数不为空才进行查询 mapper.xml 1234567891011121314&lt;!-- 用户信息综合查询 --&gt; &lt;select id="findUserList" parameterType="mybatis.first.UserQueryVo" resultType="mybatis.first.UserCustom"&gt; select * from user &lt;where&gt; &lt;if test="userCustom!=null"&gt; &lt;if test="userCustom.sex!= null and userCustom.sex!=''"&gt; and user.sex =#&#123;userCustom.sex&#125; &lt;/if&gt; &lt;if test="userCustom.username!=null and userCustom.username !=''"&gt; and user.username like '%$&#123;userCustom.username&#125;%' &lt;/if&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 里面用到了where和if标签注意里面的要做不等于空字符串校验。 可以自动处理第一个 and。 Sql 片段Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的，如 下： mapper.xml 123456789101112&lt;!-- 定义sql片断 id:sql片断是唯一表示 经验：是基于单表来定义sql片断，这样的话这个sql片断可重用性才高 --&gt; &lt;sql id="query_user_where"&gt; &lt;if test="userCustom!=null"&gt; &lt;if test="userCustom.sex!= null and userCustom.sex!=''"&gt; and user.sex =#&#123;userCustom.sex&#125; &lt;/if&gt; &lt;if test="userCustom.username!=null and userCustom.username !=''"&gt; and user.username like '%$&#123;userCustom.username&#125;%' &lt;/if&gt; &lt;/if&gt;&lt;/sql&gt; 然后在where中使用 include 引用 1234567&lt;!-- 用户信息综合查询 --&gt; &lt;select id="findUserList" parameterType="mybatis.first.UserQueryVo" resultType="mybatis.first.UserCustom"&gt; select * from user &lt;where&gt; &lt;include refid="query_user_where"&gt;&lt;/include&gt; &lt;/where&gt;&lt;/select&gt; 注意：如果引用其它 mapper.xml 的 sql 片段，则在引用时需要加上 namespace，如下： &lt;include refid=”namespace.sql 片段”/&gt; foreach在用户查询列表和查询总数的statement中增加多个输入查询sql语句如下：①select * from user where id =1 or id =2 or id=3 ②select * from user where id IN(1,10,16) 现在要在输入参数类型中添加LISTids传入多个id UserQueryVo.java123public class UserQueryVo &#123; //传入多个id private List&lt;Integer&gt; ids; mapper.xml1234567891011121314151617181920212223&lt;sql id="query_user_where"&gt; &lt;if test="userCustom!=null"&gt; &lt;if test="userCustom.sex!= null and userCustom.sex!=''"&gt; and user.sex =#&#123;userCustom.sex&#125; &lt;/if&gt; &lt;if test="userCustom.username!=null and userCustom.username !=''"&gt; and user.username like '%$&#123;userCustom.username&#125;%' &lt;/if&gt; &lt;if test="ids!=null"&gt; &lt;!-- 使用foreach来遍历传入ids collection：指定输入对象中集合属性 item：每个遍历生成对象 open：开始遍历时拼接的串 close：结束遍历时拼接的串 separator：遍历的两个对象中需要拼接的串 --&gt; &lt;foreach collection="ids" item="id" open="and (" close=")" separator="or"&gt; &lt;!-- 每个遍历需要拼接的串 --&gt; id =#&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/if&gt;&lt;/sql&gt; 测试程序 12345678910111213141516@Test public void findUserList() throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //创建包装对象，设置查询条件 UserQueryVo userQueryVo = new UserQueryVo(); UserCustom userCustom = new UserCustom(); //传入多个id List&lt;Integer&gt; ids= new ArrayList&lt;Integer&gt;(); ids.add(1); ids.add(8); ids.add(26); userQueryVo.setIds(ids); userQueryVo.setUserCustom(userCustom); List&lt;UserCustom&gt; userCustoms = userMapper.findUserList(userQueryVo); System.out.println(userCustoms);&#125; 一开始的第二种查询的实现方式1234 &lt;foreach collection="ids" item="id" open="and id IN (" close=")" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/if&gt;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
        <tag>Mybatis</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统篇]]></title>
    <url>%2Fposts%2F3b200332.html</url>
    <content type="text"><![CDATA[系统篇内容 post14]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库开发]]></title>
    <url>%2Fposts%2F90c77d0c.html</url>
    <content type="text"><![CDATA[设计与应用开发内容 一、关系数据理论二、数据库设计三、数据库编程 关系数据理论问题的提出一 、关系模式 关系模式是一个五元组。 R &lt; U，D ，dom , F &gt; （1）关系名R，它是符号化的元组语义； （2）一组属性U； （3）属性组U中属性所来自的域D； （4）属性到域的映射dom； （5）属性组U上的一组数据依赖F。即属性值间的相互关连 由于（3），（4）对模式设计关系不大，因此在本章中把关系模式看作是一个三元组： R &lt;U，F&gt; 当且仅当U上的一个关系 r 满足 F 时，r 称为关系模式R&lt;U，F&gt;的一个关系。 第一范式（1NF）：关系模式中每一个分量必须是不可分的数据项。满足了这个条件的就属于第一范式（1NF）。 二、 数据依赖 数据依赖是数据库模式设计的关键，它是一个关系内部属性与属性之间的一种约束关系，这种约束关系是通过属性间的值是否相等体现出来的数据间的相互关系。它是现实世界属性间相互联系的抽象，是数据内在的性质，是语义的体现。数据依赖有很多类型，其中最重要的是：函数依赖（Functional Dependency，简记为FD）多值依赖（Multivalued Dependency，简记为MVD） 其中，函数依赖起着核心的作用，是模式分解和模式设计的基础，范式是模式分解的标准。 比如描述一个学生的关系，可以有学号（SNO），姓名（SNAME），系名（SDEPT）等几个属性。由于一个学号只对应一个学生，一个学生只在一个系学习。因而当“学号”值确定之后，姓名和该生所在系的值也就被唯一地确定了。就象自变量x确定之后，相应的函数值f(x)也就唯一地确定了一样，称SNO函数决定SNAME和SDEPT，或者说SNAME，SDEPT函数依赖于SNO，记为：SNO→SNAME，SNO→SDEPT。 例 现在要建立一个数据库来描述学生的一些情况，面临的对象有：单一的关系模式Student（U,F） U={SNO，SDEPT，MN，CNAME，G} SNO 学号，SDEPT 系，MN 系负责人，CNAME 课程名，G 成绩 由现实世界的已知事实得知： ①一个系有若干学生，但一个学生只属于一个系； ②一个系只有一名（正职）负责人； ③一个学生可以选修多门课程，每门课程有若干学生选修； ④每个学生学习每一门课程有一个成绩； 于是得到属性组U上的一组函数依赖： F={SNO→SDEPT，SDEPT→MN，（SNO，CNAME）→G} 这组函数依赖如图 如果只考虑函数依赖这一种数据依赖，就得到了一个描述学校的数据库模式S&lt;U,F&gt;，它由一个单一的关系模式构成。这个模式有下述三个“毛病”： （1）插入异常 :如果一个系刚成立尚无学生，或者虽然有了学生但尚未安排课程。那么就无法把这个系及其负责人的信息存入数据库。 （2）删除异常: 如果某个系的学生全部毕业了，在删除该系学生选修课程的同时，把这个系及其负责人的信息也丢掉了。 （3）冗余太大。比如，每一个系负责人的姓名要与该系每一个学生的每一门功课的成绩出现的次数一样多。这样，一方面浪费存储，另一方面系统要付出很大的代价来维护数据库的完整性。比如某系负责人更换后，就必须逐一修改有关的每一个元组。 由于上述三个“毛病”，它是一个“不好”的数据库模式。一个“好”的模式应当不会发生插入异常和删除异常、冗余应尽可能少。 这个单一的模式改造一下，分成三个关系模式： S（SNO，SDEPT，SNO→SDEPT）； SG（SNO，CNAME，G，（SNO，CNAME）→G）； DEPT（SDEPT，MN，SDEPT→MN）； 这三个模式就不会发生插入异常、删除异常的毛病，数据的冗余也得到了控制。 规范化规范化理论正是用来改造关系模式的，通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题。 函数依赖一、定义设R(U)是一个属性集U上的关系模式，X和Y是U的子集。 若对于R(U)的任意一个可能的关系 r，r 中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X函数确定Y” 或 “Y函数依赖于X”，记作X→Y。 X称为这个函数依赖的决定属性集(Determinant)。 Y = f(x) 说明： 函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的所有关系实例均要满足的约束条件。 函数依赖是语义范畴的概念，只能根据数据的语义来确定函数依赖。例如：“姓名→年龄”这个函数依赖只有在不允许有同名人的条件下成立。 数据库设计者可以对现实世界作强制的规定。例如规定不允许同名人出现，函数依赖“姓名→年龄”成立。所插入的元组必须满足规定的函数依赖，若发现有同名人存在， 则拒绝装入该元组。 例如Student ( Sno, Sname, Ssex, Sage, Sdept ) 中 假设不允许学生重名，则有: Sno → Ssex， Sno → Sage , Sno → Sdept， Sno ← → Sname, Sname → Ssex， Sname → Sage Sname → Sdept 但Ssex ！→ Sage 若X→Y，并且Y→X, 则记为X← →Y。 若Y不函数依赖于X, 则记为X ！→Y。 二、术语和记号： X→Y，但Y⊈ X则称X→Y是 非平凡的函数依赖。若不特别声明，总是讨论非平凡的函数依赖。 X→Y，但Y⊆X则称X→Y是 平凡的函数依赖。 若X→Y，则X叫做决定因素（Determinant）。 若X→Y，Y→X，则记作X←→Y。 若Y函数不依赖于X，则记作X ！→Y。 例：在关系SC（Sno, Cno, Grade）中， 非平凡函数依赖： (Sno, Cno) → Grade 平凡函数依赖： (Sno, Cno) → Sno (Sno, Cno) → Cno 三、完全依赖和部分依赖 ｐ而(Sno ,Cno )→Sdept是部分函数依赖，因为Sno→Sdept成立，而Sno是(Sno ,Cno )真子集 四、传递函数依赖 码 设K为关系模式R&lt;U,F&gt;中的属性或属性组合。 若K → U，则K称为R的一个候选码（Candidate Key）。 若关系模式R有多个候选码，则选定其中的一个作为主码（Primary key）。 包含在任何一个候选码中的属性，称为主属性（Prime attribute）； 不包含在任何码中的属性，称为非主属性（Nonprime attribute）或非码属性（Non-key attribute）。 例 :关系模式S（Sno，Sdept，Sage）中单个属性Sno是码，用下横线表示出来。SC（Sno，Cno，Grade）中属性组合（Sno，Cno）是码 极端的情况是：整个属性组U是码，即所有属性当作一个码。若关系中只有一个候选码,且这个候选码中包含全部属性,则该候选码为全码，称为全码（All-key）。 例：关系模式R（P，W，A），属性P表示演奏者，W表示作品，A表示听众。假设一个演奏者可以演奏多个作品,某一作品可被多个演奏者演奏。听众也可以欣赏不同的演奏者的不同作品，这个关系的码为（P，W，A），即All-Key。 关系模式 R 中属性或属性组X 并非 R的码，但 X 是另一个关系模式的码，则称 X 是R 的外部码（Foreign key），也称外码。主码和外码一起提供了表示关系间联系的手段。 例如上面的关系模式S于SC的联系就是通过Sno来体现的。 例如 在SC（Sno，Cno，Grade）中，Sno不是码，但Sno是关系模式S（Sno，Sdept，Sage）的码，则Sno是关系模式SC的外部码。 范式关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。范式的种类包括： 满足最低要求的，称为第一范式(1NF) 在第一范式中，满足进一步要求的，称为第二范式(2NF) 以此类推：第三范式(3NF) BC范式(BCNF) 第四范式(4NF) 第五范式(5NF)某一关系模式R为第n范式，可简记为R∈nNF 5NF⊂4NF⊂BCNF⊂3NF⊂2NF⊂1NF 各模式之间的联系如下图 一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化 一、 第一范式（1NF） 关系中的每个分量必须是不可分的数据项。满足了这个条件的关系模式R就属于第一范式（1NF），记作 R∈1NF。 第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。 满足第一范式的关系模式并不一定是一个好的关系模式。 例如 关系模式 SLC（Sno, Sdept, Sloc, Cno, Grade） Sloc为学生住处，假设每个系的学生住在同一个地方。 SLC的码为(Sno, Cno)非主属性Sdept和Sloc部分函数依赖于码(Sno, Cno)SLC ∈1NF ，但是SLC并不是一个好的关系模式。 ①插入异常假设Sno＝’95102’，Sdept＝’IS’，Sloc＝’N’ 的学生还未选课，因课程号是主属性，因此该学生的信息无法插入SLC。②删除异常假定某个学生本来只选修了3号课程这一门课。现在因身体不适，他连3号课程也不选修了。因课程号是主属性，此操作将导致该学生信息的整个元组都要删除。③数据冗余度大如果一个学生选修了10门课程，那么他的Sdept和Sloc值就要重复存储10次。④修改复杂例如学生转系，在修改此学生元组的Sdept值的同时，还可能需要修改住处（Sloc）。如果这个学生选修了n门课，则必须无遗漏地修改n个元组中全部Sdept、Sloc信息。 造成这些问题的原因是：Sdept、 Sloc部分函数依赖于码。 解决方法：将SLC分解为两个关系模式，以消除这些部分函数依赖 关系模式分解应当具有无损连接性和依赖保持性 SC（Sno， Cno， Grade）SL（Sno， Sdept， Sloc） 二、第二范式（2NF） 定义 ：若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的码，则R∈2NF。 例SLC(Sno, Sdept, Sloc, Cno, Grade) ∈1NFSLC(Sno, Sdept, Sloc, Cno, Grade) ∉ 2NFSC（Sno， Cno， Grade） ∈ 2NFSL（Sno， Sdept， Sloc） ∈ 2NF 采用投影分解法将一个1NF的关系分解为多个2NF的关系，可以在一定程度上减轻原1NF关系中存在的插入异常、删除异常、数据冗余度大、修改复杂等问题。但是，将一个1NF关系分解为多个2NF的关系，并不能完全消除关系模式中的各种异常情况和数据冗余。 三、第三范式（3NF） 如果R∈3NF，则R∈2NF。 采用投影分解法将一个2NF的关系分解为多个3NF的关系，可以在一定程度上解决原2NF关系中存在的插入异常、删除异常、数据冗余度大、修改复杂等问题。但是，将一个2NF关系分解为多个3NF的关系后，并不能完全消除关系模式中的各种异常情况和数据冗余。 四、BCNF BCNF是修正的第三范式，有时也称为扩充的第三范式。 设关系模式R&lt;U，F&gt;∈1NF，如果对于R的每个函数依赖X→Y，若Y不属于X，则X必含有候选码，那么R∈BCNF。 也就是说，关系模式R&lt;U,F&gt;中，若每一个决定因素都包含码 若R∈BCNF，则： 每一个决定属性集（因素）都包含（候选）码 R中的所有属性（主属性和非主属性）都完全函数依赖于码 R∈3NF（由定义可知，排除了任何属性对码的传递依赖和部分依赖） 但是，若R∈3NF，R不一定∈BCNF 例 在关系模式C（Cno，Cname，Pcno）中，只有一个码Cno。 由于没有任何属性对Cno部分依赖或传递依赖，所以C∈3NF； 同时C中Cno是唯一的决定因素，所以C∈BCNF。 例 关系模式 S（Sno, Sname, Sdept, Sage）中，假定Sname具有唯一性，那么S就有两个码（Sno和Sname），这两个码都由单个属性组成，彼此不相交。 其他属性不存在对码的传递依赖与部分依赖，所以S∈3NF； 同时S中除Sno和Sname以外没有其他决定因素，所以S∈BCNF。 例 关系模式 SJP（S, J, P）中，S表示学生，J表示课程，P表示名次。每个学生选修每门课程的成绩有一定的名次，每门课程中的每一名次只有一个学生（即没有并列名次）。由语法可以得到下面的函数依赖： （S, J） → P，（J, P） → S 所以（S, J）和（J, P）都可以作为候选码，这两个码各由两个属性组成，而且它们是相交的。 这个关系模式中显然没有属性对码的传递依赖或部分依赖。所以SJP∈3NF； 而且除了（S, J）和（J, P）以外没有其他的决定因素，所以SJP∈BCNF。 例 在关系模式STJ（S，T，J）中，S表示学生，T表示教师，J表示课程。每一教师只教一门课。每门课由若干教师教，某一学生选定某门课，就确定了一个固定的教师。某个学生选修某个教师的课就确定了所选课的名称。则有如下的函数依赖：（S，J）→ T，（S，T）→ J，T → J这里(S，J)和(S，T)都可以作为候选码 ，S、T、J都是主属性没有任何非主属性对码的传递依赖或部分依赖，所以STJ∈3NF；由于T→J，T是决定因素，而T不是候选码，所以STJ∉BCNF。 非BCNF的关系模式也可以通过分解成为BCNF。可分解为ST（S，T）TJ（T，J） 它们都是BCNF。 3NF和BCNF是在函数依赖的条件下对模式分解所能达到的分离程度的测度。一个模式中的关系模式如果都属于BCNF，那么在函数依赖范畴内，它已实现了彻底的分离，已消除了插入和删除的异常。3NF的“不彻底”性表现在可能存在主属性对码的部分依赖和传递依赖。 五、多值依赖 属于BCNF的关系模式是否就很完美了呢？下面来看一个例子。 例如 学校中某一门课程由多个教员讲授，他们使用相同的一套参考书。每个教员可以讲授多门课程，每种参考书可以供多门课程使用。可以用一个非规范化的关系来表示教员T，课程C和参考书B之间的关系（如表6.1所示）。 关系模型TEACHING（C，T，B）的码是（C，T，B），即All-Key。因而TEACHINGÎBCNF。 对数据的增删改很不方便，数据的冗余也十分明显。仔细考察这类关系模式，发现它具有一种称之为多值依赖（MVD）的数据依赖。 定义 ：设R（U）是属性集U上的一个关系模式。X，Y，Z是U的子集，并且Z=U-X-Y。关系模式R（U）中多值依赖X→→Y成立，当且仅当对R（U）的任一关系r，给定的一对（x,z）值，有一组Y的值，这组值仅仅决定于x值而与z值无关。 若X→→Y，而Z=f即Z为空，则称X→→Y为平凡的多值依赖 多值依赖具有以下性质： （1）多值依赖具有对称性。即若X→→Y，则X→→Z，其中Z=U-X-Y。 （2）多值依赖的传递性。即若X→→Y，Y→→Z，则X→→Z-Y。 （3）函数依赖可以看作是多值依赖的特殊情况。即若X→Y，则X→→Y。 （4）若X→→Y，X→→Z，则X→→YZ。 （5）若X→→Y，X→→Z，则X→→Y∩Z。 （6）若X→→Y，Y→→Z，则X→→Y-Z，X→→Z-Y。 多值依赖与函数依赖相比，具有下面两个基本的区别： （1）多值依赖的有效性与属性集的范围有关。 若X→→Y在U上成立则在W（XY⊆W⊆U）上一定成立；反之则不然，即X→→Y在W（W⊂U）上成立，在U上并不一定成立。这是因为多值依赖的定义中不仅涉及属性组X和Y，而且涉及U中其余属性Z。 一般地，在R（U）上若有X→→Y在W（W⊂U）上成立，则称X→→Y为R（U）的嵌入型多值依赖。 但是在关系模式R（U）中函数依赖X→Y的有效性仅决定于X，Y这两个属性集的值。只要在R（U）的任何一个关系r中，元组在X和Y上的值满足函数依赖的定义，则函数依赖X→Y在任何属性集W（XY⊆W⊆U）上成立。 （2）若函数依赖X→Y在R（U）上成立，则对于任何Y’⊂Y均有X→Y’成立。而多值依赖X→→Y若在R（U）上成立，却不能断言对于任何Y⊂Y有X→→Y’成立。 六、4NF 定义 关系模式R&lt;U，F&gt;∈1NF，如果对于R的每个非平凡多值依赖X→→Y（Y⊈X），X都含有码，则称R&lt;U,F&gt;∈4NF。 4NF就是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。因为根据定义，对于每一个非平凡的多值依赖X→→Y，X都含有候选码，于是就有X→Y，所以4NF所允许的非平凡的多值依赖实际上是函数依赖。 如果一个关系模式是4NF，则必为BCNF。 关系模式WSC的码是（W，S，C），即All-Key。WSC∈BCNF 但WSC∉ 4NF。 一个关系模式如果已达到了BCNF但不是4NF，这样的关系模式仍然具有不好的性质。数据冗余及插入、修改、删除异常等问题。因此还应该继续规范化使关系模式WSC达到4NF。 可以用投影分解的方法消去非平凡且非函数依赖的多值依赖。 例如可以把WSC分解为WS（W，S），WC（W，C）。在WS中虽然有W→→S，但这是平凡的多值依赖。WS中已不存在非平凡的非函数依赖的多值依赖。所以WS∈4NF。 函数依赖和多值依赖是两种最重要的数据依赖。如果只考虑函数依赖，则属于BCNF的关系模式规范化程度已经是最高的了。如果考虑多值依赖，则和多值依赖之外，还有其他数据依赖。例如有一种连接依赖。函数依赖是多值依赖的一种特殊情况，而多值依赖实际上又是连接依赖的一种特殊情况。但连接依赖不像函数依赖和多值依赖可由语义直接导出，而是在关系的连接运算时才反映出来。存在连接依赖的关系模式仍可能遇到数据冗余及插入、修改、删除异常等问题。如果消除了属于4NF的关系模式中存在的连接依赖，则可以进一步达到5NF的关系模式。 规范化小结规范化的基本思想为： 逐步消除不合适的数据依赖，使各关系模式达到某种程度的“分离”，即采用“一事一地”的模式设计原则：让一个关系描述一个概念、一个实体或者实体间的一种联系。若多于一个概念就把它“分离”出去。 因此，所谓规范化实质上是概念的单一化。 此外，并不能说规范化程度越高的关系模式就越好。 在设计数据库模式结构时，必须对现实世界的实际情况和用户应用需求作进一步分析，确定一个合适的、能够反映现实世界的模式。上面的规范化步骤可以在其中任何一步终止。 在实际应用中，最有价值的是3NF和BCNF，在进行关系模式的设计时，通常分解到3NF就足够了。 数据依赖的公理系统数据依赖的公理系统是模式分解算法的理论基础，下面首先讨论函数依赖的一个有效而完备的公理系统——Armstrong公理系统。其用途是： 求给定关系模式的码 从一组函数依赖求得蕴含的函数依赖 。 定义 对于满足一组函数依赖 F 的关系模式R &lt;U, F&gt;，其任何一个关系 r，若函数依赖 X→Y 都成立（即 r 中任意两个元组 t 和 s，若 t[X] = s[X]，则 t[Y] = s[Y]）, 则称 F 逻辑蕴含 X →Y。 Armstrong公理系统 设U为属性集总体，F是U上的一组函数依赖，于是有关系模式R&lt;U,F&gt;。对R&lt;U,F&gt;来说有以下的推理规则： A1自反律（Reflexivity）：若Y⊆X⊆U，则X→Y为F所蕴含。 A2增广律（Augmentation）：若X→Y为F所蕴含，且Z⊆U，则X∪Z→Y∪Z为F所蕴含。 A3传递律（Transitivity）：若X→Y及Y→Z为F所蕴含，则X→Z为F所蕴含。 注意：由自反律所得到的函数依赖均是平凡的函数依赖，自反律的使用并不依赖于F。 证明Armstrong推理规则的正确性： 自反律：若 Y ⊆ X ⊆ U，则 X → Y 为F所蕴含。证明:设 Y ⊆ X ⊆ U，对R &lt;U，F&gt; 的任一关系 r 中的任意两个元组 t和s，有：若 t[X] = s[X]，由于Y ⊆X，必定有 t[Y] =s[Y]，所以 X→Y成立。自反律得证。 增广律：若 X→Y 为F所蕴含，且 Z ⊆ U，则 X∪Z → Y∪Z 为F所蕴含。证明:设 X→Y 为F所蕴含，且Z ⊆ U。设R&lt;U，F&gt; 的任一关系 r 中任意的两个元组 t和s有：若 t[XZ] = s[XZ]，则有 t[X] = s[X] 和 t[Z] = s[Z]。因为X→Y，则有 t[Y] = s[Y]，所以 t[YZ] = s[YZ]，所以XZ→YZ为F所蕴含 。增广律得证。 传递律：若 X→Y 及 Y→Z 为F所蕴含，则 X→Z 为F所蕴含。证明:设 X→Y 及 Y→Z 为F所蕴含。则对R&lt;U，F&gt; 的任一关系 r 中的任意两个元组 t和s有：若 t[X] = s[X]，由于 X→Y，必定有 t[Y] = s[Y]；再由 Y→Z，可知有 t[Z] = s[Z]，所以 X→Z 为F所蕴含 。传递律得证。 根据A1，A2，A3这三条推理规则可以得到下面三条推理规则：合并规则：由 X→Y，X→Z，有 X→YZ。（A2， A3）伪传递规则：由 X→Y，WY→Z，有 XW→Z。（A2， A3）分解规则：由 X→Y 及 Z⊆Y，有 X→Z。（A1， A3）根据合并规则和分解规则，可得: X→A1 A2 … Ak 成立的充分必要条件是: X→Ai 成立（i=1，2，…，k）。 小结：一组用于推导函数依赖的规则：若Y ⊆ X， 则X→Y若X→Y，则XZ →YZ若X→Y, Y →Z，则X→Z若X→Y, X →Z，则X →YZ若X→Y, WY →Z，则XW →Z若X→Y, Z ⊆Y，则X →Z若X →YZ，则X→Y, X →Z 在关系模式R&lt;U,F&gt;中为F所逻辑蕴含的函数依赖的全体叫做F的闭包，记为F+。 人们把自反律，传递律和增广律称为Armstrong公理系统。Armstrong公理系统是有效的、完备的。Armstrong公理的有效性指的是：由F出发根据Armstrong公理推导出来的每一个函数依赖一定在F+中；完备性指的是F+中的每一个函数依赖，必定可以由F出发根据Armstrong公理推导出来。 要证明完备性，就首先要解决如何判定一个函数依赖是否属于由F根据Armstrong公理推导出来的函数依赖的集合。当然，如果能求出这个集合，问题就解决了。但不幸的是，这是一个NP完全问题。比如从F={X→A1，…，X→An}出发，至少可以推导出2n个不同的函数依赖为此引入了下面的概念： 设F为属性集U上的一组函数依赖，X⊆U，X+F={A|X→A 能由 F 根据 Armstrong 公理导出}，X+F 称为属性集X关于函数依赖集F的闭包。 设F为属性集U上的一组函数依赖，X，Y⊆U，X→Y能由F根据Armstrong公理导出的充分必要条件是Y⊆XF+。 是，判定X→Y是否能由F根据Armstrong公理导出的问题，就转化为求出XF+，判定Y是否为XF+的子集的问题。这个问题由下面的算法解决了。 算法 ： 求属性集X（X⊆U）关于U上的函数依赖集F的闭包XF+。 输入：X，F 输出：XF+ 步骤： （1）令X（0）=X，i=0 （2）求B，这里B={A |（∃V）（∃W）（V→W ∈ F ∧ V ⊆ X （i） ∧ A ∈W）； （3）X（i+1）=B∪X（i） （4）判断X（i+1） =X（i）吗？ （5）若相等或X（i+1）=U，则X（i+1）就是XF+，算法终止。 （6）若否，则i=i+1，返回第（2）步。 例 书籍关系模式R&lt;U,F&gt;， 其中U={A，B，C，D，E}；F={AB→C，B→D，C→E，EC→B，AC→B}。 求（AB）F+。 解 由算法，设X（0）=AB； 计算X（1）；逐一扫描F集合中各个函数依赖，找左部为A，B或AB的函数依赖。得到两个：AB→C，B→D。于是X（1）=AB∪CD=ABCD。 因为X（0） ≠ X（1），所以再找出左部为ABCD子集的那些函数依赖，又得到C→E ，AC→B，于是X（2） = X（1）∪ABCDE 因为X（2）已等于全部属性集合，所以（AB）F+=ABCDE。 对于算法， 令ai=| X（i）|,{a（i）}形成一个步长大于1的严格递增的序列，序列的上界是|U|，因此该算法最多|U|-|X|次循环就会终止。 例： 证明完备性的逆否命题，即若函数依赖X→Y不能由F从Armstrong公理导出，那么它必然不为F所蕴含，它的证明分三步。 模式的分解把低一级的关系模式分解为若干个高一级的关系模式的方法并不是唯一的，只有能够保证分解后的关系模式与原关系模式等价，分解方法才有意义 对于一个模式的分解是多种多样的，但是分解后产生的模式应当与原模式等价。从不同的角度去看，“等价”有三种不同的定义： 分解具有“无损连接性” 分解要“保持函数依赖” 分解既要“保持函数依赖”，又要具有“无损连接性” 这3个定义是实行分解的3条不同的准则 例如: SL（Sno， Sdept， Sloc）F = { Sno → Sdept, Sdept → Sloc, Sno → Sloc }SL∈2NF Sno Sdept Sloc 95001 CS A 95002 IS B 95003 MA C 95004 IS B 95005 PH B 该模式存在插入异常、删除异常、冗余度大和修改复杂等问题。 将SL分解为下面三个关系模式：SN(Sno)SD(Sdept)SO(Sloc)分解后的数据库丢失了许多信息。例如无法查询95001学生所在系或所在宿舍。如果分解后的关系可以通过自然连接恢复为原来的关系，那么这种分解就没有丢失信息。 将SL分解为下面两个关系模式：NL(Sno, Sloc)DL(Sdept, Sloc)NL ⋈ DL比原来的SL关系多了3个元组，无法知道95002、95004、95005究竟是哪个系的学生 。元组增加了，信息丢失了 。 将SL分解为下面两个关系模式：ND(Sno, Sdept)NL(Sno, Sloc)与SL关系一样，因此没有丢失信息，但仍存在插入、删除和更新异常 将SL分解为下面两个关系模式：ND(Sno, Sdept)DL(Sdept, Sloc)与SL关系一样，因此没有丢失信息，并且也没有插入、删除和更新异常 所以第四种是比较合适的模式分解。 具有无损连接性的模式分解对于关系模式R&lt;U,F&gt;的一个分解 ρ = { R1&lt;U1, F1&gt;，R2&lt;U2, F2&gt;， …，Rn&lt;Un, Fn&gt;}若R与R1, R2, …, Rn自然连接的结果相等，则称关系模式R的这个分解ρ具有无损连接性（Lossless join）。具有无损连接性的分解保证不丢失信息。但是，无损连接性不一定能解决插入异常、删除异常、修改复杂、数据冗余等问题。 定理设 ρ={ R1(U1), R2(U2 )} 是 R(U) 的一个分解则ρ为无损分解的充分必要条件为：(U1∩U2) →(U1-U2) 或 (U1∩U2) →(U2-U1) 保持函数依赖的模式分解设关系模式 R&lt;U, F&gt;被分解为若干个关系模式： R1&lt;U1, F1&gt;，R2&lt;U2, F2&gt;， …，Rn&lt;Un, Fn&gt; （其中U=U1∪U2∪…∪Un，且不存在Ui ⊆ Uj，Fi为F在Ui上的投影）若F所有逻辑蕴含的函数依赖一定也由分解得到的某个关系模式中的函数依赖Fi所逻辑蕴含，则称关系模式R的这个分解是保持函数依赖的（Preserve dependency）。判断一个分解是否保持依赖检查每一个原来的依赖关系是否在子模式依赖关系的并的闭包内，涉及如何求一个属性集X的闭包XF+ 模式分解小结 如果一个分解具有无损连接性，则它能够保证不丢失信息。 如果一个分解保持了函数依赖，则它可以减轻或解决各种异常情况。 分解具有无损连接性和分解保持函数依赖是两个互相独立的标准。 具有无损连接性的分解不一定能够保持函数依赖。 同样，保持函数依赖的分解也不一定具有无损连接性。 上面例子中（分解 SL(Sno， Sdept， Sloc)）： 第一种分解方法： SN(Sno)，SD(Sdept)，SO(Sloc)既不具有无损连接性，也未保持函数依赖，它不是原关系模式的一个等价分解。 第二种分解方法：NL(Sno, Sloc)，DL(Sdept, Sloc)既未保持了函数依赖，也不具有无损连接性。 第三种分解方法：ND(Sno, Sdept)，NL(Sno, Sloc)具有无损连接性，但未持函数依赖。 第四种分解方法： ND(Sno, Sdept)，DL(Sdept, Sloc)既具有无损连接性，又保持了函数依赖。 小结 在规范化过程中，逐渐消除存储异常，使数据冗余尽量小，便于插入、删除和更新。规范化的基本原则就是遵从概念单一化“一事一地”的原则，即一个关系只描述一个实体或者实体间的联系。 规范化的投影分解方法不是唯一的，对于3NF的规范化，分解既要具有无损连接性，又要具有函数依赖保持性。 规范化理论为数据库设计提供了理论的指南和工具。 并不是规范化程度越高，模式就越好，必须结合应用环境和现实世界的具体情况合理地选择数据库模式。 数据库设计数据库设计概述数据库设计是指对于一个给定的应用环境，构造最优的数据库模式，建立数据库及其应用系统，使之能够有效地存储数据，满足各种用户的应用需求（信息要求和处理要求） 在数据库领域内，常常把使用数据库的各类系统统称为数据库应用系统。数据库是信息系统的核心和基础，它把信息系统中大量的数据按一定的模型组织起来，提供存储、维护、检索数据的功能，使信息系统可以方便、及时、准确地从数据库中获得所需信息。 数据库是信息系统的各个部分能否紧密地结合在一起以及如何结合的关键所在，数据库设计是信息系统开发和建设的重要组成部分。 数据库设计人员应该具备的技术和知识有： 数据库的基本知识 数据库设计技术 计算机科学的基础知识 程序设计的方法和技巧 软件工程的原理和方法 应用领域的知识 数据库设计的特点数据库结构（数据）设计与行为（处理）设计相结合 数据库的结构设计 数据库的结构设计指是根据给定的应用环境，进行数据库的模式或子模式的设计。它包括数据库的概念设计、逻辑设计和物理设计。 数据库模式是各应用程序共享的结构，是静态的、稳定的，一经形成后通常情况下是不容易改变的，所以结构设计又称为静态模型设计。 数据库的行为设计 数据库的行为设计是指确定数据库用户的行为和动作。而在数据库系统中，用户的行为和动作指用户对数据库的操作，这些要通过应用程序来实现，所以数据库的行为设计就是应用程序的设计。 用户的行为总是使数据库的内容发生变化，所以行为设计是动态的，行为设计又称为动态模型设计。 数据库设计方法数据库设计方法目前可分为四类： 直观设计法 规范设计法 计算机辅助设计法 自动化设计法 一、直观设计法直观设计法也叫手工试凑法，它是最早使用的数据库设计方法。这种方法依赖于设计者的经验和技巧，缺乏科学理论和工程原则的支持，设计的质量很难保证，常常是数据库运行一段时间后又发现各种问题，这样再重新进行修改，增加了系统维护的代价。因此，这种方法越来越不适应信息管理发展的需要。 二、规范设计法也称为新奥尔良法，它是目前公认的比较完整和权威的一种规范设计法。新奥尔良法将数据库设计分成需求分析（分析用户需求）、概念设计（信息分析和定义）、逻辑设计（设计实现）和物理设计（物理数据库设计）。其基本思想是：过程迭代和逐步求精。下面简单介绍几种常用的规范设计方法。 基于E-R模型的数据库设计方法该方法是在需求分析的基础上，用E-R图构造一个反映现实世界实体之间联系的企业模式，然后再将此企业模式转换成基于某一特定的DBMS的概念模式。 基于3NF的数据库设计方法该方法是在需求分析的基础上，确定数据库模式中的全部属性和属性间的依赖关系，将它们组织在一个单一的关系模式中，然后再分析模式中不符合3NF的约束条件，将其进行投影分解，规范成若干个3NF关系模式的集合。 基于视图的数据库设计方法该方法先从分析各个应用的数据着手，其基本思想是为每个应用建立自己的视图，然后再把这些视图汇总起来合并成整个数据库的概念模式。 计算机辅助设计法ORACLE Designer 2000SYBASE PowerDesigner 数据库设计的基本步骤和其他软件一样，数据库的设计过程可以使用软件工程中的生存周期的概念来说明，称为“数据库设计的生存期”，它是指从数据库研制到不再使用它的整个时期。 按规范设计法可将数据库设计分为六个阶段： 系统需求分析阶段 概念结构设计阶段 逻辑结构设计阶段 物理设计阶段 数据库实施阶段 数据库运行与维护阶段 一、系统需求分析阶段 需求分析是整个数据库设计过程的基础，要收集数据库所有用户的信息内容和处理要求，并加以规格化和分析。 这是最费时、最复杂的一步，但也是最重要的一步，相当于待构建的数据库大厦的地基，它决定了以后各步设计的速度与质量。需求分析做得不好，可能会导致整个数据库设计返工重做。 在分析用户需求时，要确保用户目标的一致性。 二、概念结构设计阶段 概念设计是把用户的信息要求统一到一个整体逻辑结构中，此结构能够表达用户的要求，是一个独立于任何DBMS软件和硬件的概念模型。 这个阶段是整个数据库设计的关键所在。 三、逻辑结构设计阶段 逻辑设计是将上一步所得到的概念模型转换为某个DBMS所支持的数据模型，并对其进行优化。 四、物理设计阶段 物理设计是为逻辑数据模型建立一个完整的能实现的数据库结构，包括存储结构和存取方法。 五、数据库实施阶段 设计人员根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。 六、数据库运行与维护阶段 这一阶段主要是收集和记录实际系统运行的数据，数据库运行的记录用来提高用户要求的有效信息，用来评价数据库系统的性能，进一步调整和修改数据库。 在数据库系统运行过程中必须不断地对其进行评价、调整与修改，以保持数据库的完整性，并能有效地处理数据库故障和进行数据库恢复。在运行和维护阶段，可能要对数据库结构进行修改或扩充。 设计一个完善的数据库应用系统，往往是上述六个阶段的不断反复。 按照上述原则，设计过程各个阶段的设计描述，可以用下图概括 需求分析需求分析是数据库设计的起点，为以后的具体设计做准备。需求分析的结果是否准确的反映了用户的实际要求，将直接影响到后面各个阶段的设计，并影响到设计结果是否合理和实用。经验证明，由于设计要求的不正确或误解，直到系统测试阶段才发现许多错误，则纠正起来要付出很大代价。因此，必须高度重视系统的需求分析。 一、需求分析的任务 从数据库设计的角度来看，需求分析的任务是：对现实世界要处理的对象（组织、部门、企业）等进行详细的调查，通过对原系统（手工系统或计算机系统）的了解，明确用户的各种需求，收集支持新系统的基础数据并对其进行处理，在此基础上确定新系统的功能。 新系统必须充分考虑今后可能的扩充和改变，不能仅仅按当前应用需求来设计数据库。 二、需求分析的重点需求分析的重点是调查、收集与分析用户在数据管理中的： 信息要求 —— 指用户需要从数据库中获得信息的内容与性质。由用户的信息要求可以导出数据要求，即在数据库中需要存储哪些数据。 处理要求 —— 指用户要完成什么处理功能，对处理的响应时间的要求，对处理方式的要求(批处理 / 联机处理)。 安全性与完整性要求 三、需求分析的难点 确定用户最终需求的难点 用户缺少计算机知识，开始时无法确定计算机究竟能为自己做什么，不能做什么，因此无法一下子准确地表达自己的需求，他们所提出的需求往往不断地变化。 设计人员缺少用户的专业知识，不易理解用户的真正需求，甚至误解用户的需求。 新的硬件、软件技术的出现也会使用户需求发生变化。 解决方法设计人员必须采用有效的方法，与用户不断深入地进行交流，才能逐步得以确定用户的实际需求。 四、需求分析的方法 首先是调查清楚用户的实际需求并进行初步分析，与用户达成共识，然后 进一步分析与表达这些需求。 调查组织机构情况，包括了解组织部门的组成情况和各部门的职责等。 调查各部门的业务活动情况，调查重点之一。包括了解各个部门输入和使用什么数据；如何加工处理这些数据；输出什么信息；输出到什么部门；输出结果的格式是什么，等等。 做需求调查时，往往需要同时采用多种方法。无论使用何种调查方法，都必须有用户的积极参与和配合。 设计人员应该和用户取得共同的语言，帮助不熟悉计算机的用户建立数据库环境下的共同概念，并对设计工作的最后结果共同承担责任。 常用调查方法包括： 跟班作业。通过亲身参加业务工作了解业务活动的情况，能比较准确地理解用户的需求，但比较耗时。 开调查会。通过与用户座谈来了解业务活动情况及用户需求。 请专人介绍。 询问。对某些调查中的问题，可以找专人询问。 设计调查表请用户填写。如果调查表设计合理，则很有效，且易于为用户接受。 查阅记录。查阅与原系统有关的数据记录。 五、进一步分析和表达用户需求分析和表达用户的需求的常用方法是：自顶向下的结构化分析方法（Structured Analysis，简称SA方法） SA方法从最上层的系统组织机构入手，采用逐层分解的方式分析系统，并用数据流图和数据字典描述系统。 要反映更详细的内容，需要分解处理功能和数据。 分解处理功能 将处理功能的具体内容分解为若干子功能，再将每个子功能继续分解，直到把系统的工作过程表达清楚为止。 分解后的处理过程，用判定表或判定树来描述。 分解数据 在处理功能逐步分解的同时，其所用的数据也逐级分解，形成若干层次的数据流图。数据流图表达了数据和处理过程的关系。 分解后的数据，用数据字典来描述 最后，将分析结果再次提交给用户，征得用户的认可。整个过程如下图所示： 例如，我们要开发一个学校管理系统。 经过可行性分析和初步需求调查，抽象出该系统最高层数据流图，该系统由教师管理子系统、学生管理子系统、后勤管理子系统组成，每个子系统分别配备一个开发小组。 进一步细化各个子系统。其中学生管理子系统开发小组通过进行进一步的需求调查，明确了该子系统的主要功能是进行学籍管理和课程管理，包括学生报到、入学、毕业的管理，学生上课情况的管理。通过详细的信息流程分析和数据收集后，他们生成了该子系统的数据流图。 数据字典数据字典的用途数据字典是各类数据描述的集合，是进行详细的数据收集和数据分析所获得的主要结果。数据字典在数据库设计中占有很重要的地位。 数据字典通常包括： 数据项 数据结构 数据流 数据存储 处理过程 其中，数据项是数据的最小组成单位，若干个数据项可以组成一个数据结构。数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容。下面，我们用学生学籍管理子系统的数据字典 进行说明 数据项数据项是不可再分的数据单位。 数据项描述＝｛ 数据项名，数据项含义说明，别名, 数据类型，长度，取值范围，取值含义, 与其他数据项的逻辑关系｝ 其中，取值范围、与其他数据项的逻辑关系定义了数据的完整性约束条件. 以“学号”为例： 数据项： 学号 含义说明：唯一标识每个学生 别名： 学生编号 类型： 字符型 长度： 8 取值范围：00000000至99999999 取值含义：前2位标明该学生所在年级，后面4位标明院系和班级，后2位按顺序编号 与其他数据项的逻辑关系：…… 数据结构数据结构反映了数据之间的组合关系。 一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。 数据结构描述＝｛ 数据结构名，含义说明， 组成:｛数据项或数据结构｝｝ 以“学生”为例： 数据结构： 学生 含义说明： 是学籍管理子系统的主体数据结构，定义了一个学生的有关信息 组成： 学号，姓名，性别，年龄，所在系，年级 数据流数据流是数据结构在系统内传输的路径。 数据流描述＝｛ 数据流名，说明，数据流来源， 数据流去向，组成:｛数据结构｝， 平均流量，高峰期流量 ｝ 其中，数据流来源是说明该数据流来自哪个过程；数据流去向是说明该数据流将到哪个过程去；平均流量是指在单位时间（每天、每周、每月等）里的传输次数；高峰期流量则是指在高峰时期的数据流量。 以“体检结果”为例： 数据流： 体检结果 说明： 学生参加体格检查的最终结果 数据流来源：体检 数据流去向：审批 组成： …… 平均流量： …… 高峰期流量：…… 数据存储数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一。 数据存储描述＝{ 数据存储名，说明，编号， 流入的数据流，流出的数据流， 组成:｛数据结构｝，数据量，存取方式｝ 其中，流入的数据流指出数据来源；流出的数据流指出数据去向；数据量是指每次存取多少数据，每天（或每小时、每周等）存取几次等信息；存取方法包括：批处理 / 联机处理、检索 / 更新、顺序检索 / 随机检索等。 以“学生登记表 ”为例： 数据存储： 学生登记表 说明： 记录学生的基本情况 流入数据流：入学登记 流出数据流：查询信息 组成： …… 数据量： 每年3000张 存取方式： 随机存取 处理过程处理过程的具体处理逻辑一般用判定表或判定树来描述。数据字典中只需要描述处理过程的说明性信息。 处理过程描述＝｛ 处理过程名，说明，输入:｛数据流｝， 输出:｛数据流｝，处理:｛简要说明｝｝ 简要说明主要说明该处理过程的功能及处理要求：功能是指该处理过程用来做什么；处理要求是指处理频度要求（如单位时间里处理多少事务，多少数据量）、响应时间要求等。处理要求是后面物理设计的输入及性能评价的标准。 以“分配宿舍 ”为例： 处理过程：分配宿舍 说明： 为所有新生分配学生宿舍 输入： 学生，宿舍 输出： 宿舍安排 处理： 在新生报到后，为所有新生分配学生宿舍。要求同一间宿舍只能安排同一性别的学生，同一个学生只能安排在一个宿舍中。每个学生的居住面积不小于3平方米。安排新生宿舍其处理时间应不超过15分钟。…… 可见，数据字典是关于数据库中数据的描述，即元数据，而不是数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改，充实，完善的。 概念结构设计概念结构 需求分析阶段描述的用户应用需求是现实世界的具体需求，将需求分析得到的用户需求抽象为信息结构即概念模型的过程就是概念结构设计。 概念结构是各种数据模型的共同基础，它比数据模型更独立于机器、更抽象，从而更加稳定。 概念结构设计是整个数据库设计的关键。 概念结构设计的特点： 能真实、充分地反映现实世界，包括事物和事物之间的联系，能满足用户对数据的处理要求。是对现实世界的一个真实模型。 易于理解，从而可以用它和不熟悉计算机的用户交换意见，用户的积极参与是数据库的设计成功的关键。 易于更改，当应用环境和应用要求改变时，容易对概念模型修改和扩充。 易于向关系、网状、层次等各种数据模型转换。 描述概念模型的工具E-R模型 概念结构设计的方法与步骤设计概念结构的四类方法 自顶向下首先定义全局概念结构的框架，然后逐步细化。 自底向上首先定义各局部应用的 概念结构，然后将它们集成起来，得到全局概念结构 。 逐步扩张首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构。 混合策略将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构 。 常用策略: 自顶向下地进行需求分析 自底向上地设计概念结构 这里只介绍自底向上设计概念结构的方法。它通常分为两步：第1步是抽象数据并设计局部视图，第2步是集成局部视图，得到全局的概念结构，如下图所示。 其中DD是数据字典，DFD是数据流 数据抽象概念结构是对现实世界的一种抽象。从实际的人、物、事和概念中抽取所关心的共同特性，忽略非本质的细节。把这些特性用各种概念精确地加以描述，这些概念组成了某种模型。 三种常用抽象包括 分类（Classification） 定义某一类概念作为现实世界中一组对象的类型，这些对象具有某些共同的特性和行为，它抽象了对象值和型之间的“is member of”的语义。 在E-R模型中，实体型就是这种抽象。 例如： 哪些人构成“学生”，哪些人构成“教师” 。 聚集（Aggregation） 定义某一类型的组成成分，它抽象了对象内部类型和成分之间“is part of”的语义。 在E-R模型中若干属性的聚集组成了实体型，就是这种抽象。 例如：“学生”由学号、姓名、性别、班级等属性构成。 概括（Generalization） 定义类型之间的一种子集联系，它抽象了类型之间的“is subset of”的语义。 概括有一个很重要的性质：继承性。子类继承超类上定义的所有抽象。 例如：本科生和研究生是学生的子类，学生是它们的父类。 原本的E-R图不具有概括，然后对E-R模型作了扩充，允许定义超类实体和子类实体。并用双竖边的矩形框表示子类，用直线加小圈圈表示超类—子类的联系，如下图所示 概括有一个很重要的性质：继承性。子类继续超类上定义的所有抽象。这样，本科生和研究生集成了学生类型的属性，子类也可以增加自己的某些特殊属性。 局部E-R模型设计数据抽象是概念设计的第一步，其用途是：对需求分析阶段收集到的数据进行分类、组织（聚集），形成实体、实体的属性，标识实体的码，并确定实体之间的联系类型（1:1，1:n，m:n），设计局部E-R模型。 E-R方法： “实体-联系方法”（Entity-Relationship Approach）的简称。它是描述现实世界概念结构模型的有效方法。 用E-R方法建立的概念结构模型称为E-R模型，或称为E-R图。 实体型：用矩形框表示，框内标注实体名称。 属性：用椭圆形框表示，框内标注属性名称。 联系：指实体之间的联系，有一对一（1：1），一对多（1：n）或多对多（m ：n）三种联系类型。例如系主任领导系，学生属于某一系，学生选修课程，工人生产产品，这里“领导”、“属于”、“选修”、“生产”表示实体间的联系，可以作为联系名称。联系用菱形框表示，框内标注联系名称。 现实世界的复杂性导致实体联系的复杂性。表现在E-R图上可以归结为下图所示的几种基本形式： 两个实体之间的联系 两个以上实体间的联系 同一实体集内部各实体之间的联系 需要注意的是，因为联系本身也是一种实体型，所以联系也可以有属性。如果一个联系具有属性，则这些联系也要用无向边与该联系连接起来。例如，如下图所示，学生选修的课程有相应的成绩。这里的“成绩”既不是学生的属性，也不是课程的属性，只能是学生选修课程的联系的属性。 设计分E-R图具体做法 ① 选择局部应用在多层的数据流图中选择一个适当层次的数据流图，作为设计分E-R图的出发点。让这组图中每一部分对应一个局部应用。 由于高层的数据流图只能反映系统的概貌，而中层的数据流图能较好地反映系统中各局部应用的子系统组成，因此人们往往以中层数据流图作为设计分E-R图的依据（如图所示）。 ②逐一设计分E-R图 选择好局部应用之后，就要对每个局部应用逐一设计分E-R图，亦称局部E-R图。 ③ 实体与属性之间并没有形式上可以截然划分的界限，但可以给出两条准则：（1）作为“属性”，不能再具有需要描述的性质。“属性”必须是不可分的数据项，不能包含其他属性。（2）“属性”不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系。凡满足上述两条准则的事物，一般均可作为属性对待。 ④例子例如1：职工是一个实体，职工号、姓名、年龄是职工的属性，职称如果没有与工资、福利挂钩，换句话说，没有需要进一步描述的特性，则根据准则（1）可以作为职工实体的属性。但如果不同的职称有不同的工资、住房标准和不同的附加福利，则职称作为一个实体看待就更恰当，如下图所示。 例如2在医院中，一个病人只能住在一个病房，病房号可以作为病人实体的一个属性。但如果病房还要与医生实体发生联系，即一个医生负责几个病房的病人的医疗工作，则病房根据准则（2）应作为一个实体，如图所示。 例如3如果一种货物只存放在一个仓库，那么就可以把存放货物的仓库号作为描述货物存放地点的属性。但如果一种货物可以存放在多个仓库中，或者仓库本身又用面积作为属性，或者与职工发生管理上的联系，那么就应把仓库作为一个实体，如下图所示。 实例 销售管理子系统分E-R图的设计。 子系统的主要功能是：处理顾客和销售员送来的订单（接订单） 根据订货安排生产的（处理订单） 交出货物同时开出发票（开发票） 收到顾客付款后,根据发票存根和信贷情况进行应收款处理 得到了该子系统二层数据流图（共5张）和数据字典，其中包括14个数据结构和29个数据流。 图7.18是第一层数据流图。虚线部分划出了系统边界。图中把系统功能又分为四个子系统。图7.19至图7.22是第二层数据流图。 设计该分E-R图的草图（如图7.23所示）。 然后参照第二层数据流图和数据字典中的详尽描述，遵循前面给出的两个准则，进行了如下调整： （1）每张订单由订单号、若干头信息和订单细节组成。订单细节又有订货的零件号、数量等来描述。按照准则（2），订单细节就不能作订单的属性处理而应该上升为实体。一张订单可以订若干产品，所以订单与订单细节两个实体之间是1：n的联系。 （2）原订单和产品的联系实际上是订单细节和产品的联系。每条订货细节对应一个产品描述，订单处理时从中获得当前单价、产品重要等信息。 （3）图7.21中“发票清单”是一个数据存储，是否应作为实体加入分E-R图呢？答案是不必。这里的数据存储对应手工凭证，发票上的信息在开具发票的同时已及时存入应收账款中了。 （4）工厂对大宗订货给予优惠。每种产品都规定了不同订货数量的折扣，应增加一个“折扣规则”实体存放这些信息，而不应把它们放在产品描述实体中。 最后得到分E-R图如图7.24所示。 对每个实体定义的属性如下： 顾客：{&lt;u&gt;顾客号&lt;/u&gt;，顾客名，地址，电话，信贷状况，账目余额 订单：{&lt;u&gt;订单号&lt;/u&gt;，顾客号，订货项数，订货日期，交货日期，工种号，生产地点} 订单细则：{&lt;u&gt;订单号，细则号&lt;/u&gt;，零件号，订货数，金额} 应收账款：{&lt;u&gt;顾客号，订单号&lt;/u&gt;，发票号，应收金额，支付日期，支付金额，当前余额，货款限额} 产品描述：{&lt;u&gt;产品号&lt;/u&gt;，产品名，单价，重量} 折扣规则：{&lt;u&gt;产品号&lt;/u&gt;，订货量，折扣} 视图的集成各子系统的分E-R图设计好以后，下一步就是要将所有的分E-R图综合成一个系统的总E-R图。 有两种方式： 多个分E-R图一次集成，如图所示。 逐步集成，用累加的方式一次集成两个分E-R图，如图所示。 第一种方式比较复杂，做起来难度较大。 第二种方式每次只集成两个分E-R图，可以降低复杂度。 每次集成局部E-R图时都需要分两步走。 （1）合并。解决各分E-R图之间的冲突，将各分E-R图合并起来生成初步E-R图。 （2）修改和重构。消除不必要的冗余，生成基本E-R图。 一、合并分E-R图，生成初步E-R图 合理消除各分E-R图的冲突是合并分E-R图的主要工作与关键所在。 各分E-R图之间的冲突主要有三类：属性冲突、命名冲突和结构冲突。 属性冲突 属性值域冲突 即属性值的类型、取值范围或取值集合不同。比如学号，有些部门将其定义为数值型，而有些部门将其定义为字符型。又如年龄，有的可能用出生年月表示，有的则用整数表示。 属性取值单位冲突。比如零件的重量，有的以公斤为单位，有的以斤为单位，有的则以克为单位。 属性冲突属于用户业务上的约定，必须与用户协商后解决。 命名冲突命名不一致可能发生在实体名、属性名或联系名之间，其中属性的命名冲突更为常见。一般表现为同名异义或异名同义（实体、属性、联系名）。 同名异义即同一名字的对象在不同的部门中具有不同的意义。比如，“单位”在某些部门表示为人员所在的部门，而在某些部门可能表示物品的重量、长度等属性。 异名同义（一义多名），即同一意义的对象在不同的部门中具有不同的名称。比如，有的部门把教科书称为“课本“，有的部门则把教科书称为”教材“。 命名冲突可能发生在属性级、实体级、联系级上。其中属性的命名冲突更为常见。 命名冲突的解决方法同属性冲突，需要与各部门协商、讨论后加以解决。 结构冲突 同一对象在不同应用中有不同的抽象，可能为实体，也可能为属性。例如，“系别”在某一局部应用中被当作实体，而在另一局部应用中则被当作属性。这类冲突在解决时，就是使同一对象在不同应用中具有相同的抽象，或把实体转换为属性，或把属性转换为实体。 同一实体在不同应用中属性组成不同，或者是属性次序不同。 原因：不同的局部应用关心的是该实体的不同侧面。解决办法是：合并后实体的属性组成为各局部E-R图中的同名实体属性的并集，然后再适当调整属性的次序。 同一联系在不同应用中呈现不同的类型。例如，E1与E2在某一应用中可能是一对一联系，而在另一应用中可能是一对多或多对多联系，也可能是在E1、E2、E3三者之间有联系。这种情况应该根据应用的语义对实体联系的类型进行综合或调整。 下面以教务管理系统中的两个局部E-R图为例，来说明如何消除各局部E-R图之间的冲突，进行局部E-R模型的合并，从而生成初步E-R图。首先，这两个局部E-R图中存在着命名冲突，学生选课局部E-R图中的实体“系”与教师任课局部E-R图中的实体“单位”，都是指“系”，即所谓的异名同义，合并后统一改为“系”，这样属性“名称”和“单位”即可统一为“系名”。其次，还存在着结构冲突，实体“系”和实体“课程” 在两个不同应用中的属性组成不同，合并后这两个实体的属性组成为原来局部E-R图中的同名实体属性的并集。解决上述冲突后，合并两个局部E-R图，生成如图所示的初步的全局E-R图。 修改与重构，消除不必要的冗余，生成基本E-R图 所谓冗余，在这里指冗余的数据和实体之间冗余的联系。 冗余的数据是指可由基本的数据导出的数据； 冗余的联系是由其他的联系导出的联系。 在上面消除冲突合并后得到的初步E-R图中，可能存在冗余的数据或冗余的联系。冗余的存在容易破坏数据库的完整性，给数据库的维护增加困难，应该消除。我们把消除了冗余的初步E-R图称为基本E-R图。 通常采用分析的方法消除冗余。数据字典是分析冗余数据的依据，还可以通过数据流图分析出冗余的联系。 例如，在上图所示的初步E-R图中 “课程”实体中的属性“教师号”可由“讲授”这个教师与课程之间的联系导出，而学生的平均成绩可由“选修”联系中的属性“成绩”中计算出来，所以“课程”实体中的 “教师号” 与“学生”实体中的“平均成绩”均属于冗余数据。 最终得到的基本E-R模型是企业的概念模型，它代表了用户的数据要求，是沟通“要求”和“设计”的桥梁。它决定数据库的总体逻辑结构，是成功建立数据库的关键。如果设计不好，就不能充分发挥数据库的功能，无法满足用户的处理要求。 因此，用户和数据库人员必须对这一模型反复讨论，在用户确认这一模型已正确无误的反映了他们的要求后，才能进入下一阶段的设计工作。 逻辑结构设计数据库逻辑设计的任务是将概念结构转换成特定DBMS所支持的数据模型的过程。从此开始便进入了“实现设计”阶段，需要考虑到具体的DBMS的性能、具体的数据模型特点。从E-R图所表示的概念模型可以转换成任何一种具体的DBMS所支持的数据模型，如网状模型、层次模型和关系模型。这里只讨论关系数据库的逻辑设计问题，所以只介绍E-R图如何向关系模型进行转换。 逻辑结构设计的步骤包括： 将概念结构转化为一般的关系、网状、层次模型； 将转化来的关系、网状、层次模型向特定DBMS支持下的数据模型转换 对数据模型进行优化 转换内容 E-R图由实体、实体的属性和实体之间的联系三个要素组成，关系模型的逻辑结构是一组关系模式的集合。 将E-R图转换为关系模型，也就是将实体、实体的属性和实体之间的联系转化为关系模式。 一、转换原则 一个实体型转换为一个关系模式 实体型的属性就是关系的属性 实体型的码就是关系的码例如，学生实体可以转换为如下关系模式：学生（学号，姓名，性别、出生日期，所在系，年级，平均成绩）宿舍、班级、档案材料、教师、课程、教室、教科书都可以分别转换为一个关系模式。 一个m:n联系转换为一个关系模式 关系的属性：与该联系相连的各实体的码以及联系本身的属性 关系的码：各实体码的组合例如，“选修”联系是一个m:n联系，可以将它转换为如下关系模式，其中学号与课程号为关系的组合码：选修（学号，课程号，成绩） 一个1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并 转换为一个独立的关系模式关系的属性：与该联系相连的各实体的码以及联系本身的属性关系的码：n端实体的码例如，“系“和“教师”是1:n的联系，建立一个关系，记录教师和所在的系，以教师作为码。 与n端对应的关系模式合并合并后关系的属性：在n端关系中加入1端关系的码和联系本身的属性合并后关系的码：不变。例如，“系“和“教师”是1:n的联系，在“教师“关系中加入”系“作为属性。这种可以减少系统中的关系个数，一般情况下更倾向于采用这种方法。 一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并 转换为一个独立的关系模式关系的属性：与该联系相连的各实体的码以及联系本身的属性关系的候选码：每个实体的码均是该关系的候选码例如，“班长”和“班级”是1:1的联系，可以建立一个关系，记录班长和所在班级，这两个属性都可以作为该关系的候选码。 与某一端对应的关系模式合并合并后关系的属性：加入对应关系的码和联系本身的属性合并后关系的码：不变例如，“班长”和“班级”是1:1的联系，可以在“班长“关系中增加班级属性，也可以在”班级“关系中加入班长属性。 从理论上讲，1:1联系可以与任意一端对应的关系模式合并。但在一些情况下，与不同的关系模式合并效率会大不一样。因此究竟应该与哪端的关系模式合并需要依应用的具体情况而定。由于连接操作是最费时的操作，所以一般应以尽量减少连接操作为目标。例如，如果经常要查询某个班级的班长信息，那么将“班级“属性合并到“班长“关系中会更好些。 三个或三个以上实体间的一个多元联系转换为一个关系模式 关系的属性：与该多元联系相连的各实体的码以及联系本身的属性 关系的码：各实体码的组合例如，“授课”联系是一个三元联系，可以将它转换为如下关系模式，其中课程号、教师号和教材号为关系的组合码： 授课（课程号，教师号，教材号） 同一实体集的实体间的联系，即自联系，也可按上述1:1、1:n和m:n三种情况分别处理例如，如果教师实体集内部存在领导与被领导的1:n自联系，我们可以将该联系与教师实体合并，这时主码教师号将多次出现，但作用不同，可用不同的属性名加以区分： 教师：｛教师号，姓名，性别，职称，系主任｝ 同一具有相同码的关系模式可合并 目的：减少系统中的关系个数。 合并方法：将其中一个关系模式的全部属性加入到另一个关系模式中，然后去掉其中的同义属性（可能同名也可能不同名），并适当调整属性的次序。例如，某关系模式记录了学生的身份证号： 身份证（学号，身份证号） 可以与学生关系模式合并为： 学生（学号，姓名，出生日期，身份证号，……） 向特定DBMS规定的模型进行转换 一般的数据模型还需要向特定DBMS规定的模型进行转换。 转换的主要依据是所选用的DBMS的功能及限制。 没有通用规则。 对于关系模型来说，这种转换通常都比较简单。 二、数据模型的优化 数据库逻辑设计的结果不是唯一的。 得到初步数据模型后，还应该适当地修改、调整数据模型的结构，以进一步提高数据库应用系统的性能，这就是数据模型的优化。 关系数据模型的优化通常以规范化理论为指导。 三、关系模式规范化 应用规范化理论对上述产生的关系的逻辑模式进行初步优化，以减少乃至消除关系模式中存在的各种异常，改善完整性、一致性和存储效率。 规范化理论是数据库逻辑设计的指南和工具，规范化过程可分为两个步骤： 确定规范式级别考查关系模式的函数依赖关系，确定范式等级，逐一分析各关系模式，考查是否存在部分函数依赖，传递函数依赖等，确定它们分别属于第几范式。 实施规范化处理确定范式级别后，利用第4章的规范化理论，逐一考察各个关系模式，根据应用要求，判断它们是否满足规范要求，可用已经介绍过的规范化方法和理论将关系模式规范化。 综合以上数据库的设计过程，规范化理论在数据库设计中有如下几方面的应用： 在需求分析阶段，用数据依赖概念分析和表示各个数据项之间的联系。 在概念结构设计阶段，以规范化理论为指导，确定关系键，消除初步E-R图中冗余的联系。 在逻辑结构设计阶段，从E-R图向数据模型转换过程中，用模式合并与分解方法达到规范化级别。 四、模式评价与改进关系模式的规范化不是目的而是手段，数据库设计的目的是最终满足应用需求。因此，为了进一步提高数据库应用系统的性能，还应该对规范化后产生的关系模式进行评价、改进，经过反复多次的尝试和比较，最后得到优化的关系模式。 模式评价： 目的是检查所设计的数据库模式是否满足用户的功能要求、效率，确定加以改进的部分。 模式评价包括： 功能评价 性能评价 功能评价 功能评价指对照需求分析的结果，检查规范化后的关系模式集合是否支持用户所有的应用要求。 关系模式必须包括用户可能访问的所有属性。在涉及多个关系模式的应用中，应确保联接后不丢失信息。如果发现有的应用不被支持，或不完全被支持，则应该改进关系模式。 发生这种问题的原因可能是在逻辑设计阶段，也可能是在需求分析或概念设计阶段。是哪个阶段的问题就返回到哪个阶段去，因此有可能对前两个阶段再进行评审，解决存在的问题。 性能评价 对于目前得到的数据库模式，由于缺乏物理设计所提供的数量测量标准和相应的评价手段，所以性能评价是比较困难的，只能对实际性能进行估计，包括逻辑记录的存取数、传送量以及物理设计算法的模型等。 模式改进 根据模式评价的结果，对已生成的模式进行改进。 如果因为需求分析、概念设计的疏漏导致某些应用不能得到支持，则应该增加新的关系模式或属性。 如果因为性能考虑而要求改进，则可采用合并或分解的方法。 合并 如果有若干个关系模式具有相同的主键，并且对这些关系模式的处理主要是查询操作，而且经常是多关系的查询，那么可对这些关系模式按照组合使用频率进行合并。 这样便可以减少联接操作而提高查询效率。 分解 为了提高数据操作的效率和存储空间的利用率，最常用和最重要的模式优化方法就是分解。 根据应用的不同要求，可以对关系模式进行垂直分解和水平分解。①水平分解 是把关系的元组分为若干子集合，定义每个子集合为一个子关系 对于经常进行大量数据的分类条件查询的关系，可进行水平分解，这样可以减少应用系统每次查询需要访问的记录数，从而提高了查询性能。 例如，有学生关系（学号，姓名，类别……），其中类别包括大专生、本科生和研究生。如果多数查询一次只涉及其中的一类学生，就应该把整个学生关系水平分割为大专生、本科生和研究生三个关系。 ②垂直分解 把关系模式的属性分解为若干子集合，形成若干子关系模式。垂直分解的原则是把经常一起使用的属性分解出来，形成一个子关系模式 。 垂直分解可以提高某些事务的效率，但也有可能使另一些事务不得不执行连接操作，从而降低了效率。因此是否要进行垂直分解要看分解后的所有事务的总效率是否得到了提高。垂直分解要保证分解后的关系具有无损连接性和函数依赖保持性。 例如，有教师关系（教师号，姓名，性别，年龄，职称，工资，岗位津贴，住址，电话），如果经常查询的仅是前六项，而后三项很少使用，则可以将教师关系进行垂直分割，得到两个教师关系：教师关系1（教师号，姓名，性别，年龄，职称，工资）教师关系2（教师号，岗位津贴，住址，电话）这样，便减少了查询的数据传递量，提高了查询速度。 经过多次的模式评价和模式改进之后，最终的数据库模式得以确定。逻辑设计阶段的结果是全局逻辑数据库结构。对于关系数据库系统来说，就是一组符合一定规范的关系模式组成的关系数据库模型。数据库系统的数据物理独立性特点消除了由于物理存储改变而引起的对应程序的修改。标准的DBMS例行程序应适用于所有的访问，查询和更新事务的优化应当在系统软件一级上实现。这样，逻辑数据库确定之后，就可以开始进行应用程序设计了。 数据库的物理设计数据库最终要存储在物理设备上。对于给定的逻辑数据模型，选取一个最适合应用环境的物理结构的过程，称为数据库物理设计。物理设计的任务是为了有效地实现逻辑模式，确定所采取的存储策略。此阶段是以逻辑设计的结果作为输入，结合具体DBMS的特点与存储设备特性进行设计，选定数据库在物理设备上的存储结构和存取方法。数据库的物理设计可分为两步：确定物理结构，在关系数据库中主要指存取方法和存储结构；评价物理结构，评价的重点是时间和空间效率。 存储记录结构的设计 在物理结构中，数据的基本存取单位是存储记录。 有了逻辑记录结构以后，就可以设计存储记录结构，一个存储记录可以和一个或多个逻辑记录相对应。存储记录结构包括记录的组成、数据项的类型和长度，以及逻辑记录到存储记录的映射。 某一类型的所有存储记录的集合称为“文件”，文件的存储记录可以是定长的，也可以是变长的。 索引的设计 存储记录是属性值的集合，主关系键可以惟一确定一个记录，而其他属性的一个具体值不能惟一确定是哪个记录。在主关系键上应该建立惟一索引，这样不但可以提高查询速度，还能避免关系键重复值的录入，确保了数据的完整性。在数据库中，用户访问的最小单位是属性。如果对某些非主属性的检索很频繁，可以考虑建立这些属性的索引文件。索引文件对存储记录重新进行内部链接，从逻辑上改变了记录的存储位置，从而改变了访问数据的入口点。关系中数据越多索引的优越性也就越明显。 建立多个索引文件可以缩短存取时间，但是增加了索引文件所占用的存储空间以及维护的开销。因此，应该根据实际需要综合考虑。 数据存放位置的设计 为了提高系统性能，应该根据应用情况将数据的易变部分、稳定部分、经常存取部分和存取频率较低部分分开存放。 例如，目前许多计算机都有多个磁盘，因此可以将表和索引分别存放在不同的磁盘上，在查询时，由于两个磁盘驱动器并行工作，可以提高物理读写的速度。 在多用户环境下，可能将日志文件和数据库对象（表、索引等）放在不同的磁盘上，以加快存取速度。另外，数据库的数据备份、日志文件备份等，只在数据库发生故障进行恢复时才使用，而且数据量很大，可以存放在磁带上，以改进整个系统的性能。 系统配置的设计 DBMS产品一般都提供了一些系统配置变量、存储分配参数，供设计人员和DBA对数据库进行物理优化。系统为这些变量设定了初始值，但是这些值不一定适合每一种应用环境，在物理设计阶段，要根据实际情况重新对这些变量赋值，以满足新的要求。 系统配置变量和参数很多，例如，同时使用数据库的用户数、同时打开的数据库对象数、内存分配参数、缓冲区分配参数（使用的缓冲区长度、个数）、存储分配参数、数据库的大小、时间片的大小、锁的数目等，这些参数值影响存取时间和存储空间的分配，在物理设计时要根据应用环境确定这些参数值，以使系统的性能达到最优。 评价物理结构 和前面几个设计阶段一样，在确定了数据库的物理结构之后，要进行评价，重点是时间和空间的效率。 如果评价结果满足设计要求，则可进行数据库实施。 实际上，往往需要经过反复测试才能优化物理设计。 数据库实施和维护数据库实施是指根据逻辑设计和物理设计的结果，在计算机上建立起实际的数据库结构、装入数据、进行测试和试运行的过程。数据库实施主要包括以下工作： 建立实际数据库结构； 装入数据； 应用程序编码与调试； 数据库试运行； 整理文档。 数据库运行和维护 数据库试运行结果符合设计目标后，数据库就投入正式运行，进入运行和维护阶段。数据库系统投入正式运行，标志着数据库应用开发工作的基本结束，但并不意味着设计过程己经结束。 由于应用环境不断发生变化，用户的需求和处理方法不断发展，数据库在运行过程中的存储结构也会不断变化，从而必须修改和扩充相应的应用程序。 数据库运行和维护阶段的主要任务包括以下三项内容： 维护数据库的安全性与完整性； 监测并改善数据库性能； 重新组织和构造数据库。 维护数据库的安全性与完整性 按照设计阶段提供的安全规范和故障恢复规范，DBA要经常检查系统的安全是否受到侵犯，根据用户的实际需要授予用户不同的操作权限。 数据库在运行过程中，由于应用环境发生变化，对安全性的要求可能发生变化，DBA要根据实际情况及时调整相应的授权和密码，以保证数据库的安全性。 同样数据库的完整性约束条件也可能会随应用环境的改变而改变，这时DBA也要对其进行调整，以满足用户的要求。 另外，为了确保系统在发生故障时，能够及时地进行恢复，DBA要针对不同的应用要求定制不同的转储计划，定期对数据库和日志文件进行备份，以使数据库在发生故障后恢复到某种一致性状态，保证数据库的完整性。 监测并改善数据库性能 目前许多DBMS产品都提供了监测系统性能参数的工具，DBA可以利用系统提供的这些工具，经常对数据库的存储空间状况及响应时间进行分析评价； 结合用户的反应情况确定改进措施； 及时改正运行中发现的错误； 按用户的要求对数据库的现有功能进行适当的扩充。但要注意在增加新功能时应保证原有功能和性能不受损害。 重新组织和构造数据库 数据库建立后，除了数据本身是动态变化以外，随着应用环境的变化，数据库本身也必须变化以适应应用要求。 数据库运行一段时间后，由于记录的不断增加、删除和修改，会改变数据库的物理存储结构，使数据库的物理特性受到破坏，从而降低数据库存储空间的利用率和数据的存取效率，使数据库的性能下降。因此，需要对数据库进行重新组织，即重新安排数据的存储位置，回收垃圾，减少指针链，改进数据库的响应时间和空间利用率，提高系统性能。这与操作系统对“磁盘碎片”的处理的概念相类似。 DBMS一般都提供了重新组织和构造数据库的应用程序，以帮助DBA完成数据库的重组和重构工作。 只要数据库系统在运行，就需要不断地进行修改、调整和维护。一旦应用变化太大，数据库重新组织也无济于事，这就表明数据库应用系统的生命周期结束，应该建立新系统，重新设计数据库。从头开始数据库设计工作，标志着一个新的数据库应用系统生命周期的开始。 小结 本章介绍了数据库设计的六个阶段，包括：系统需求分析、概念结构设计、逻辑结构设计、物理设计、数据库实施、数据库运行与维护。对于每一阶段，都分别详细讨论了其相应的任务、方法和步骤。 需求分析是整个设计过程的基础，需求分析做得不好，可能会导致整个数据库设计返工重做。 将需求分析所得到的用户需求抽象为信息结构即概念模型的过程就是概念结构设计，概念结构设计是整个数据库设计的关键所在，这一过程包括设计局部E-R图、综合成初步E-R图、E-R图的优化。 将独立于DBMS的概念模型转化为相应的数据模型，这是逻辑结构设计所要完成的任务。一般的逻辑设计分为三步：初始关系模式设计，关系模式规范化，模式的评价与改进。 物理设计就是为给定的逻辑模型选取一个适合应用环境的物理结构，物理设计包括确定物理结构和评价物理结构两步。 根据逻辑设计和物理设计的结果，在计算机上建立起实际的数据库结构，装入数据，进行应用程序的设计，并试运行整个数据库系统，这是数据库实施阶段的任务。 数据库设计的最后阶段是数据库的运行与维护，包括维护数据库的安全性与完整性，监测并改善数据库性能，必要时需要进行数据库的重新组织和构造。 数据库编程嵌入式SQLSQL语言是应用程序和数据库之间的主要编程接口。使用SQL语言编写访问数据库的代码时，可用两种方法存储和执行这些代码。 在客户端存储代码，并创建向数据库服务器发送的SQL命令 将SQL语句存储在数据库服务器端，然后由应用程序调用执行这些SQL语句。 存储在数据库服务器端供客户端调用执行的SQL语句就是存储过程。 嵌入式SQL的处理过程主语言：嵌入式SQL是将SQL语句嵌入程序设计语言中，被嵌入的程序设计语言，如C、C++、Java称为宿主语言处理过程：预编译，如下图所示 在ESQL中，为了区分SQL语句和主语言语句，所有SQL语句都必须加前缀EXEC SQL，以（；）结束称为一个程序片断： EXEC SQL&lt;sql语句&gt;; 嵌入式SQL语句与主语言之间的通信将SQL嵌入到高级语言中混合编程，程序会有两种不同计算模型的语句 sql语句 描述性的面向集合的语句 负责操纵数据库 高级语言语句 过程性的面向记录的语句 负责控制程序流程 数据库工作单元与源程序工作单元之间的通信： SQL通信区 向主语言传递SQL语句的执行状态信息 使主语言能够根据此控制程序流程 SQLCA：SQL Communication Area SQLCA是一个数据结构 SQLCA的用途： SQL语句执行后，系统反馈给应用程序信息描述当前系统工作状态描述运行环境 将这些信息送到SQL通信区中 应用程序从SQL通信区中取出这些状态信息，从而决定接下来执行的语句。 SQLCA使用方法：定义SQLCA用EXEC SQL INCLUDE SQLCA定义使用SQLCASQLCA中有一个存放每次执行SQL语句后返回代码的变量SQLCODE如果SQLCODE等于预定义的常量SUCCESS，则表示SQL语句成功，否则表示出错应用程序每执行完一条SQL 语句之后都应该测试一下SQLCODE的值，以了解该SQL语句执行情况并做相应处理 主变量 主语言向SQL语句提供参数 将SQL语句查询数据库的结果交主语言进一步处理 主变量的类型：输入主变量输出主变量一个主变量有可能既是输入主变量又是输出主变量指示变量：一个主变量可以附带一个指示变量（Indicator Variable）什么是指示变量： 指示主变量的值或者条件 ①在SQL语句中使用主变量和指示变量的方法 说明主变量和指示变量BEGIN DECLARE SECTION……………… (说明主变量和指示变量)………END DECLARE SECTION ②使用主变量 说明之后的主变量可以在SQL语句中任何一个能够使用表达式的地方出现为了与数据库对象名（表名、视图名、列名等）区别，SQL语句中的主变量名前要加冒号（:）作为标志这些变量由宿主语言的程序定义，并用SQL的DECLARE语句说明。Sql之外，主变量可以直接使用 ③使用指示变量 指示变量前也必须加冒号标志 必须紧跟在所指主变量之后 游标SQL语言与主语言具有不同数据处理方式SQL语言是面向集合的，一条SQL语句原则上可以产生或处理多条记录主语言是面向记录的，一组主变量一次只能存放一条记录仅使用主变量并不能完全满足SQL语句向应用程序输出数据的要求嵌入式SQL引入了游标的概念，用来协调这两种不同的处理方式 游标的定义游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果每个游标区都有一个名字用户可以用SQL语句逐一从游标中获取记录，并赋给主变量，交由主语言进一步处理 使用游标的步骤 说明游标（DECLARE） 打开游标（OPEN） 推进游标指针并取当前记录( FETCH ) 关闭游标（CLOSE） ①声明游标使用DECLARE语句语句格式12EXEC SQL DECLARE &lt;游标名&gt; CURSOR FOR &lt;SELECT语句&gt;; 功能是一条说明性语句，这时DBMS并不执行SELECT指定的查询操作。 ②打开游标使用OPEN语句语句格式1EXEC SQL OPEN &lt;游标名&gt;; 功能打开游标实际上是执行相应的SELECT语句，把所有满足查询条件的记录从指定表取到缓冲区中这时游标处于活动状态，指针指向查询结果集中第一条记录 ③推进游标指针并取当前记录使用FETCH语句语句格式123EXEC SQL FETCH [[NEXT|PRIOR| FIRST|LAST] FROM] &lt;游标名&gt; INTO &lt;主变量&gt;[&lt;指示变量&gt;][,&lt;主变量&gt;[&lt;指示变量&gt;]]...; 功能指定方向推动游标指针，然后将缓冲区中的当前记录取出来送至主变量供主语言进一步处理NEXT|PRIOR|FIRST|LAST：指定推动游标指针的方式 NEXT：向前推进一条记录 PRIOR：向回退一条记录 FIRST：推向第一条记录 LAST：推向最后一条记录 缺省值为NEXT ④关闭游标使用CLOSE语句语句格式 1EXEC SQL CLOSE &lt;游标名&gt;; 功能关闭游标，释放结果集占用的缓冲区及其他资源说明游标被关闭后，就不再和原来的查询结果集相联系被关闭的游标可以再次被打开，与新的查询结果相联系 建立和关闭数据库连接建立数据库连接 12EXEC SQL CONNECT TO target [AS connection-name] [USER user-name]; target是要连接的数据库服务器： 常见的服务器标识串，如@: 包含服务器标识的SQL串常量 DEFAULT connect-name是可选的连接名，连接必须是一个有效标识符在整个程序内只有一个连接时可以不指定连接名 关闭数据库连接1EXEC SQL DISCONNECT [connection]; 程序运行过程中可以修改当前连接 ：1EXEC SQL SET CONNECTION connection-name | DEFAULT; 程序实例 [例1]依次检查某个系的学生记录，交互式更新某些学生年龄。12345678910EXEC SQL BEGIN DEC LARE SECTION; /*主变量说明开始*/ char deptname[64]; char HSno[64]; char HSname[64]; char HSsex[64]; int HSage; int NEWAGE;EXEC SQL END DECLARE SECTION; /*主变量说明结束*/long SQLCODE;EXEC SQL INCLUDE sqlca; /*定义SQL通信区*/ 12345678910111213141516171819202122232425262728293031323334353637int main(void) /*C语言主程序开始*/&#123;int count = 0; char yn; /*变量yn代表yes或no*/ printf("Please choose the department name(CS/MA/IS): "); scanf("%s", deptname); /*为主变量deptname赋值*/ EXEC SQL CONNECT TO TEST@localhost:54321 USER "SYSTEM" /"MANAGER"; /*连接数据库TEST*/ EXEC SQL DECLARE SX CURSOR FOR /*定义游标*/ SELECT Sno, Sname, Ssex, Sage /*SX对应语句的执行结果*/ FROM Student WHERE SDept = :deptname; EXEC SQL OPEN SX; /*打开游标SX便指向查询结果的第一行*/for ( ; ; ) /*用循环结构逐条处理结果集中的记录*/&#123; EXEC SQL FETCH SX INTO :HSno, :HSname, :HSsex,:HSage; /*推进游标，将当前数据放入主变量*/ if (sqlca.sqlcode != 0) /* sqlcode != 0,表示操作不成功*/ break; /*SQLCA状态信息决定退出循环*/ if(count++ == 0) /*如果是第一行的话，先打出行头*/ printf("\n%-10s %-20s %-10s %-10s\n", "Sno", "Sname", "Ssex", "Sage"); printf("%-10s %-20s %-10s %-10d\n", HSno, HSname, HSsex, HSage); /*打印查询结果*/ printf(“UPDATE AGE(y/n)?”); /*询问用户是否要更新年龄*/ do&#123; scanf("%c",&amp;yn);&#125; while(yn != 'N' &amp;&amp; yn != 'n' &amp;&amp; yn != 'Y' &amp;&amp; yn != 'y');if (yn == 'y' || yn == 'Y') /*如果选择更新操作*/ &#123; printf("INPUT NEW AGE:"); scanf(“%d”,&amp;NEWAGE); /*输入新年龄到主变量中*/ EXEC SQL UPDATE Student /*嵌入式SQL*/ SET Sage = :NEWAGE WHERE CURRENT OF SX ; &#125; /*对当前游标指向的学生年龄进行更新*/&#125; EXEC SQL CLOSE SX; /*关闭游标SX不再和查询结果对应*/ EXEC SQL COMMIT WORK; /*提交更新*/ EXEC SQL DISCONNECT TEST; /*断开数据库连接*/ &#125; 不用游标的SQL语句不用游标的SQL语句的种类 说明性语句 数据定义语句 数据控制语句 查询结果为单记录的SELECT语句 非CURRENT形式的增删改语句 一、查询结果为单记录的 SELECT语句这类语句不需要使用游标，只需要用INTO子句指定存放查询结果的主变量 [例2] 根据学生号码查询学生信息。假设已经把要查询的学生的学号赋给了主变量givensno。123EXEC SQL SELECT Sno，Sname，Ssex，Sage，Sdept INTO :Hsno， : Hname ，:Hsex，:Hage，:Hdept FROM Student WHERE Sno=:givensno； (1) INTO子句、WHERE子句和HAVING短语的条件表达式中均可以使用主变量(2)查询返回的记录中，可能某些列为空值NULL。(3) 如果查询结果实际上并不是单条记录，而是多条记录，则程序出错，RDBMS会在SQLCA中返回错误信息 [例3] 查询某个学生选修某门课程的成绩。假设已经把将要查询的学生的学号赋给了主变量givensno，将课程号赋给了主变givencno。123456EXEC SQL SELECT Sno，Cno，Grade INTO :Hsno，:Hcno，:Hgrade:Gradeid /*指示变量Gradeid*/ FROM SC WHERE Sno=:givensno AND Cno=:givencno； 如果Gradeid &lt; 0，不论Hgrade为何值，均认为该学生成绩为空值。 二、非CURRENT形式的增删改语句 在UPDATE的SET子句和WHERE子句中可以使用主变量，SET子句还可以使用指示变量[例4] 修改某个学生选修1号课程的成绩。1234EXEC SQL UPDATE SC SET Grade=:newgrade /*修改的成绩已赋给主变量*/ WHERE Sno=:givensno； /*学号赋给主变量givensno*/ [例5] 将计算机系全体学生年龄置NULL值。1234Sageid=-1；EXEC SQL UPDATE Student SET Sage=:Raise :Sageid WHERE Sdept= ‘CS’； 将指示变量Sageid赋一个负值后，无论主变量Raise为何值，RDBMS都会将CS系所有学生的年龄置空值 。等价于：123EXEC SQL UPDATE Student SET Sage=NULL WHERE Sdept= 'CS'； [例6] 某个学生退学了，现要将有关他的所有选课记录删除掉。假设该学生的姓名已赋给主变量stdname。123456EXEC SQL DELETE FROM SC WHERE Sno= (SELECT Sno FROM Student WHERE Sname=:stdname)； [例7] 某个学生新选修了某门课程，将有关记录插入SC表中。假设插入的学号已赋给主变量stdno，课程号已赋给主变量couno。 1234gradeid=-1； /*用作指示变量，赋为负值*/EXEC SQL INSERT INTO SC(Sno，Cno，Grade) VALUES(:stdno，:couno，:gr :gradeid)； 由于该学生刚选修课程，成绩应为空，所以要把指示变量赋为负值 必须使用游标的SQL语句一、 查询结果为多条记录的SELECT语句当SELECT语句查询结果是多个元组时，此时宿主语言程序无法使用，一定要用游标机制把多个元组一次一个地传送给宿主语言程序处理。二、CURRENT形式的UPDATE和DELETE语句在游标处于活动状况时，可以修改或删除游标指向的元组。 CURRENT形式的UPDATE语句和DELETE语句的用途 面向集合的操作 一次修改或删除所有满足条件的记录 如果只想修改或删除其中某个记录用带游标的SELECT语句查出所有满足条件的记录从中进一步找出要修改或删除的记录用CURRENT形式的UPDATE语句和DELETE语句修改或删除之UPDATE语句和DELETE语句中的子句：WHERE CURRENT OF &lt;游标名&gt;表示修改或删除的是最近一次取出的记录，即游标指针指向的记录 动态SQL静态嵌入式SQL 静态嵌入式SQL语句能够满足一般要求 无法满足要到执行时才能够确定要提交的SQL语句 动态嵌入式SQL 允许在程序运行过程中临时“组装”SQL语句 支持动态组装SQL语句和动态参数两种形式 一、SQL语句主变量： 程序主变量包含的内容是SQL语句的内容，而不是原来保存数据的输入或输出变量 SQL语句主变量在程序执行期间可以设定不同的SQL语句，然后立即执行 [例9] 创建基本表TEST1234567EXEC SQL BEGIN DECLARE SECTION;const char *stmt = "CREATE TABLE test(a int);"; /* SQL语句主变量 */EXEC SQL END DECLARE SECTION;... ...EXEC SQL EXECUTE IMMEDIATE :stmt; /* 执行语句 */ 二、动态参数动态参数SQL语句中的可变元素使用参数符号(?)表示该位置的数据在运行时设定和主变量的区别动态参数的输入不是编译时完成绑定而是通过 (prepare)语句准备主变量和执行(execute)时绑定数据或主变量来完成 使用动态参数的步骤： 声明SQL语句主变量。 准备SQL语句(PREPARE)。 EXEC SQL PREPARE &lt;语句名&gt; FROM &lt;SQL语句主变量&gt;; 执行准备好的语句(EXECUTE) 123EXEC SQL EXECUTE &lt;语句名&gt; [INTO &lt;主变量表&gt;] [USING &lt;主变量或常量&gt;]; [例10]向TEST中插入元组。123456789EXEC SQL BEGIN DECLARE SECTION;const char *stmt = &quot;INSERT INTO test VALUES(?);&quot;; /*声明SQL主变量 */EXEC SQL END DECLARE SECTION;... ...EXEC SQL PREPARE mystmt FROM :stmt; /* 准备语句 */... ...EXEC SQL EXECUTE mystmt USING 100; /* 执行语句 */EXEC SQL EXECUTE mystmt USING 200; /* 执行语句 */ 存储过程PL/SQL 块结构基本的SQL是高度非过程化的语言，ESQL将SQL嵌入程序设计语言，借助高级语言的控制功能实现过程化，PL/SQL是对SQL的扩展，增加了过程化的语句功能。PL/SQL 程序的基本结构是块，所有的PL/SQL程序都是由块组成的，这些块之间可以互相嵌套，每个块完成一个逻辑操作。如下图 常量变量的定义 PL/SQL中定义变量的语法形式是： 12变量名 数据类型[ [ NOT NULL] : = 初值表达式 ] 或变量名 数据类型[ [NOT NULL ] 初值表达式] 常量的定义类似于变量的定义常量名 数据类型CONSTANT : = 常量表达式常量必须要给一个值，并且该值在存在期间或者常量的作用域不能改变，如果视图修改它，PL/SQL将返回一个异常。 赋值语句变量名称 : = 表达式 控制结构PL/SQL提供了流程控制语句，主要有条件控制语句和循环控制语句，这些语句的语法、语义和一般的高级语言类似 一、条件控制语句一般有三种形式的if语句：IF-THEN, IF -THEN -ELSE 和嵌套 IF 语句 1. IF condition THEN Sequence_of_statement; /*条件为真时语句序列才会被执行*/ END IF /*条件为假货null时什么也不做，控制转移至下一个语句*/ 2. IF condition THEN Sequence_of_statements1; /*条件为真时执行语句序列1*/ ELSE Sequence_of_statements2; /*条件为假货null时执行语句序列2*/ END IF; 3. 在THEN 和ELSE子句中还可以再包括IF语句，即IF语句可以嵌套 二、循环控制语句有三种:LOOP . WHILE-LOOP 和 FOR-LOOP 最简单的循环语句LOOP 123LOOP Sequence_of_statements; /*循环体，一组PL/SQL语句*/END LOOP; WHILE_LOOP 123WHILE condition LOOP Sequence_of_statements;END LOOP; 每次执行循环语句的时候，先对条件进行求值，如果条件为真，则执行循环体内的语句序列，如果条件为假，则跳过循环并且把控制传递给下一个语句 FOR-LOOP 123FOR count IN [REVERSE]bound1 .... bound2 LOOP Sequence_of_statements;END LOOP; FOR循环的基本执行过程： 将count设置为循环下界bound1，检查它是否小于上界bound2 当指定REVERSER时则将count设置为循环的上界bound2，检查count是否大于下界bound1 如果越界则执行跳出循环，否则执行循环体，然后按照步长（+1或者-1）更新count的值，重新判断条件 三、错误处理如果PL/SQL在执行时出现异常，则应该在异常处停下来。SQL标准对数据库服务器提供什么样的异常处理作出了建议，要求PL/SQL管理器提供完善的异常处理机制，相对于ESQL简单的提供执行状态信息sqlcode，这里的异常处理就复杂多了。 存储过程PL/SQL块有两种类型，即命名块和匿名块，上面介绍的是匿名块。匿名块每次执行都是要进行编译，不能被存储到数据库中，也不能在其他的PL/SQL块中调用。存储过程和函数是命名块，他们被编译后保存在数据库中，可以被反复调用，运行速度较快。 一、存储过程的优点由PL/SQL语句书写的过程，经编译和优化后存储在数据库服务器中，使用时只要调用即可。存储过程的优点：(1) 运行效率高(2) 降低了客户机和服务器之间的通信量(3) 方便实施企业规则 允许模块化程序设计 只需创建一次并存储在数据库中，就可以在应用程序中反复调用该存储过程 改善性能—运行效率高 在创建存储过程时对代码进行分析和优化，并在第一次执行时进行语法检查和编译，将编译好的可执行代码存储在内存的一个专门缓冲区中，以后再执行此存储过程时，只需直接执行内存中的可执行代码即可。 减少网络流量-降低了客户机和服务器之间的通信量 只需要一条执行存储过程的代码即可实现，因此，不再需要在网络中传送大量的代码。 存储过程功能接受输入参数并以输出参数的形式将多个值返回给调用者。包含执行数据库操作的语句。将查询语句执行结果返回到客户端内存中。 二、存储过程的用户接口用户通过下面的SQL语句创建、重新命名、执行和删除存储过程： 创建存储过程 123CREATE Procedure 过程名（[参数1，参数2, .... ]）/* 存储过程首部*/AS&lt;PL/SQL块&gt; /*存储过程体，描述该存储过程的操作*/ 存储过程包括过程首部和过程体。过程名：是数据库服务器合法的对象标识参数列表：用名字来表示调用时给出的参数值，必须指定值的数据类型，存储参数也可以定义输入参数，输出参数或输入/输出参数，默认为输入参数过程体：是一个&lt;PL/SQL块&gt;，包括声明部分和可执行语句部分，&lt;PL/SQL块&gt;的基本结构已经在前面有介绍了。 例1．不带参数的存储过程。查询计算机系学生的考试情况，列出学生的姓名、课程名和考试成绩。1234567CREATE PROCEDURE p_StudentGrade1ASSELECT Sname, Cname, Grade FROM Student , SC,Course WHERE Student.sno=Sc.sno and Sc.cno=Course.cno and Dept = '计算机系' 执行此存储过程：EXEC p_StudentGrade1 例2．带输入参数的存储过程。查询某个指定系学生的考试情况，列出学生的姓名、所在系、课程名和考试成绩。 12345678CREATE PROCEDURE p_StudentGrade2 @dept char(20)AS SELECT Sname, Dept, Cname, Grade FROM Student , SC WHERE Student.sno=Sc.sno and Sc.cno=Course.cno and Dept = @dept 执行存储过程，查询信息管理系学生的修课情况 EXEC p_StudentGrade2 ‘信息管理系’ 例 利用存储过程来实现下面的应用，从一个账户转指定的数额的快想到另一个账户中。 1234567891011121314151617CREATE PROCEDURE TRANSFER(inAcount INT ,outAcount INT ,amount FLOAT) AS DECLARE totalDeposit FLOAT; BEGIN /*检查转出账户的余额*/ SELECT total INTO totalDeposit FROM ACCOUNT WHERE ACCOUNTNUM=outAccount; IF totalDeposit IS NULL THEN /*账户不存在或账户中没有存款*/ ROLLBACK; RETURN; END IF; IF totalDeposit &lt;amount THEN /*账户存款不足*/ ROLLBACK; RETURN; END IF; UPDATE account SET total != total - amount WHERE ACCOUNTNUM =outAccount; /*修改转出账户，减去转出额*/ UPDATE account SET total = total + amount WHERE ACCOUNTNUM =inAccount; /*修改转入账户，增加转出额*/ COMMIT; /*提交转账事务*/END; 执行存储过程 CALL/PERFORM Procedure 过程名([参数1，参数2, … ]); 使用CALL或者PERFORM 等方式集火存储过程的执行，在PL/SQL中，数据库支持在过程体中调用其他存储过程 例 从账户1234567转一万元到1234568中 CALL Procedure TRANSFER (1234567 ,1234568 ,10000); 删除存储过程DROP PROCEDURE 过程名(); 三、游标 和嵌入式SQL一样，在PL/SQL中如果select语句只返回一条记录，可以将该结果存放到变量中，当查询返回多条记录时，用游标对结果集进行处理，一个游标与一个SQL语句相关联。 ODBC编程数据库互连概述ODBC产生的原因 由于不同 的数据库管理系统的存在，在某个RDBMS下编写的应用程序就不能在另一个RDBMS下运行， 许多应用程序需要共享多个部门的数据资源，访问不同的RDBMS。 ODBC： 是微软公司开放服务体系中有关数据库的一个组成部分 建立了一组规范 提供了一组访问数据库的标准API ODBC的约束力： 规范应用开发 规范RDBMS应用接口 ODBC工作原理概述分四个部分：用户应用程序，驱动程序管理器（ODBC Driver），数据库驱动程序(ODBC Driver)，数据源(如RDBMS和数据库) 一、应用程序提供用界面、用户逻辑和事务逻辑，应用程序调用的是标准的ODBC函数和SQL语句，应用层使用ODBC API 调用接口与数据库进行交互，使用ODBC来开发应用从系统的程序简称为ODBC应用程序，包括的内容有： 请求连接数据库； 向数据源发送SQL语句 为SQL语句执行结果分配存储空间，定义所读取的数据格式 获取数据库操作结果 ，或处理错误 进行数据处理并向用户提交处理结果 请求事务的提交和回滚操作 断开与数据源的连接 二、驱动程序管理器 驱动程序管理器用来管理各种驱动程序的。管理应用程序和驱动程序之间的通信。主要功能包括了装载OBDC驱动程序、选择和连接正确驱动程序、管理数据源、检查ODBC调用参数的合法性及记录ODBC函数的调用等，当应用需要时返回驱动程序的有关信息。ODBC驱动程序管理器可以建立、配置或删除数据源，并查看系统当前所安装的数据库ODBC驱动程序。下图为ODBC应用系统的体系结构 三、数据库驱动程序 ODBC通过驱动程序来提供应用系统与数据库平台的独立性ODBC应用程序不能直接存取数据库，各种操作请求由驱动程序管理器提交给某个RDBMS的ODBC驱动程序，通过调用驱动程序所支持的函数来存取数据库。数据库的操作结果也铜鼓哦驱动程序返回给应用程序。如果应用程序要操纵不同的数据库，就要动态的链接到不同的驱动程序上。 目前的ODBC驱动程序分单束和多束两类。 单束：数据源和应用程序在同一台机器上，驱动程序直接完成对数据的I/O操作，驱动程序相当于数据管理器。 多束： 支持客户机/服务器、客户机/应用服务器/数据库服务器等网络环境下的数据访问，由驱动程序完成数据库访问请求的提交和结果集接手，应用程序使用驱动程序提供的结果集管理接口操纵执行后的结果集数据。 四、ODBC数据源管理 数据源是最终用户需要访问的数据，包含了数据库位置和数据库类型等信息，实际上是一种数据连接的抽象。 ODBC给每个被访问的数据源指定唯一的，数据源名（Data Source Name，简称DSN）并映射到所有必要的、用来存取数据的底层软件。在连接中，用数据源名来代表用户名、服务器名、所连接的数据库名等。最终用户无需知道DBMS或其他数据管理软件、网络以及有关ODBC驱动程序的细节，数据源最终对用户是透明的。 ODBC API基础ODBC应用程序接口要符合两个方面的一致性： API一致性，API一致性级别有核心级，扩展1级，扩展2级 语法一致性，语法一致性级别有最低限度SQL语法级，核心SQL语法级，扩展SQL语法级。 一、函数概述ODBC3.0标准提供76个函数接口，大概分为 分配和释放环境句柄，连接句柄，语句句柄 连接函数（SQLDriverConnect等） 与信息相关的函数（如获取描述信息函数SQLGetinfo ，SQLGetFunction）； 事务处理函数（如SQLEndTran）； 执行相关函数（SQLExecdirect，SQLExecute等）； 编目函数，提供了11个编目函数如SQLTables、SQLColumn等，应用程序可以通过对编目函数的调用来获取数据字典的信息如权限、表结构等。 二、句柄及其属性句柄是32为整数值，代表一个指针。ODBC3.0中句柄分为环境句柄、连接句柄、语句句柄或描述符句柄四类。对于每种句柄不同的驱动程序有不同的数据结构，这四种句柄的关系如下图 每个ODBC应用程序需要建立一个ODBC环境，分配一个环境句柄，存取数据的全局性背景如环境状态，当前环境状态诊断，当前在环境上分配的连接句柄等。 一个环境句柄可以建立多个连接句柄，每一个连接句柄实现与一个数据源之间的连接 在一个连接中可以建立多个语句句柄，它不只是一个SQL语句，还包括SQL语句产生的结果集以及相关的信息等 在ODBC3.0中提出了描述符句柄的概念，是描述SQL语句的参数，结果集列的元数据集合。 三、数据类型ODBC定义两套数据类型：SQL数据类型：用于数据源C数据类型：用于应用程序的C代码 转换关系如下表| | SQL数据类型 | C数据类型 ||—|—|—|| SQL数据类型 | 数据源之间 | 应用程序变量传送到语句参数（SQLBindparameter） || C数据类型 | 从结果集列中返回到应用程序变量（SQLBindcol） | 应用程序变量之间转换 | ODBC的工作流程一、配置数据源有两种方法： 运行数据源管理工具进行配置 使用Driver Manager提供的ConfigDsn函数来增加、修改或删除数据源，这种方法适用于在应用程序中创建的临时使用的数据源 二、初始化环境由于还没和具体的驱动程序相关联，不是由具体的数据库管理系统驱动程序来进行管理，而是由Driver Manager来进行控制，并配置环境属性，直到应用程序通过调用连接函数和某个数据源进行连接后，Driver Manager才调用所连的驱动程序中的SQLAllocHandle，来实现真正分配环境句柄的数据结构 三、建立连接 应用程序调用SQLAllocHandle分配连接句柄，通过SQLConnect、SQLDriverConnect或SQLBrowseConnect与数据源连接，其中SQLConnect是最简单的连接函数，输入参数为配置好的数据源名称、用户ID和口令。 四、分配语句句柄在处理任何SQL语句之前，还需要首先分配一个语句句柄，语句句柄含有具体的SQL语句以及输出的结果集等信息。在后面的执行函数中，语句句柄都是必要的输入参数。 五、执行SQL语句应用程序处理SQL语句的方式有两种： 预处理(SQLPrepare，SQLExecute适用于语句的多次执行) 直接执行（SQLExecdirect） 如果SQL语句含有参数，应用程序为每个参数调用SQLBindParameter，并把它们绑定至应用程序变量。这样应用程序直接通过改变应用程序缓冲区的内容从而在程序中动态的改变SQL语句的具体执行。接下来的操作会根据语句的类型进行相应的处理 有结果集的语句（Select或是编目函数），则进行结果集处理 没有结果集的函数，可以直接利用本语句句柄继续执行新的语句或是获取行计数（本次执行所影响的行数）之后继续执行。 在插入数据时，采用预编译的方法，首先通过SQLPrepare来预处理SQL语句，将每一列绑定到用户缓冲区。 预编译的好处，只需要进行一次语法分析，可以多次执行同一语句。 六、结果集处理应用程序通过SQLNumResultCols来获取结果集中的列数，通过SQLDescribeCol或者SQLColAttribute函数来获取结果集每一列的名称、数据类型、精度、范围。 ODBC中使用游标来处理结果集数据。游标可分为： forward-only游标：只能在结果集中向前滚动，是默认游标类型 可滚动游标：分为静态、动态，码集驱动和混合型驱动四中 七、中止处理处理结束后，应用程序将首先释放语句句柄，然后释放数据库连接，并与数据库服务器断开，最后释放ODBC环境。 流程如下图]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库学习基础篇②]]></title>
    <url>%2Fposts%2Fa6386957.html</url>
    <content type="text"><![CDATA[基础篇内容 一、数据库安全性 二、数据库完整性 数据库安全性计算机安全性概述 数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏。 安全性问题不是数据库系统所独有的，所有计算机系统都有这个问题。只是在数据库系统中大量数据集中存放，而且为许多最终用户直接共享，从而使安全性问题更为突出。 系统安全保护措施是否有效是数据库系统的主要指标之一。 数据库的安全性和计算机系统的安全性，包括操作系统、网络系统的安全性是紧密联系、相互支持的。 计算机系统的三类安全性问题所谓计算机系统安全性，是指为计算机系统建立和采取的各种安全保护措施，以保护计算机系统中的硬件、软件及数据，防止其因偶然或恶意的原因使系统遭到破坏，数据遭到更改或泄露等。 计算机系统安全性问题可以分成三大类： 技术安全类： 指计算机系统中采用具有一定安全性的硬件、软件来实现对计算机系统及其所存数据的安全保护，当计算机系统受到无意或恶意的攻击时仍能保证系统正常运行，保证系统内的数据不增加、不丢失、不泄露。 管理安全类： 软硬件意外故障、场地的意外事故、管理不善导致的计算机设备和数据介质的物理破坏、丢失等安全问题。 政策法律类 ： 政府部门建立的有关计算机犯罪、数据安全保密的法律道德准则和政策法规、法令。 该笔记只包含技术安全 数据库安全性控制用户标识与鉴别系统提供的最外层安全保护措施。 基本方法是：系统提供一定的方式让用户标识自己的名字或身份；系统内部记录着所有合法用户的标识；每次用户要求进入系统时，由系统核对用户提供的身份标识；通过鉴定后才提供机器使用权。用户标识和鉴定可以重复多次。 常用的方法有： 用户标识（User Identification）：用一个用户名（User Name）或用户标识号（UID）来标明用户身份。 口令（Password）：系统核对口令以鉴别用户身份。通过用户名和口令的方法简单易行，但这些信息容易被人窃取。可以采取更复杂的方法 —— 每个用户预先约定好一个计算过程或者函数。系统提供一个随机数用户根据自己预先约定的计算过程或者函数进行计算系统根据用户计算结果是否正确鉴定用户身份 存取控制数据库安全性所关心的主要是DBMS的存取控制机制。 数据库安全最重要的一点就是确保只授权给有资格的用户访问数据库的权限，同时令所有未授权的人员无法接近数据，这主要通过数据库系统的存取控制机制实现。存取控制机制主要包括两部分： 定义用户权限 合法权限检查 用户权限定义和合法权检查机制一起组成了DBMS的安全子系统 常用存取控制方法有： 自主存取控制（Discretionary Access Control，简称DAC）同一用户对于不同的数据对象有不同的存取权限不同的用户对同一对象也有不同的权限用户还可将其拥有的存取权限转授给其他用户 强制存取控制（Mandatory Access Control，简称 MAC）每一个数据对象被标以一定的密级每一个用户也被授予某一个级别的许可证对于任意一个对象，只有具有合法许可证的用户才可以存取 自主存取控制（DAC）方法主要通过 SQL 的 GRANT 语句和 REVOKE 语句实现自主存取控制。 用户权限由两个要素组成： 数据库对象 操作类型 定义用户存取权限，是指定义用户可以在哪些数据库对象上进行哪些类型的操作。定义存取权限称为授权。 123456789101112 关系数据库系统中的存取权限———————————————————————————————————————————————————————对象类型 对象 操作类型———————————————————————————————————————————————————————数据库 模式 CREATE SCHEMA 基本表 CREATE TABLE ,ALTERTABLE模式 视图 CREATE VIEW 索引 CREATE INDEX数据 基本表和视图 SELECT ,INSERT,UPDATE,DELETE ,REFERENCES,ALL PRIVILEGES数据 属性列 SELECT,INSERT,UPDATE,REFERENCES,ALL PRIVILEGES——————————————————————————————————————————————————————— 自主存取控制的缺点是： 可能存在数据的“无意泄露”。 原因在于： 这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记。 解决方法：对系统控制下的所有主客体实施强制存取控制策略。 授权与回收授权SQL中用GRANT语句向用户授权。GRANT语句的一般格式为：1234GRANT &lt;权限&gt; [,&lt;权限&gt;]... [ ON &lt;对象类型&gt; &lt;对象名&gt; ]TO &lt;用户&gt;[,&lt;用户&gt;]...[ WITH GRANT OPTION ]; 语义：将对指定操作对象的指定操作权限授予指定的用户 一 、GRANT发出GRANT的可以是： DBA 数据库对象创建者（即属主Owner） 拥有该权限的用户接受权限的用户可以是： 一个或多个具体用户 PUBLIC（全体用户） 如果指定了WITH GRANT OPTION 子句，则获得某种权限的用户还可以把这种权限再授予其他用户，没有指定WITH GRANT OPTION子句，则获得某种权限的用户只能使用该权限，不能传播该权限。不允许循环授权。 例 把查询Student表的权限授给U1 123GRANT SELECT ON TABLE StudentTO u1; 例 把对Student表和Course表的全部操作权授予用户U2和U3 123GRANT ALL PRIVILEGESON TABLE Student ,CourseTO U2 U3; 例 把对表SC 和查询权限授予所有用户 123GRANT SELECTON TABLE SCTO PUBLIC; 例 把查询Student表和修改学生学号的权限授给用户U4 123GRANT UPDATE(SNO),SELECTON TABLE StudentTO U4; 对属性列的授权时必须明确指出相应属性列名 例 把对表SC的INSERT权限授予U5 用户，并允许将此权限授予给其他用户 1234GRANT INSERTON TABLE SCTO U5WITH GRANT OPTION; 执行此sql语句后，u5不仅拥有了对表SC的insert权限，还能传播此权限。例如U5还可以将权限授予U6 1234GRANT INSERTON TABLE SCTO U6WITH GRANT OPTION; U6还可以授予给U7123GRANT INSERTON TABLE SCTO U7; 因为U6未给U7传播的权限，所以U7不能再传播此权限。 二、 回收REVOKE授予的权限可以由DBA或其他授权者用REVOKE语句收回REVOKE语句的一般格式为： 123REVOKE &lt;权限&gt;[,&lt;权限&gt;]... [ON &lt;对象类型&gt; &lt;对象名&gt;]FROM &lt;用户&gt;[,&lt;用户&gt;]...; 例： 把用户U4修改学生学号的权限收回 123REVOKE UPDATE(Sno)ON TABLE StudentFROM U4; 例 ：回收所有用户对表SC的查询权限 123REVOKE SELECTON TABLE SCFROM PUBLIC; 例： 把用户U5对SC表的INSERT权限收回123REVOKE SELECTON TABLE SCFROM U5 CASCADE 将用户U5的insert权限收回的时候，必须级联（CASCADE）收回，不然系统将拒绝（restrict）执行该命令，因为在上面授权的例子中，U5将对SC表的insert权限授予了U6，而U6又授予给了U7 注意：这里缺省值为restrict，有的DBMS缺省值为CASCADE，会自动执行级联操作而不必明显的写出CASCADE，如果U6或者U7还从其他用户处获得对SC表的insert权限，那么他们仍然具有此权限。系统只回收直接或间接从U5处获得的权限 SQL灵活的授权机制： DBA：拥有所有对象的所有权限不同的权限授予不同的对象 用户 ：拥有自己建立的对象的全部的操作权限GRANT 授予其他用户 被授权的用户继续授权许可：再授予 所有授予出去的权利在必要时都可以用revoke语句收回。 三、 创建数据库模式的权限 对数据库模式的授权，DBA 在创建用户时实现一般CREATE USER格式： 12CREATE USER &lt;username&gt;[WITH] [ DBA | RESOURCE | CONNECT] 对该语句的说明: 只有系统的超级用户才有权创建一个新的数据库用户 新创建的数据库用户有三种权限：CONNECT , RESOURCE ,DBA CREATE USER命令中没有指定权限的话，默认创建的是CONNECT权限。拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登陆数据库。然后由DBA或者其他用户授予他应有的权限，根据获得的授权权限他可以对数据库对象进行权限范围内的操作。 拥有RESOURCE权限的用户能创建基本表和视图，称为所创建对象的属主，但是不能创建模式，不能创建新的用户。数据库对象的属主可以使用GRANT语句把对象上的权限授予其他用户。 拥有DBA的用户是系统中的超级用户，可以创建新的用户，创建模式，创建基本表和视图等，DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户。 一个DBA用户可以拥有CREATE USER, CREATE SCHEMA和CREATE TABLE 权限，一个RESOURCE用户可以拥有CREATE TABLE权限。 1个数据库下，可以有多个模式。1个模式下，可以有0个或多个表 。首先我来做一个比喻，什么是User，什么是Database，什么是Schema，什么是Table，什么是列，什么是行，？我们可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间，Table可以看作是每个Schema中的床，Table就被放入每个房间中，不能放置在房间之外。然后床上可以放置很多物品，就好比Table上可以放置很多列和行一样。所以Schema包含的是Object，而不是User。User是每个对应数据库的主人，既然有操作数据库的权利，就肯定有操作数据库中每个Schema（房间）的权利。换句话说，如果他是某个仓库的主人，那么这个仓库的使用权和仓库中的所有东西都是他的，他有完全的操作权，。我们还可以给User分配具体的权限，也就是他到某一个房间能做些什么，是只能看（Read-Only），还是可以像主人一样有所有的控制权（R/W），这个就要看这个User所对应的角色Role了.在SQL Server2005中，当我们用Create User创建数据库用户时，我们可以为该用户指定一个已经存在的Schema作为默认Schema，如果我们不指定，则该用户所默认的Schema即为dbo 模式，dbo 房间（Schema）好比一个大的公共房间，在当前登录用户没有默认Schema的前提下，如果你在大仓库中进行一些操作，比如Create Tabe，如果没有指定特定的房间（Schema），那么你的物品就只好放进公共的dbo房间（Schema）了。但是如果当前登录用户有默认的Schema，那么所做的一切操作都是在默认Schema上进行（比如当前登录用户为login1。在SQL Server2005中创建一个数据库的时候，会有一些Schema包括进去，被包括进去的Schema有：dbo，INFORMATION_SCHEMA,guest，sys等等。 数据库角色数据库角色是被命令的一组与数据库操作相关的权限，角色是权限的集合。因此可以为一组具有相同权限的用户创建一个角色，使用角色来管理数据库权限可以简化授权 。 首先用CREATE ROLE语句创建角色，然后用GRANT语句给角色授权 一、角色的创建格式： 1CREATE ROLE &lt;角色名&gt; 刚刚创建的角色是空的，没有任何内容，可以用GRANT为角色授权 二、给角色授权 123GRANT &lt;权限&gt; [,&lt;权限&gt;].....ON &lt;对象类型&gt;对象名 TO &lt;角色&gt; [,&lt;角色&gt;].... DBA和用户可以利用GRANT语句将权限授予给一个或几个角色 三、将一个角色授予其他角色或用户 123GRANT &lt;角色1 &gt; [,&lt;角色2&gt;]....ON &lt;角色3&gt; [&lt;用户1&gt;]....[WITH ADMIN OPTION] 该语句把橘色授予某个用户或另一个角色，这样一个角色（例如角色3）所拥有的权限就是授予它的全部角色（角色1和角色2）所包含的权限的总和。 授予者或者是角色的创建者，或者拥有在这个角色上的ADMIN OPTION。 如果指定了WITH ADMIN OPTION 子句，则获得某种权限的角色或用户还可以将权限再授予其他角色。 一个角色包含的权限包括直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限。 四、角色权限的收回 授予的权限可以由DBA或其他授权者用REVOKE语句收回REVOKE语句的一般格式为： 123REVOKE &lt;权限&gt;[,&lt;权限&gt;]... [ON &lt;对象类型&gt; &lt;对象名&gt;]FROM &lt;用户&gt;[,&lt;用户&gt;]...; 用户可以回收角色的权限，从而修改角色拥有的权限 REVOKE动作的执行者或者是角色的创建者，或者拥有这个角色上的ADMIN OPTION 例 通过角色来实现将一组权限授予一个用户 步骤： 首先创建一个角色R1 1CREATE ROLE R1; 然后使用GRANT语句，使角色R1拥有Student表的SELECT ,UPDATE ,INSERT权限 123GRANT SELECT ,UPDATE,INSERTON TABLE StdentTO R1; 将这个角色授予王平，张明，赵玲，使他们具有角色R1包含的全部权限 12GRANT R1 TO 王平，张明，赵玲; 当然也可以一次性的通过R1来回收王平的三个权限 12REVOKE R1FROM 王平； 例 ： 角色的权限修改 123GRANT DELETEON TABLE StudentTO R1; 使角色R1在原来的基础上增加了Student表的DELETE权限 例123REVOKE SELECTON TABLE StudentFROM R1; 使R1减少了select权限 强制存取控制（MAC）方法 MAC是系统为保证更高程度的安全性，按照TDI/TCSEC标准中安全策略的要求，所采取的强制存取检查手段。 MAC不是用户能直接感知或进行控制的。 MAC适用于对数据有严格而固定密级分类的部门，例如军事部门或政府部门。 在MAC中，DBMS所管理的全部实体被分为两大类： 主体 —— 系统中的活动实体，包括： DBMS所管理的实际用户 代表用户的各进程 客体 —— 系统中的被动实体，是受主体操纵的，包括： 文件 基表 索引 视图 等 对于主体和客体，DBMS为它们的每个实例（值）指派一个敏感度标记（Label）。敏感度标记被分为若干级别，例如： 绝密（Top Secret） 机密（Secret） 可信（Confidential） 公开（Public） 等主体的敏感度标记称为许可证级别（Clearance Level）；客体的敏感度标记称为密级（Classification Level）。MAC机制就是通过对比主体的Label和客体的Label，最终确定主体是否能够存取客体。 强制存取控制规则：当某一用户（或某一主体）以标记Label注册入系统时，系统要求他对任何客体的存取必须遵循下面两条规则： 仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体。 仅当主体的许可证级别等于客体的密级时，该主体才能写相应的客体。 某些系统将第（2）条修正为：仅当主体的许可证级别小于或等于客体的密级时，主体才能写客体。也就是说，用户可为写入的数据对象赋予高于自己的许可证级别的密级这样，一旦数据被写入，该用户自己也不能再读该数据对象了。这两种规则的共同点是：禁止了拥有高许可证级别的主体更新低密级的数据对象，从而防止了敏感数据的泄露。 强制存取控制（MAC）是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记的用户才可以操纵数据，从而提供了更高级别的安全性。 DAC与MAC共同构成DBMS的安全机制实现MAC时要首先实现DAC原因是：较高安全性级别提供的安全保护要包含较低级别的所有保护。 DAC + MAC安全检查：先进行DAC检查通过DAC检查的数据对象再由系统进行MAC检查只有通过MAC检查的数据对象方可存取。 视图机制可以通过视图机制把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护。视图机制的主要功能在于提供数据独立性，其安全保护功能太不精细，往往远不能达到应用系统的要求。可以将视图机制与授权机制配合使用： 首先用视图机制屏蔽掉一部分保密数据 视图上面再进一步定义存取权限 间接实现了支持存取谓词的用户权限定义 例 建立计算机系学生的视图，把对该视图的SELECT权限授于王平，把该视图上的所有操作权限授于张明。 ①首先建立计算机系学生的视图CS_Student 12345CREATE VIEW CS_StudentAS SELECT *FROM StudentWHERE Sdept = 'CS'； ② 然后在视图上进一步定义存取权限 123456GRANT SELECTON CS_Student TO 王平 ；GRANT ALL PRIVILIGESON CS_Student TO 张明； 审计什么是审计？ 启用一个专用的审计日志（Audit Log），将用户对数据库的所有操作记录在上面； DBA可以利用审计日志中的追踪信息，找出非法存取数据的人、时间和内容。 C2以上安全级别的DBMS必须具有审计功能 审计是很费时间和空间的，所以DBMS往往将其作为可选特征，允许DBA根据应用对安全性的要求，灵活地打开或关闭审计功能。审计功能一般主要用于安全性要求较高的部门。 审计一般可以分为：用户级审计： 任何用户都可设置的审计，主要针对用户自己创建的数据库表或视图进行审计，记录所有用户对这些表或视图的一切成功和（或）不成功的访问要求以及各种类型的SQL操作。 系统级审计 ： 只能由DBA设置，用以监测成功或失败的登录要求、监测GRANT和REVOKE操作以及其他数据库级权限下的操作。 AUDIT语句：设置审计功能NOAUDIT语句：取消审计功能 例 对修改SC表结构或修改SC表数据的操作进行审计 12AUDIT ALTER，UPDATE ON SC； 例 取消对SC表的审计 12NOAUDIT ALTER，UPDATE ON SC； 数据加密数据加密防止数据库中数据在存储和传输中失密的有效手段。 加密的基本思想根据一定的算法将原始数据（术语为明文，Plain text）变换为不可直接识别的格式（术语为密文，Cipher text）。不知道解密算法的人无法获知数据的内容。 加密方法主要有： 替换方法 使用密钥（Encryption Key）将明文中的每一个字符转换为密文中的一个字符。 置换方法 将明文的字符按不同的顺序重新排列 混合方法 典型实例：美国1977年制定的官方加密标准——数据加密标准（Data Encryption Standard，简称DES） DBMS中的数据加密： 有些数据库产品提供了数据加密例行程序 有些数据库产品本身未提供加密程序，但提供了接口 数据加密功能通常也作为可选特征，允许用户自由选择 数据加密与解密是比较费时的操作 数据加密与解密程序会占用大量系统资源 应该只对高度机密的数据加密 统计数据库安全性统计数据库 允许用户查询聚集类型的信息（如合计，平均值等） 不允许查询单个记录信息 统计数据库中特殊的安全性问题 隐蔽的信息通道 能从合法的查询中推导出不合法的信息 可以制定规则来防范 规则1：任何查询至少要查询N（N足够大）个以上的记录 规则2：任意两个查询的相交数据项不能超M个 规则3：任一用户的查询次数不能超过1+（N-2）/M 数据库安全机制的设计目标：试图破坏安全的人所花费的代价 &gt;&gt; 得到的利益 小结数据库的安全性是指保护数据库，防止因用户非法使用数据库造成数据泄露、更改或破坏。 实现数据库系统安全性的技术和方法 用户标识与鉴别2.存取控制 自主存取控制方法 强制存取控制方法 视图机制 审计 数据加密 数据库完整性 数据库的完整性是指：数据的正确性和相容性。 例如：学生的学号必须存在而且唯一；性别只能是“男”或“女”；学生选修的课程必须是学校开设的课程，等等。 数据的完整性和安全性是两个不同概念。 数据的完整性，是指防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据。所防范的对象是：不合语义的、不正确的数据。 数据的安全性，是指保护数据库防止恶意的破坏和非法的存取所防范的对象是：非法用户和非法操作。 为维护数据库的完整性，DBMS必须： 提供定义完整性约束条件的机制DBMS应提供定义数据库完整性约束条件（数据必须满足的语义约束条件）的机制，并把它们作为模式的一部分存入数据库中。 提供完整性检查的方法检查用户发出的操作请求是否违背了完整性约束条件 采取违约处理如果发现用户的操作请求使数据违背了完整性约束条件，则采取一定的动作来保证数据的完整性。 实体完整性实体完整性定义关系模型的实体完整性在CREATE TABLE中用PRIMARY KEY定义。 对单属性构成的码有两种说明方法：定义为列级约束条件定义为表级约束条件 对多个属性构成的码只有一种说明方法：定义为表级约束条件 例 将Student表中的Sno属性定义为码 1234567CREATE TABLE Student (Sno CHAR(9) PRIMARY KEY, /* 在列级定义主码*/ Sname CHAR(20) NOT NULL, Ssex CHAR(2) , Sage SMALLINT, Sdept CHAR(20) ); 或者 12345678CREATE TABLE Student (Sno CHAR(9), Sname CHAR(20) NOT NULL, Ssex CHAR(2) , Sage SMALLINT, Sdept CHAR(20), PRIMARY KEY (Sno) /*在表级定义主码*/ ); 例 将SC表中的Sno，Cno属性组定义为码 123456CREATE TABLE SC(Sno CHAR(9) NOT NULL， Cno CHAR(4) NOT NULL， Grade SMALLINT，PRIMARY KEY (Sno，Cno) /* 对于多个属性构成的主码，只能在表级定义*/); ↑一个候选码中有多个属性，候选码可以有多种组合，而主码只是选择了其中一种组合而已，所以主码也可以有多个属性构成，而不是有多个主码 实体完整性检查和违约处理用PRIMARY KEY定义了关系的主码之后，每当对基本表插入记录或对码列进行更新操作时，RDBMS按照实体完整性规则 自动进行检查。包括： 检查主码值是否唯一，如果不唯一则拒绝插入或修改 检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改 从而保证了实体完整性。 检查记录中的主码值是否唯一的一种方法是进行全表扫描，依次判断中表中的每一条记录的主码值和将插入记录上的主码值（或者修改的新主码值）是否相同，如下图所示 全表扫描是十分耗时的。为了避免对基本表进行全表扫描，RDBMS核心一般都在主码上自动建立一个索引，如下图的B+树索引。通过索引查找基本表中是否已经存在新的主码值，将大大提高效率。 参照完整性参照完整性定义关系模型的参照完整性：在CREATE TABLE中用FOREIGN KEY定义外码用REFERENCES指明这些外码参照哪些表的主码。 例如，关系SC中一个元组表示一个学生选修的某门课程的成绩，（Sno，Cno）是主码。Sno，Cno分别参照引用Student表的主码和Course表的主码。 例 定义SC中的参照完整性 12345678CREATE TABLE SC (Sno CHAR(9) NOT NULL， Cno CHAR(4) NOT NULL， Grade SMALLINT， PRIMARY KEY (Sno，Cno)， /* 在表级定义实体完整性 */ FOREIGN KEY (Sno) REFERENCES Student(Sno)， /* 在表级定义参照完整性 */ FOREIGN KEY (Cno) REFERENCES Course(Cno) /* 在表级定义参照完整性 */ ); 参照完整性检查和违约处理一个参照完整性将两个表中的相应元组联系起来了。因此，对被参照表和参照表进行增删操作时有可能破坏参照完整性，必须进行检查。 对表SC和Student有四种可能破坏参照完整性的情况： SC表中增加一个元组，该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。 修改SC表中的一个元组，修改后该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。 从Student表中删除一个元组，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。 修改Student表中的一个元组的Sno属性，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。 当上述的不一致发生时，系统就可以采用以下的策略加以处理。 拒绝（NO ACTION）执行 级连（CASCADE）操作 设置为空值（SET-NULL） 当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。 例如，有下面2个关系 学生（学号，姓名，性别，专业号，年龄）专业（专业号，专业名） 学生关系的“专业号”是外码，因为专业号是专业关系的主码。 假设专业表中某个元组被删除，专业号为12，按照设置为了空值策略，就要把学生表中专业号=12的所有元组的专业号设置为空值。这对应了这样的语义：某个专业删除了，该专业的所有学生专业未定，等待重新分配专业。因此对于参照完整性时，除了应该定义外码，还应定义外码列是否允许空值。 例 显式说明参照完整性的违约处理事例 123456789101112CREATE TABLE SC(Sno CHAR (9) NOT NULL,Cno CHAR(4) NOT NULL,Grade SMALLINT,PRIMARY KEY(Sno,Cno), /*在表级定义实体完整性*/FOREIGN KEY(Sno)REFERENCES Student(Sno) /*在表级定义参照完整性*/ ON DELETE CASCADE /*当删除Student表中的元组时，级连删除SC表中相应的元组*/ ON UPDATE CASCADE, /*当更新Student表中的Sno时，级连更新SC表中相应的元组*/FOREIGN KEY(Cno)REFERENCES Course(Cno) /*在表级定义参照完整性*/ ON DELETE NO ACTION /*当删除course表中的元组造成了与SC表不一致时拒绝删除*/ ON UPDATE CASCADE /*当更新course表中的cno时，级连更新SC表中相应的元组*/ ); 可以对DELETE和UPDATE采用不同的策略，如上面删除被参照表Course表中的元组，造成了不一致时，拒绝删除被参照表的元组，而对更新操作则采取级联更新的策略。 从上面的讨论看到RSBMS在实现参照完整性时，除了要提供定义主码、外码的机制外，还需要提供不同的策略供用户选择。选择哪种策略，要根据应用环境的要求确定。 用户定义的完整性①用户自定义约束条件是针对某一具体应用的数据必须满足的语义要求。 RDBMS提供了定义和检验这类完整性的机制，而不必由应用程序承担。 ② 用户自定义的约束条件检查和违约处理 一、 属性上的约束条件的定义 在CREATE TABLE中定义属性时，可以定义属性或元组上的约束条件，包括： 列值非空（NOT NULL） 列值唯一（UNIQUE） 检查列值是否满足一个布尔表达式（CHECK） 不允许空值例 在定义SC表时，说明Sno和Cno属性不允许取空值 123456789CREATE TABLE SC( Sno CHAR(9) NOT NULL, /* Sno属性不允许取空值 */Cno CHAR(4) NOT NULL, /* Cno属性不允许取空值 */Grade SMALLINT NOT NULL, /*Grade属性不允许取空值*/PRIMARY KEY (Sno， Cno)， /* 如果在表级定义实体完整性，隐含了Sno，Cno不允许取空值，则在列级不允许取空值的定义就不必写了 * / .. .. .. ）； 列值唯一例 建立部门表DEPT，要求部门名称Dname列取值唯一，部门编号Deptno列为主码。 123456CREATE TABLE DEPT (Deptno NUMERIC(2), Dname CHAR(9) UNIQUE, /*要求Dname列值唯一*/ Location CHAR(10), PRIMARY KEY (Deptno) ); 用check短语指定列值应该满足的条件例 Student表的Ssex只允许取“男”或“女” 1234567CREATE TABLE Student(Sno CHAR(9) PRIMARY KEY, /*在列级定义主码*/Sname CHAR(8) NOT NULL, /*Sname属性不允许取空值*/Ssex CHAR(2) CHECK(Ssex in (‘男’或‘女’)), /*性别属性Ssex只允许取男或女*/Sage SMALLINT,Sdept CHAR(20)); SC表的Grade的值应该在0到100之间。 12345678CREATE TABLE SC(Sno CHAR(9)NOT NULL,Cno CHAR(4)NOT NULL,Grade SMALLINT CHECK (Grade&gt;=0 AND Grade &lt;=100),PRIMARY KEY (Sno,Cno),FOREIGN (Sno) PEFERENCES Student(Sno),FOREIGN (Cno)REFERENCES Course(Cno)); 二、 属性上的约束条件检查和违约处理 在往表中插入元组或修改属性的值时，RDBMS会检查属性或元组上的约束条件是否被满足，如果不满足则操作被拒绝执行。 三、 元组上的约束条件的定义 与属性上约束条件的定义类似，在CREATE TABLE语句中可以用CHECK短语定义元组上的约束条件，即元组级的限制。同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件。 例 当学生的性别是男孩时，其名字不能以Ms.打头。 123456789CREATE TABLE Student(Sno CHAR(9),Sname CHAR(8) NOT NULL,Ssex CHAR(2),Sage SMALLINT,Sdept CHAR(20),PRIMARY KEY (Sno),CHECK (Ssex= ‘女’ OR Sname NOT LIKE‘Ms.%’ );/*定义了元组中Sname和Ssex两个属性值之间的约束条件*/ 四、元组上的约束条件检查和违约处理 当往表中插入元组或修改属性的值时，RDBMS就检查元组上的约束条件是否被满足，如果不满足则操作被拒绝执行。 完整性约束命名子句 完整性的约束命名子句 CONSTRAINT〈完整性约束条件名〉[PRIMARY KEY短语 | FOREIGN KEY短语 | CHECK短语] 例 建立学生登记表Student，要求学号在90000-99999之间，姓名不能取空值，年龄小于30，性别只能是“男”或“女”。 1234567891011CREATE TABLE Student(Sno NUMERIC(6) CONSTRAINT C1 CHECK (Sno BETWEEN 90000 AND 99999),Sname CHAR(20) CONSTRAINT C2 NOT NULL,Sage NUMERIC(3) CONSTRAINT C3 CHECK (Sage&lt;30),Ssex CHAR (2) CONSTRAINT C4 CHECK (Ssex IN （‘男’，‘女’）)，CONSTRAINT StudentKey PRIMARY KEY(Sno)); 在Student表上建立了5个约束条件，包括主码约束（命名为StudentKey）以及C1、C2、C3、C4四个列级约束。 例 建立教师表TEACHER，要求每个教师的应发工资不低于3000元。应发工资实际上就是实发工资列Sal与扣除项Deduct之和。 12345678910CREATE TABLE TEACHER(Eno NUMERIC(4) PRIMARY KEY,Ename CHAR(10),Job CHAR(8),Sal NUMERIC(7,2),Deduct NUMERIC(7,2),Deptno NUMERIC(2),CONSTRAINT EMPFKey FOREIGN KEY (Deptno) REFERENCES DEPT(Deptno),CONSTRAINT C1 CHECK (Sal + Deduct &gt;=3000)); 修改表中的完整性限制我们可以使用ALTER TABLE 语句修改表中的完整性限制。 例 去掉上面student表中对性别的限制。 12 ALTER TABLE StudentDROP CONSTRAINT C4； 例 修改表Student中的约束条件，要求学号改为在900000-999999之间，年龄由小于30改为小于40。 可以先删除原来的约束条件，再增加新的约束条件。 12345678ALTER TABLE StudentDROP CONSTRAINT C1;ALTER TABLE StudentADD CONSTRAINT C1 CHECK (Sno BETWEEN 900000 AND 999999),ALTER TABLE StudentDROP CONSTRAINT C3;ALTER TABLE StudentADD CONSTRAINT C3 CHECK (Sage &lt; 40) 域中的完整性限制 SQL支持域的概念，并可以用CREATE DOMAIN语句建立一个域应该满足的完整性约束条件 建立一个性别域，并声明性别域的取值范围 12CREATE DOMAIN GenderDomain CHAR(2) CHECK(VALUE IN(‘男’,’女’)); 对Ssex的说明可以改写为 1Ssex GenderDomain 建立一个性别域GenderDomain，并对其中的限制命名。 12CREATE DOMAIN GenderDomain CHAR(2)CONSTRAINT GD CHECK(VALUE IN(‘男’,’女’)); 删除域GenderDomain的限制条件GD。 12ALTER DOMAIN GenderdomainDROP CONSTRAINT GD; 在域GenderDomain上增加限制条件GDD 12ALTER DOMAIN GenderdomainADD CONSTRAINT GDD CHECK (VALUE IN(‘1’,’0’)); 这样，通过上面两个例子，就把性别的取值范围由(‘男’,’女’) 改为(‘1’,’0’)。 触发器用户定义在关系表上的一类由事件驱动的特殊过程，一旦定义，任何用户对表的增加、修改和删除工作均由服务器自动激活相应的触发器，在DBMS核心层进行集中的完整性控制。触发器类似于约束，但是比约束更加灵活，可以进行更为复杂的检查和操作，具有更精细和更强大的数据控制能力。 定义触发器一般格式 ：12345CREATE TRIGGER &lt;触发器名&gt; &#123; BEFORE | AFTER &#125; &lt;触发事件&gt; ON &lt;表名&gt; FOR EACH &#123; ROW | STATEMENT &#125; [ WHEN &lt;触发事件&gt;] &lt;触发动作体&gt; 各部分语法进行详细说明： 表的拥有者即创建表的用户才可以在表上创建触发器，并且一个表上只能创建一定数量的触发器。 触发器名：触发器名可以包含模式名，也可以不包含模式名。同一模式下，触发器名必须是唯一的；并且触发器名和&lt;表名&gt;必须在同一模式下。 表名：当这个表的数据发生变化时，将激活定义在该表上相应&lt;触发事件&gt;的触发器，因此，该表也称为触发器的目标表。 触发事件：触发事件可以是INSERT、DELETE或UPDATE，也可以是这几个事件的组合，如INSERT OR DELETE等。UPDATE后面还可以有OF 〈触发列…….〉，即进一步修改那些列时触发器激活。 触发器类型：触发器按照所触发动作的间隔尺寸可以分为行级触发器（FOR EACH ROW）和语句级触发器（FOR EACH STATEMENT）。 例如，假设在前面的的TEACHER表上创建了一个AFTER UPDATE触发器。如果表TEACHER有1000行，执行如下语句：UPDATE TEACHER SET Deptone =5;如果该触发器为语句级触发器，那么执行完语句后，触发动作只发生一次。如果是行动级触发器，触发动作将执行1000次。 触发条件：触发器被激活时，只有当触发条件为真时触发动作体才执行；否则触发动作体不执行。如果省略WHEN触发条件，则触发动作体在触发器激活后立即执行。 触发动作体：触发动作体既可以是一个匿名PL/SQL过程块，也可以是对已创建存储过程的调用。如果是行级触发器，在两种情况下，用户都可以在过程体中使用NEW和OLD引用UPDATE/INSERT事件之后的新值和UPDATE/INSERT事件之前的旧值。如果是语句级触发器，则不能在触发动作体中使用NEW和OLD进行引用。如果触发动作体执行失败，激活触发器的时间就会中止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化。 例 定义一个BEFORE行级触发器，为教师表TEACHER定义完整性规则“接受的工资不得低于4000元，如果低于4000元，自动改为4000元”。 12345678CREATE TRIGGER Insert_Or_Update_Sal /*在教师表Teacher上定义触发器*/ BEFORE INSERT OR UPDATE ON Teacher /*触发事件是插入或更新操作*/ FOR EACH ROW /*这是行级触发器*/ AS BEGIN /*定义触发动作体，这是一个PL/SQL过程块*/ If (new.job=’教授’) AND (new.Sal&lt;4000) THEN New.Sal=4000; /*因为是行级触发器，可在过程体中使用插入或更新操作后的新值*/ END IF; END; /*触发动作体结束*/ 例 定义AFTER行级触发器，当教师表Teacher的工资发生变化以后就自动在工资变化表Sal_log中增加一条相应的记录。首先建立工资变化表Sal_log. 12345678910111213141516171819202122CREATE TABLE Sal_log (Eno NUMERIC(4) referencr teacher(eno), Sal NUMERIC(7,2), Username char(10), Date TIMESTAMP)); CREATE TRIGGER Insert_Sal /*建立了一个触发器*/ AFTER INSERT ON Teacher /*触发事件是INSERT*/ FOR EACH ROW AS BEGIN INSERT INTO Sal_log VALUES( New.Eno,new.Sal,CURRENT_USER,CURRENT_TIMESTAMP); END;CREATE TRIGGER Update_Sal /*建立了一个触发器*/ AFTER UPDATE ON Teacher /*触发事件是UPDATE*/ FOR EACH ROW AS BEGIN IF(new.Sal&lt;&gt;old.Sal) THENINSERT INTO Sal_logVALUES(New.Eno,new.Sal,CURRENT_USER,CURRENT_TIMESTAMP)； END IF; END; 例 建一个avg_sc(Sno, avg_grade)表；为SC表建一个触发器，当为sc表插入、删除、修改记录时，自动修改avg_sc表中的值。 12345678910111213CREATE TRIGGER set_avg_trg AFTER INSERT OR UPDATE ON SC FOR EACH ROWAS BEGIN UPDATE avg_sc SET avg_grade = ( SELECT AVG(Grade) FROM SC WHERE SC.Sno = avg_sc.Sno ) WHERE Sno in (SELECT Sno FROM inserted ); INSERT INTO avg_sc (Sno, avg_grade) SELECT Sno, AVG(Grade) FROM SC WHERE Sno in (SELECT Sno FROM inserted) AND Sno not in (SELECT Sno FROM avg_sc) GROUP BY Sno;END; 1234567891011121314CREATE TRIGGER sc_delete_trgAFTER DELETE ON SC FOR EACH ROWAS BEGINUPDATE avg_sc SET avg_grade =(SELECT AVG(Grade) FROM SC WHERE SC.Sno=avg_sc.sno ) WHERE sno in ( SELECT Sno FROM deleted );DELETE FROM avg_sc WHERE Sno in (SELECT Sno FROM deleted WHERE NOT EXISTS ( SELECT * FROM SC WHERE SC.Sno=deleted.Sno)) END; 激活触发器触发器的执行，是由触发事件激活的，并由数据库服务器自动执行的。一个数据表上可能定义了多个触发器，比如多个BEFORE触发器，多个AFTER触发器等。同一个表上的多个触发器激活时遵循如下的执行顺序： （1） 执行该表上的BEFORE触发器； （2） 激活触发器的SQL语句； （3） 执行该表上的AFTER触发器。 对于同一个表上的多个BEFORE（或AFTER）触发器而言，遵循“谁先创建谁先执行”的原则。有些RDBMS是按照触发器的字母排序顺序执行触发器的。 例 执行修改某个教师工资的SQL语句，激活上述定义的触发器。 1UPDATE Teacher SET Sal = 800 WHERE Ename = ‘陈平’； 执行顺序是： （1） 执行触发器Insert_Or_Update_Sal; （2） 执行SQL语句“UPDATE Teacher SET Sal = 800 WHERE Ename = ‘陈平’；” （3） 执行触发器Insert_Sal; （4） 执行触发器Update_Sal。 删除触发器SQL语法如下： 1DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;； 例 删除教师表Teacher上的触发器Insert_Sal. 1DROP TRIGGER Insert_Sal ON Teacher; 小结数据库的完整性是为了保证数据库中存储的数据是正确的。 RDBMS完整性实现的机制 完整性约束定义机制 完整性检查机制 违背完整性约束条件时RDBMS应采取的动作 实体完整性参照完整性用户定义的完整性触发器 这样基础篇的内容就到这里了]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库学习基础篇①]]></title>
    <url>%2Fposts%2F486c9009.html</url>
    <content type="text"><![CDATA[基础篇内容 一、绪论二、关系数据库三、关系数据库标准语言 绪论数据库系统概述一、基础概念 数据数据是数据库存储的基本对象，有多种表现形式。数据的表现形式还不能完全表达其内容，需要经过解释，数据的解释是指对数据含义的说明，数据的含义成为数据的语义，数据和他的语义是不可区分的。 数据库（database，简称DB）是存放数据的仓库，按照一定的格式存放的。严格来说，数据库是长期存储在计算机内，有组织、可共享的大量数据的集合。数据库中的数据按照一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性、并可为各种用户共享。具有三个基本特点：永久存储、有组织、可共享 数据库管理系统（database management system ，DBMS）DBMS的作用就是科学的组织和存储数据，高效的获取和维护数据。主要功能包括了 数据定义功能：提供数据定义语言来对数据对象进行定义 数据组织、存储和管理： 基本目标是提供存储空间利用率和方便存取，提供多种方法（如索引查找，hash查找、顺序查找等）来提供存取效率 数据操纵功能：通过数据操纵语言对数据库进行基本操作，如查询，插入，删除和修改等。 数据库的事务管理和运行管理：数据库在建立、运用和维护时对数据库管理系统统一管理、控制、以保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。 数据库的建立和维护功能：包括了数据库初始数据的输入，转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。 其他功能：DBMS与网络中其他软件系统的通信功能；一个DBMS与另一个DBMS或文件系统的数据转换功能；异构数据库之间的互访和互操作功能等。 数据库系统（database system，DBS）数据库系统是指计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、应用系统、数据库管理员构成。 二、 数据库系统的特点 数据结构化这是一个主要特征之一。所谓的“整体”结构化是指数据库的数据不再仅仅针对某一个应用，而是面向全组织；不仅数据内部是结构化的，而且整体也是结构化的，数据之间是具有联系的。在数据库系统中，不仅数据是整体结构化，而且存取数据的方式也很灵活，可以存取数据库中的某一个数据项、一组数据项、一个记录或一组记录。 数据的共享性高，冗余度低，易扩充数据是面向整个系统，可以被多个用户多个应用共享使用，数据共享可以大大减少数据冗余，还能避免数据之间的不相容性和不一致性。数据不一致性是指同一数据由于人工管理或者文件系统管理时，重复存储，导致不同拷贝的值不一样。 数据独立性高数据的物理独立性：是指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。即，数据在磁盘上怎样存储由DBMS管理，用户程序不需要了解，应用程序要处理的只是数据的逻辑结构，这样当数据的物理存储改变了，应用程序不用改变。逻辑独立性：是指用户的应用程序与数据库的逻辑结构是相互独立的，即，当数据的逻辑结构改变时，用户程序也可以不变。数据独立性由DBMS的二级映像功能来保证。 数据由DBMS统一管理和控制数据库的共享是并发共享，即多个用户可以同时存取数据库中的数据甚至同时存储同一个数据。所以DBMS还提供以下几个数据控制功能：（1）数据的安全性保护（2）数据的完整性检查（3）并发控制（4）数据库恢复 总结：数据库是长期存储在计算机内有组织的大量的共享的数据集合。它可以提供各种用户共享，具有最小冗余度和较高的数据独立性。 数据模型数据模型是现实世界数据特征的抽象 数据模型应该满足三个方面：比较真实的模拟现实世界；二是容易为人所理解；三是便于在计算机实现。 根据不同的目的，可以把模型划分两类： 概念模型：也称为信息模型，按照用户的观点来对数据和信息建模，主要用于数据库设计 逻辑模型和物理模型：逻辑模型主要包括层次模型，网状模型，关系模型，面向对象模型和对象关系模型等。是按照计算机系统的观点对数据建模。主要用于DBMS的实现。物理模型是对数据最底层的抽象，描述数据在系统内部的表示方法和存取方法，是面向计算机系统的。物理模型的具体实现是DBMS的任务，数据库设计人员要了解和选择物理模型，一般用户则不需要考虑物理级的细节。 数据模型的组成要素一般来说，数据模型是严格定义一组概念的集合，这些概念精确地描述了系统的静态特性，动态特性和完整性约束条件。因此数据模型通常由数据结构，数据操作和完整性约束三部分来组成。 一、 数据结构数据结构描述数据库的组成对象以及对象之间的联系。有两类： 是与对象的类型，内容，性质有关的，例如网状模型中的数据项，记录，关系模型中的域，属性，关系等。 是与数据之间的联系有关的对象，例如网状模型中的系型。 二、 数据操作 数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。 数据库的主要有查询和更新（包括插入，删除、修改）两大类操作。数据模型必须定义这些操作的确切含义，操作符号，操作规则（如优先级）以及实现操作的语言。 数据操作是对系统动态特性的描述。 三、 数据的完整性约束条件 数据的完整性约束条件是一组完整性规则。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态和状态的变化，以保证数据的正确，有效，相容。 数据模型应该反映和规定本数据模型必须遵守的基本的通用的基本的通用的完整性约束条件。 数据模型还应该提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。 概念模型概念模型一方面应该具有较强的语义表达能力，能够方便、直接的表达应用中的各种语义知识、另一方面应该简单，清晰，易于用户理解。 基本概念（1） 实体：客观存在并可相互区别的事物成为实体。可以是具体的人事物，也可以是抽象的概念或者联系，比如老师和学校的工作关系。 （2）属性：实体所具有的某一特性称为属性。一个实体可以由若干的属性来刻画，比如学生这个实体可以由学号姓名性别出生年月等信息组成。 （3）码:唯一标识实体的属性集称为码。比如学号是学生实体的码。 （4）域：属性的取值范围称为该属性的域，比如学号的域为8位整数，姓名的域为字符串集合，学生年龄的域为整数，性别的域为（男，女） （5）实体型：具有相同属性的实体必然具有共同的特征和性质。用实体名以及属性名称集合来抽象和刻画同类实体，称为实体型。比如学生（学号，姓名，性别，出生年月，所在院系，入学时间）就是一个实体型。 （6）实体集：同一类型实体的集合称为实体集，例如全体学生就是一个实体集 （7）联系：实体内部的联系通常是指组成实体的各属性之间的联系；实体之间的联系通常是指不同的实体集之间的联系。 实体型之间的联系一、两个实体型的联系分为三种： 一对一联系（1：1）如果对于实体集A中每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，则称为一对一联系。比如电影院座位和观众实体之间的联系 一对多联系（1：n）如果对于实体集A中每一个实体，实体集B中有n个实体（n&gt;=0）与之联系，比如部门和员工两个实体集之间的联系。 多对多联系（n:n）表示实体集A中多个实体可与实体集B中多个实体相联系。例如一门课程可以同时有若干学生选修，而一个学生也可以同时选修多门课程，这就是多对多联系。实际上，一对一联系是一对多联系的特例，而一对多联系又是多对多联系的特例。 二、 两个以上的实体型之间的联系 一般来说，两个以上的实体型也存在一对一，一对多，多对多的联系比如 课程，老师，参考书 。一个课程可以由若干个老师讲授，也可以使用若干本参考书，这就是一对多。供应商与项目，零件的联系，一个供应商可以供给多个项目多种零件，而且每个项目可以使用多个供应商供应的零件，每种零件可由不同的供应商攻击。所以是多对多联系。 三、 单个实体型内的联系 同一个实体集内的各实体之间也可以存在一对一，一对多，多对多的联系。比如职工内部也存在领导与被领导的关系，而一个职工仅被另一个职工直接领导，这是一对多的联系 四、概念模型的一种表示方法：实体–联系方法 概念模型的方法挺多，最著名的是实体-联系方法（entity-relationship Approach）。该方法用E-R图来描述现实世界的概念模型，也称为E-R模型 E-R图提供表示实体型、属性和联系的方法： 实体型 ：用矩阵表示，矩形框内写明实体名 属性：用椭圆表示，并用无向边将其相应的实体型连接起来 例如 ：学生实体具有学号、姓名、性别、出生年份、系、入学时间等属性，用E_R图表示如下 联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁边表上联系的类型（1:1,1:n或m:n） 如果联系具有属性，那么这些属性也需要用无向边和该联系连接起来 五、 一个实例 下面用E-R图来表示某个工厂物资管理的概念模型 物资管理设计的实体有： 仓库 —属性有仓库号，面积，电话号码 零件 —属性有零件号，名称，规格，单价，描述 供应商—属性有供应商号，姓名，地址，电话号码，账号 项目 —属性有项目号，预算，开工日期 职工 —属性有职工号，姓名，年龄，职称 这些实体的联系如下：（1）一个仓库可以存放多种零件，一种零件可以存放在多个仓库中，因此仓库和零件具有多对多的联系。用库存量来表示某种零件在某个仓库中的数量（2）一个额仓库有多个职工当仓库保管员，一个职工只能在一个仓库工作，因此仓库和职工之间是一对多的联系。（3）职工之间具有领导和被领导关系，即仓库主任领导若干保管员，因此职工实体型中具有一对多的联系。（4）供应商、项目和零件三者之间具有多对多的联系。即一个供应商可以供给若干项目多种零件，每个项目可以使用不同供应商供应的零件，每种零件可由不同的供应商供给。 最常用的数据模型目前最常用的逻辑数据模型有： 层次模型 网状模型 关系模型 面向对象模型 对象关系模型 其中层次模型和网状模型称为非关系模型，在非关系模型中，实体用记录表示，实体的属性对应记录的数据项（或字段）。实体之间的联系在非关系模型中转换成记录之间的两两联系。 非关系模型非关系模型中的数据结构的单位是基本层次联系，就是指两个记录及他们之间的一对多（包括一对一）的联系。如图 Ri位于联系Lij的始点，称为双亲节点，Rj位于联系Lij的终点，称为子女节点 层次模型层次模型用树形来表示各类实体以及实体间的联系。现实世界中许多实体之间的联系本来就呈现出一种很自然的的层次关系，如行政机构，家族关系等。 一、层次数据模型的数据结构 满足下面两个条件的集合为层次模型 （1）有且只有一个节点，没有双亲节点，这个节点称为根节点（2）根以外的其他节点有且只有一个双亲节点。 在层次模型中，每个节点表示一个记录模型，记录（类型）之间的联系用节点之间的连线（有向边）表示，这种联系是父子之间的一对多的联系。 每个记录模型可包含若干个字段，记录类型描述的是实体，字段描述实体的属性，各个记录类型及其字段都必须命名。各个记录类型、同一个记录类型里的各个字段不能同名。 下图是一个教员学生层次模型，有4个记录型，其中记录型– 系 是根节点，由系编号，系名，办公地点三个字段组成。两个子女节点教研室和学生。记录型– 教研室 是系的子女节点，同时又是教员的双亲节点。由教研室编号，教研室名两个字段组成。记录型– 学生 由学号，姓名，成绩三个字段组成。记录型– 教员由职工号，姓名，研究方向三个字段组成。学生和教员是叶节点，他们没有子女节点。由系到教研室，由教研室到教员，由系到学生均是一对多的联系。 下图是上图对应的一个值，该值是D02系记录值及其所有后代记录值组成的一棵树。 二、 多对多联系在层次模型中的表示 如果用层次模型表示多对多联系，必须首先将多对多联系分解成一对多联系。分解方法两种：冗余节点法和虚拟节点法 下图是简单的多对多，一个学生可以选修多门课程，一门课程可由多个学生选修，学生由学号，姓名，成绩三个字段组成。课程由课程号两个字段组成。 下图是采用冗余节点法，通过增加两个冗余节点将多对多联系转换成两个一对多联系 下图是采用虚拟节点的分解方法，将冗余节点换成虚拟节点，所谓虚拟节点就是一个指针，指向所代替的节点。 冗余节点法的优点是结构清晰，允许节点改变存储位置，缺点需要额外空间，并有潜在的不一致性问题。虚拟节点的优点在减伤空间的浪费吗，避免产生潜在不一致性，缺点是节点改变了存储位置可能引起虚拟节点中指针的修改。 三、层次模型的数据操纵与完整性约束 层次模型的数据操纵主要有查询，插入，删除和更新，进行插入，删除，更新操作时要满足层次模型的完整性约束条件。 在进行插入操作的时候，如果没有相应的双亲节点就不能插入它的子女节点值，比如在上面的教员学生层次模型中，若新加入一名教员，但是还没分配教研室，这就就不能插入到数据库中。 在进行删除操作时，如果删除双亲节点，那么双亲节点下的子女节点值也被同时删除。在教员学生层次模型中，删除教研室，那么该教研室的教员的数据也会全部丢失。 四、层次数据模型的存储结构 层次数据库中不仅要存储数据本身，还要存储数据之间的层次联系。层次模型数据的储存常常是和数据之间的储存结合在一起的，常用方法有两种 邻接法按照层次树穿越的顺序把素有记录值依次邻接存放，即通过物理空间的位置相邻来体现（或隐含）层次顺序。 链接法用指针来反映数据之间的层次联系。 子女-兄弟链接法：每个记录设两类指针，分别指向最左边的子女（每个记录型对应一个）和最新的兄弟。 层次序列链接法：按照树的前序穿越链接各记录值 五、层次模型的优缺点 优点： 层次模型的数据结构比较简单清晰 层次数据库的查询效率高层次数据库的性能优于关系数据库，不低于网状数据库 层次数据模型提供了良好的完整性支持 缺点： 现实世界很多是非层次性的，如节点之间具有多对多联系 一个节点如果具有多个双亲等，层次模型表示这类联系方法就很笨拙。 查询子女节点必须通过双亲节点 由于结构严密，层次命令趋于程序化 网状模型由于很多联系是非层次的，用层次模型表示非树形结构是很不直接的，而网状模型则可以克服这个问题。 一、 网状数据模型的数据结构满足以下两个条件则称为网状模型：（1）允许一个以上的节点无双亲（2）一个节点可以有多余一个的双亲 网状模型是一种比层次模型更具有普遍性的结构，去掉了层次模型的两个限制，允许多个节点没有双亲节点，允许节点可以有多个双亲节点。还允许两个节点之间有多重联系（称为符合联系）。网状模型可以更直接的去描述现实世界，而层次模型实际上是网状模型的一个特例。 网状模型中每一个节点表示一个记录类型（实体），每个记录类型可包含若干个字段（字体的属性），节点间的连线表示记录类型（实体）之间的一对多的父子联系。在层次模型中，子女节点和双亲节点的联系是唯一的，而在网状模型中的是可以不唯一的。 下面是网状模型的例子 以学生选课为例： 一个学生可以选修若干门课程，某一课程可以被多个学生选修，因此学生与课程之前是多对多联系。为了表示多对多的联系，引入了一个学生选课的联结记录，由三个数据项组成，即学号，课程号，成绩，表示某个学生选修某一门课程及其成绩。 学生选课就包含了三个记录，学生、课程、选课 每个学生可以选多门课程，即对学生记录中的一个值，选课记录中可以多个值相联系，而选课记录中的一个值，只能和学生记录中的一个值联系。学生和选课之间的联系是一对多的联系。联系名为S-SC。同样课程与选课的联系也是一对多的联系。联系名为C-SC 。 下图是一个学生，选课，课程的网状数据库的一个值 二、 网状数据模型的操纵和完整性约束 DBTG在模式DDL中提供了定义DBTG数据库完整性的若干概念和语句：（1）支持记录码的概念，码即唯一表示记录的数据项的集合。例如学生记录中的学号是码，因此不允许学生记录中出现重复的学号。（2）保证一个联系中双亲记录和子女记录之间是一对多的联系。（3）可以直接双亲记录和子女记录的某些约束条件。比如有些子女记录要双亲记录存在才可以插入，双亲记录删除也会连同删除。 三、网状数据模型的存储结构 最常用的是链接法，包括单向链接，双向链接，环状链接和向首链接，此外还有其他方法：引元阵列法，二进制阵列法，索引法，根据具体情况来使用。 设一个网状数据库的实例： 学生记录：S1 , S2 , S3; 课程记录：C1 , C2 , C3; S1的选课记录: S1C1A 、S1C2A; S2的选课记录: S2C1A 、S2C3B; S3的选课记录: S3C1B 、S3C2B S4的选课记录: S4C1A 、S4C2A 、S4C3B 学生选课数据库中 学生、课程、选课三个记录的值可以分别按某种文件组织方式存储，记录之间的联系用单向链接实现 图中的实线链表示S-SC联系，即把S1学生和他的选课记录（选修的C1，C2两门课程的选课记录）链接起来，同样把S2,S3,S4学生和他们的选课记录链接起来； 虚线表示C-SC联系，把C1课程和选修了C1课程的学生记录（有S1,S2,S3,W4学生选修了C1）链接起来，同样把C2,C3课程和选修了这些课程的学生记录链接起来。 四、网状数据模型的优缺点 优点： 能够更直接的描述现实世界，比如一个节点可以有多个双亲，节点之间可以有多重联系 具有良好的性能，存取效率较高 缺点： 结构比较复杂，随着应用环境的阔达，数据库的结构变得越来越负责，不利于最终用户掌握。 网状模型的DDL，DML复杂，并且要嵌入某一种高级语言（COBOL ，C）。用户不容易掌握，不容易使用。 由于记录之间的联系是通过存取路径实现的，应用程序在访问在访问数据时必须选择适当的存取路径，因此用户必须了解系统结构的细节，家中了编写应用程序的负担。 关系模型关系模型是目前最重要的一种数据模型。关系数据莫系统采用关系模型作为数据的组织方式。 一、 关系数据模型的数据结构 关系模型与上面的模型不同，是建立在严格的数学概念的基础上的。从用户观点上看，关系模型是由一组关系组成，每个关系的数据结构是一张规范化的二维表。以下图学生登记表为例 关系（relation）：一个关系对应通常说的一张表，如学生登记表 元祖（tuple）: 表中的一行即为一个元祖； 属性（Attribute）：表中的一列即为一个属性，给每一个属性起一个名称即为属性名。如这张表有6列，对应六个属性（学号，姓名，年龄，性别，系名，年级） 码（key）：也称为码键。表中某个属性组，它可以唯一确定一个元祖，如表中的学号可以确定一个学生，也就称为本关系的码 域（domain）：属性的取值范围，如人的年龄一般在1~150岁之间，大学生年龄属性域是（14~38），性别的域是（男，女），系名的域是一个学校所有系名的集合； 分量：元祖中的一个属性值 关系模式：对关系的描述，一般表示为 关系名（属性1，属性2，…… ，属性n） 上面的关系可以描述为 学生（学号，姓名，年龄，性别，系名，年级） 在关系模型中，实体以及实体间的联系都是用关系来表示。例如，学生，课程，学生与课程之间的多对多联系在关系模型中可以如下表示： 学生（学号，姓名，年龄，性别，系名，年级） 课程（课程号，课程名，学分） 选修（学号，课程号，成绩） 关系模型要求关系必须是规范化的，即要求关系必须满足一定的规范条件：关系的每一个分量必须是一个不可分的数据项，也就是说不允许表中还有表。 下图是一个术语的粗略对比 二、 关系数据模型的操纵和完整性约束 主要操作：查询，插入，删除和更新数据。 完整性约束包含三大类：实体完整性，参照完整性，用户定义完整性 关系模型中的的数据操作都是集合操作，操作对象和操作结果都是关系，即若干元祖的集合，而不像非关系模型中国那样是单记录的操作方式。另一方面，关系模型把存取路径隐藏起来，用户只需要指出“干什么”、“找什么”，不必详细说明“怎么干”或“怎么找”，从而大大的提高了数据的独立性，提高了用户生产率。 三、关系数据模型的存储结构 在关系数据模型中，实体及实体间的联系都用表来表示，在关系数据库的物理组织中，有的DBMS 一个表对应一个操作系统文件，有的DBMS从操作系统获得若干大的文件，自己设计表、索引等存储结构。 四、关系数据模型的优缺点优点： 关系模型与非关系模型不同，是建立在严格的数学概念的基础上 关系模型的概念单一，无论实体还是实体之间的联系都用关系来表示。对数据的检索和更新结果也是关系（即表）所以其数据结果简单、清晰、用户易懂易用。 关系模型的存取路径对用户透明，从而更有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作。 缺点： 由于存取路径透明，查询效率往往不如非关系数据模型。 数据库的系统结构 本章学习的是数据库系统的模式结构 数据库系统模式的概念在数据模型中有“型”（T）和“值（value）”的概念。型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。例如学生记录定义为（学号，姓名，性别，系别，年龄，籍贯）这样的记录型，而（900201,李明，男，计算机，22,江苏）则是该记录型的一个记录值 模式是数据库中全体数据的逻辑结构和特征的描述，仅仅涉及到型的描述，不涉及到具体的值。模式的一个具体值称为模式的一个实例。同一个模式可以有很多实例。 模式是相对稳定的，而实例是相对变动的，因为数据库的数据是不断更新的，模式反应的是数据的结构和联系，而实例反映的是数据库某一时刻的状态。 数据库系统的三级模式结构三级模式是指数据库系统由外模式，模式和内模式构成。 模式（Schema） 模式也叫逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。属于数据库系统模式结构的中间层，既不涉及数据的物理存储细节和硬件环境，也与具体的应用无关。 模式实际上是数据库数据在逻辑级上的视图。一个数据库只有一个模式。数据库模式以某一种数据模型为基础，考虑所有用户的需求，结合成一个逻辑整体。 定义模式时要定义数据的逻辑结构，比如数据记录是由哪些数据项构成，数据项的名字、类型、取值范围等，而且要定义数据之间的联系，定义与数据有关的安全性、完整性要求。 外模式（External Schema） 外模式也称为子模式或者用户模式，是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。 外模式通常是模式的子集。一个数据库可以有多个外模式，。对模式中的同一数据，在外模式中的结构、类型、长度、保密级别都可以不同。同一个外模式可以被某一个用户的多个应用系统使用，但是一个应用程序只能使用一个外模式。 外模式是保证数据库安全性的一个有力措施，每个用户只能看见和访问所对应的外模式中的数据，数据中的其余数据是不可见的。 内模式（Internal Schema）内模式也称为存储模式（Storage Schema），一个数据库只有一个内模式，是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。例如，记录的存储方式是顺序结构存储还是B树结构存储；索引按什么方式组织；数据是否压缩，是否加密；数据的存储记录结构有何规定等。 粗略的表达：内模式就是存储如表在哪个表空间在哪里有索引，表空间的数据文件放在哪里，在哪个磁盘。 数据的二级映像和功能和数据独立性数据库系统的三级模式是对数据的三个抽象级别，为了在系统内部实现这三个抽象层次的联系和转换，提供了两层映像： 外模式/模式 映像 模式 / 内模式 映像 这两层映像保证了数据库系统的数据能够具有较高的逻辑独立性和物理独立性。 外模式/模式 映像 模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。 同一个模式可以有任意多个外模式，。 每一个外模式，数据库系统都有一个外模式/模式映像，定了了外模式与模式之间的对应关系，这些映像的定义通常包含在各自的外模式的描述中。 当模式改变时，由数据库管理员对每个 外模式/模式映像进行改变，可以使外模式不变，从而不必修改应用程序。保证了数据与程序的逻辑独立性。 模式/内模式映像数据库只有一个模式，也只有一个内模式，所以模式/内模式映像是唯一的，定义了数据全局逻辑结构与存储结构之间的对应关系。例如说明逻辑记录和字段在内部是如何表示的。该映像定义一般包含在模式描述中。 当数据库的存储结构改变了，数据库管理员对模式/内模式映像作相应改变，就可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性。 三种模式的归纳： 在三级模式中，模式即全局逻辑结构是数据库的中心和关键，独立于数据库的其他层次，设计数据库模式结构时应首先确定数据库的逻辑模式。 数据库的内模式依赖于全局逻辑结构，独立于外模式，也独立于存储设备。它是将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率。 数据库的外模式面向具体的应用程序，定义在逻辑模式之上，独立于存储模式和存储设备。当应用需求发生较大变化，相应外模式不能满足其视图要求时，外模式就得做改动。因此设计外模式需要充分考虑应用的扩充性。 数据库系统的组成大概分为 硬件平台及数据库： 大内存 大磁盘 系统具有较高的通道能力 软件： DBMS 支持DBMS的操作系统 具有数据库接口的高级语言 以DBMS为核心的应用开发工具 为特定应用环境开发的数据库应用系统 人员 数据库管理员 系统分析员和数据库设计人员 应用程序员 用户 关系数据库关系数据结构及形式化定义关系数据结构关系模型的数据结构只包含单一的数据结构—–关系在用户看来，关系模型中的数据的逻辑结构是一张扁平的二维表 域（domain）域是一组具有相同数据类型的集合 笛卡儿积（Cartesian product）给定一组域D1，D2, … … ，Dn，这些域可以相同 关系（relation） 当n=1时，称该关系为单元关系当n=2时，称为二元关系 关系是笛卡尔积的有限子集，所以关系也是二维表。每行对应一个元祖，每列对应一个域，由于域可以相同，为了加以区分，必须对每列起一个名字，称为属性（attribute），n目的关系必有n个属性。 候选码（Candidate Key）： 关系中可以唯一地标识一个元组的 属性 或 属性组。 主码（Primary Key）： 若一个关系又多个候选码，则选定其中一个为主码。 主属性（Non-Key attribute）：包含在任何候选码中的诸属性称为主属性。不包含在任何候选码中的属性称为非码属性。 外码（Froregin Key）： 如果关系模式 R 中的属性或者属性组非该关系的码，但是它是其他关系的码，那么该属性集对关系模式 R而言是外码。 全码（All-Key）：关系模型的所有属性组是这个关系模式的候选码，称为全码。 一般来说，D1,D2,D3,D4…..Dn的笛卡尔积是没有实际语义的，只有它的某个子集才有实际含义。 关系有三种类型：基本关系（基本表或基表）、查询表、视图表 基本表是实际存在的表，是实际存储数据的逻辑表示。 查询表是查询结果对应的表 视图表是由基本表或者其他视图表到处的表，是虚表，不对应实际存储的数据 基本关系具有六条性质： 列的同质性 列名唯一性 列序无关性 元祖相异性 行序无关性 分量原子性 在实际关系数据库产品中，不一定完全会具备这几条性质 关系模式关系模式是型，关系是值 关系的描述称为关系模式 ，形式化表示为R(U,D,DOM,F)其中R为关系名，U为组成该关系的属性名集合，D为属性组U中的属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合 关系数据库关系数据库的型也称为关系数据库模式，是对关系数据库的描述。关系数据库模式包括： 若干域的定义 在这里域上定义的若干关系模式 关系操作关系模型给出了关系操作能力的说明，但不对RDBMS给出具体的语法要求，也就是说不通的RDBMS可以定义和开发不通的语言来实现这些操作。 基本的关系操作通常分为两大操作： 查询（query） 插入（insert）、删除（delete）、修改（update） 关系的查询表达能力很强，是关系操作中最主要的部分。 查询操作又可以分为：选择（select）、投影（project）、链接（join）、除（divide）、并（union）、交（intersection）、笛卡尔积等其中选择，投影，并，差，笛卡尔积是5种基本操作，其他操作可以由基本操作来定义和导出的。 关系操作的特点就是集合操作方式，即操作的对象和结果都是集合。也称为一次一集合（set-at-a-time）的方式，而非关系数据库模型的数据操作方式则为一次一记录（record-at-a-time）的方式。 关系数据语言分类早期是用代数方式或逻辑方式表示，称为关系代数和关系演算 关系代数，元祖关系演算和域关系演算均为抽象的查询语言，跟具体的RDBMS中实现的语言不完全一样。 一种介乎于关系代数和关系演算之间的语言SQL，具有丰富的查询功能，还具有数据定义和数据控制功能，是集合了查询、DDL、DML和DCL于一体的关系数据语言。 关系的完整性关系模型的完整性规则是对关系的某种约束条件，也就是说关系的值随着时间变化时应该满足一些约束条件，这些条件实际上是现实世界的要求，任何关系都是需要时刻满足这些语义约束。 关系的三类完整性约束实体完整性规则：若属性（一个或一组属性）A是基本关系R的主属性，那么A不能取空值 所谓空值就是“不知道”或“不存在”的值 规则说明： 实体完整性是针对基本关系而言的 现实世界的实体是可区分的，即他们具有某种唯一标识 关系模型中以主码作为唯一标识 主码中的属性即主属性不能取空值。 参照完整性 关系间的引用：在关系模型中实体及实体间的联系都是用关系来描述的，因此可能存在关系与关系间的引用。 外码 设FALSE是基本关系R 的一个或一组属性，但不是关系R 的码。如果F与基本关系s的主码Ks相对应，则称F为基本关系R的外码 基本关系R称为参照关系 基本关系S称为被参照关系或目标关系 关系R和关系S不一定是不同的关系 显然目标关系S的主码Ks和参照关系R的外码F必须定义在同一个（或同一组）域上。 注意的是，外码不一定要和相应的主码同名，不过在实际中，为了便于识别，尽量取相同的名字。 所以参照完整性规则就是定义外码和主码之间的引用规则 参照完整性规则： 若属性（属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同关系），则对于R中每一个元祖在F上的值必须为 或者取空值（F的每个属性值均为空值） 或者等于S中某个元祖的主码值 具体如图 用户定义的完整性不同的数据库系统根据应用环境的不同，还需要特殊的约束条件，而用户定义的完整性就是针对某一具体关系数据库的约束条件。 针对某一具体关系数据库的约束条件，反应某一具体应用的所涉及的数据必须满足的语义要求 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法去处理它们，而不要用程序来承担这一个功能 关系代数关系代数是一种抽象的查询语言，运算对象，运算符，运算结果是运算的三大要素关系代数的运算对象是关系，运算结果也是关系运算符包括四类：集合运算符，专门的关系运算符，算术比较符，逻辑运算符。 关系代数的运算按运算符的不同可分为传统的集合运算符和专门的关系运算符。其中集合运算符是把关系看成元祖的集合。专门的关系运算符不仅涉及行还涉及列。比较运算符和逻辑运算符是用来辅助专门的关系运算符进行操作的。 传统的集合运算 并（Union）关系 R 与 S 具有相同的关系模式，即 R 与 S 的元数相同（结构相同），R 与 S 的并是属于 R 或者属于 S 的元组构成的集合，记作 R ∪ S，定义如下： R∪S = {t | t∈R ∨ t∈S} 差（Difference）关系 R 与 S 具有相同的关系模式，关系 R 与 S 的差是属于 R 但不属于 S 的元组构成的集合，记作 R − S，定义如下 R−S = {t | t∈R∨t∉S} 交（Intersection）关系R和关系S交由即属于R又属于S的元组组成， 其结果仍为n目关系 R∩S = {t | t∈R ∧ t∈S } 笛卡尔积（cartesian product）两个无数分别为 n 目和 m 目的关系 R 和 S 的 笛卡尔积是一个 (n+m) 列的元组的集合。组的前 n 列是关系 R 的一个元组，后 m 列是关系 S 的一个元组，记作 R × S，定义如下： R×S = { t | t =&lt; (tn,tm) ∧ tn∈R ∧ tm∈S} 专门的关系运算专门的运算关系包括 选择、 投影、连接 、 除运算等。 先做几个记号 目=列数，n目或者n度指的是关系表有n个属性，也就是有n列 选择(selection)定义：在关系R中选出满足指定条件F的元组(行操作)表达式：σF(R) = {t | t∈R ∧ F(t)=’真’},逻辑表达式F的基本形式为：X1 θ Y1其中 θ 表示比较运算符或者逻辑运算符，X1、Y1等是属性名或常量或简单函数，而属性名也可以用它的序号来代替比较运算符:① ： &gt; 大于② ： ≥ 大于等于③ ： &lt; 小于④ ： ≤ 小于等于⑤ ： = 等于⑥ ： &lt;&gt; 不等于 逻辑运算符：┐ 非∧ 与∨ 或 下图查询信息系（is系）全体学生 其中下角标 5 为Sdept的属性序号 投影(projection)定义：从关系R中选出若干属性A组成新关系(列操作)表达式：πA(R) = { t[A] | t∈R}其中A为R中的属性列投影操作是从列的角度进行和运算的投影之后不仅取消了原关系的某些列，还可能取消了某些元组，因为取消了某些属性后，就可能出现重复行，所以应该取消这些完全相同的行。 连接(join)定义：从两个关系R和S的笛卡尔积中选取属性间满足指定条件AθB的元组表达式：R∞S(AθB) = {t(r)t(s)|t(r)∈R∧t(s)∈S∧t(r)[A]θt(s)[B]} 普通连接 关系R：A B Ca b cb a cc a b关系S:A B Cb a ca b cc a b连接起来：RA RB RC SA SB SCa b c a b ca b c b a ca b c c a bb a c a b cb a c b a cb a c c a bc a b a b cc a b b a cc a b c a b就是R的第一行不断的加S的第一行，第二行，第三行，R的第二行不断的加以S的第一行，第二行，第三行一直加下去拓展关系：连接分两种：等值连接与自然连接①等值连接：指定条件AθB的θ为’= ‘时那么就把上面普通连接里面RA和SB相同的保留，其他去掉，而且重复的两行也去掉一行RA RB RC SA SB SCa b c b a ca b c c a bb a c a b c②自然连接：在等值连接的基础上去除重复的属性A B Ca b ca b cb a c 除运算(division)定义：设关系R除以关系S的结果为关系T,则T包含所有在R但不在S中的属性及值,且T的元组与S的元组的所有组合都在R中.表达式：R÷S = {t(r)[X]|t(r)∈R∧π(Y)(S)属于Y(x)},其中Y(x)为x在R中的象集,x=t(r)[X] 上面的演算经过有限次复合后形成的式子称为关系代数表达式 关系演算分为元组关系演算和域关系演算 元组关系演算语言ALPHA元组关系演算以元组变量作为谓词变元的基本对象。典型的元组关系演算语言是E.F.Codd提出的ALPHA语言，但这一语言并没有实际实现。现在关系库管理系统INGRES所用的QUEL语言是参会照ALPHA语言研制的，与ALPHA十分相似 基本格式中:操作语句主要有GET、PUT、HOLD、UPDATE、DELETE和DROP六条语句 ALPHA语言语句的基本格式是: 操作语句 工作空间名(表达式):操作条件 工作空间是用户与系统的通信区，它可以用一个字母表示，通常用W表示；表达式用于指定语句的操作对象，它可以是关系名和属性名，一条语句可以同时操作多个关系或多个属性；操作条件是一个逻辑表达式，它用于将操作结果限定在满足条件的元组中，操作条件可以为空；呆以在基本格式的基础上加上排序要求，定额要求等。 一、 检索操作 (1) 简单检索(即不带条件的检索) 格式： GET 工作空间名 （表达式1） 查询所有被选修的课程号码。GET W (SC.Cno) (2) 限定的检索(即带条件的检索) 格式： GET 工作空间名（表达式1） ：操作条件 查询信息系(IS)中年龄小于20岁的学生的学号和年龄。 GET W (Student.Sno， Student.Sage):Student.Sdept=’IS’∧Student.Sage&lt;20 (3) 带排序的检索 格式： GET 工作空间名（表达式1） [：操作条件] DOWN/UP 表达式2查询计算机科学系(CS)学生的学号、 年龄， 结果按年龄降序排序。 GET W (Student.Sno， Student.Sage): Student.Sdept=‘CS’DOWN Student.Sage (4) 带定额的检索 格式 : GET 工作空间名（定额）（表达式1）[：操作条件] DOWN/UP 表达式2取出一个信息系学生的学号。 GET W (1) (Student.Sno): Student.Sdept=’IS’ (5) 用元组变量的检索 元组变量的含义表示可以在某一关系范围内变化（也称为范围变量Range Variable） 元组变量的用途简化关系名：设一个较短名字的元组变量来代替较长的关系名。操作条件中使用量词时必须用元组变量。 定义元组变量格式： RANGE 关系名 变量名 一个关系可以设多个元组变量 查询信息系学生的名字RANGE Student XGET W (X.Sname):X.Sdept=‘IS’ (6) 用存在量词的检索 查询选修2号课程的学生名字。 RANGE SC X GET W (Student.Sname): ΕX(X.Sno=Student.Sno∧X.Cno=’2’) 查询至少选修一门其先行课为6号课程的学生名字RANGE Course CX SC SCXGET W (Student.Sname):∃ SCX (SCX.Sno=Student.Sno∧∃ CX (CX.Cno=SCX.Cno∧CX.Pcno=’6’)) (7) 带有多个关系的表达式的检索 查询成绩为90分以上的学生名字与课程名字 RANGE SC SCXGET W (Student.Sname， Course.Cname): ∃SCX (SCX.Grade≥90∧SCX.Sno=Student.Sno∧Course.Cno=SCX.Cno) (8) 用全称量词的检索 查询不选1号课程的学生名字。 RANGE SC SCXGET W (Student.Sname): ∀SCX(SCX.Sno≠Student.Sno∨SCX.Cno≠’1’) (9) 用两种量词的检索 查询选修了全部课程的学生姓名。 RANGE Course CX SC SCXGET W (Student.Sname) : ∀ CX ∃ SCX (SCX.Sno=Student.Sno ∧ SCX.Cno = CX.Cno) (10) 用蕴函（Implication） 的检索 查询最少选修了95002学生所选的课程的学生的学号 思路：依次检查每一门课程，看95002是否选了这门课，如果选了，再看看有没有其他学生选了这么课，遍历完后。看看是否存在学生把95002选了的课都选了，如果存在即符合。 RANGE Course CX SC SCX SC SCYGET W(Student Sno):∀ CX ( ∃ SCX (SCX.Sno=’95002 ∧ SCX.Cno=CX.Cno) → ∃ SCY（SCY.Sno=Student.Sno ∧ SCY.Cno=CX.Cno)) (11) 聚集函数 查询学生所在系的数目。 GET W (COUNT(Student.Sdept))COUNT函数在计数时会自动排除重复值。 二、更新操作 （1）修改操作修改操作用UPDATE语句实现，步骤是： 用HOLD语句将要修改的元组从数据库中读到工作空间中 HOLD 工作空间名（表达式1） [：操作条件 ] 用宿主语言修改工作空间中元组的属性 用UPDATE语句将修改后的元组送回数据库中 把95007学生从计算机科学系转到信息系 HOLD W (Student.Sno， Student.Sdetp): Student.Sno=’95007 （从Student关系中读出95007学生的数据）MOVE ‘IS’ TO W.Sdept （用宿主语言进行修改）UPDATE W （把修改后的元组送回Student关系） （2）插入操作 用宿主语言在工作空间中建立新元组 用PUT语句把该元组存入指定关系中 PUT 工作空间名 （关系名） 学校新开设了一门2学分的课程‚计算机组织与结构‛ ， 其课程号为8， 直接先行课为6号课程。 插入该课程元组 MOVE ‘8’ TO W.CnoMOVE ‘计算机组织与结构’ TO W.CnameMOVE ‘6’ TO W.CpnoMOVE ‘2’ TO W.CcreditPUT W (Course) (把w中的元组插入到制定关系course中) put语句只对一个关系操作，表达式必须为单个关系名 （3）删除 用HOLD语句把要删除的元组从数据库中读到工作空间中 用DELETE语句删除该元组 DELETE 工作空间名 95110学生因故退学， 删除该学生元组。 HOLD W (Student):Student.Sno=’95110’DELETE W 域关系语言QBE域关系演算以元组变量的分量（即域变量）作为谓词变元的基本对象。最突出的特点是操作方式，它是一种高度非过程化的基于屏幕表格的查询语言，用户通过终端屏幕编辑程序，以填写表格的方式构造查询要求，而查询的结果也是以表格形式显示。 QEB中用示例元素来表示查询结构可能的情况，示例元素实际上就是域变量。以下就是QEB的操作框架： 本章小结关系数据库是目前使用最广泛的数据库系统。关系数据库与非关系数据库的区别：关系系统只有“表”这一种数据结构，而非关系数据库系统还有其他数据结构，以及对这些数据结构的操作。 关系数据库标准语言SQL SQL—结构化查询语言，是关系数据库的标准语言，SQL是一个通用的，功能极强的关系数据库语言。 SQL特点SQL语言之所以能够为用户和业界所接受，并成为国际标准，是因为它是一个综合的、功能极强同时又简捷易学的语言。SQL语言集数据查询、数据操纵、数据定义和数据控制功能于一体，主要特点包括： 综合统一SQL集合数据定义、数据操纵、数据控制于一体，语言风格统一。可以独立完成数据库生命周期中的全部活动 定义关系模式，插入数据，建立数据库 对数据库中的数据进行查询和更新 数据库重构和维护 数据库安全性、完整性控制 在关系模型中实体和实体间的联系均用关系表示，这种数据结构的单一性带来了数据操作符的统一性，查找、插入、删除、更新等每一种操作都只需要一种操作符 高度非过程化 面向集合的操作方式SQL采用集合操作方式，不仅操作对象、查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合。 以同一种语法结构提供多种使用方式SQL即使独立的语言，也是嵌入式语言。既可以在终端键盘直接输入SQL命令进行数据库操作，也可以嵌入到高级语言，如C、Java程序中提供给程序员使用。这种统一的语法提供多种不同的使用方式的做法，提供了极大的灵活性与方便性。 语言简洁，易学易用核心功能只有九个动词，如下图所示 SQL基本概念SQL语言支持关系数据库三级模式结构。其中外模式对应于视图和部分基本表，模式对应于基本表，内模式对应于存储文件。 SQL支持关系数据库三级模式结构，如下： 基本表：独立存储于数据库中的数据表（关系），可有若干个索引。 索引：对表中的属性组进行逻辑上排序，可以加快检索速度。 视图：由基表导出的虚表，数据库中只保存视图的定义。 存储文件：以OS文件的形式保存数据库的表、视图、索引等数据库对象。 学生-课程数据库学生-课程模式 S-T : 学生表：Student(Sno,Sname,Ssex,Sage,Sdept) 课程表：Course(Cno,Cname,Cpno,Ccredit) 学生选课表：SC(Sno,Cno,Grade) 数据定义SQL的数据定义功能包括了： 一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一｜ ｜ 操作方式 ｜一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一｜ 操作对象 ｜ 创建 ｜ 删除 ｜ 修改 ｜一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一｜ 模式 ｜CREATE SCHEMA ｜DROP SCHEMA ｜ ｘｘｘ ｜｜ 表 ｜CREATE TABLE ｜DROP TABLE ｜ALTER TABLE ｜｜ 视图 ｜CREATE VIEW ｜ DROP VIEW ｜ ｘｘｘ ｜｜ 索引 ｜CREATE INDEX ｜DROP INDEX ｜ ｘｘｘ ｜一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一一 SQL通常不提供修改模式定义、修改视图定义和修改索引定义的操作，如有要修改，只能先删除再重建。 模式的定义和删除一、定义模式“模式”是一个数据库的命名空间，一个框架，打个比方：在java中，创建模式相当于创建一个包，而创建表相当于创建一个类，一个类是在某一个包下面进行管理的。在mysql中，创建模式与创建数据库是一样的，也就是create schema &lt;模式名&gt;与 create database &lt;数据库名&gt;是等效的。所以模式的定义与删除语句如下： create schema &lt;模式名&gt; authorization &lt;用户名&gt; 例如创建一个学生-课程的模式S-T1create schema &quot;S-T&quot; authorization wang;//为用户wang创建一个模式S-T 删除模式语句如下： 1drop schema &lt;模式名&gt; &lt;cascade|restrict&gt; 其中cascade与restrict两者必选其一。 cascade(级联)，表示删除模式的同时，把该模式中的所有数据库对象（例如表等）也全部删除。 restrict（限制），表示如果该模式下已经定义了下属的数据库对象（如表、视图等），则拒绝执行该删除语句的执行还可以在创建模式的时候同时在这个模式定义中进一步创建基本表，视图，定义授权，即： 1create schema &lt;模式名&gt; authorization &lt;用户名&gt; [&lt;表定义子句&gt; | &lt;视图定义子句&gt; |&lt;授权定义子句&gt;] 例如：1234567CREATE SCHEMA TEST AUTHORIZATION ZHANG CREATE TABLE TAB1(COL1 SMALLINT, COL2 INT, COL3 CHAR(20), COL4 NUMERIC(10,3), COL5 DECIMAL(5,2)&#125; 该语句为用户ZHANG创建了一个模式TEST，并且定义了一个表TAB1 二、删除模式 1DROP SCHEMA &lt;模式名&gt; &lt; CASCADE | RESTRICT &gt; 其中CASCADE ：级联删除。即：删除模式的同时把模式中所有的数据库对象（模式中定义的下属数据库对象）全部删除 RESTRICT：限制删除。即：删除模式时，如果模式中已定义下属数据库对象，则拒绝删除。 这两个必须二选一 1DROP SCHEMA ZHANG CASCADE 该语句删除了模式ZHANG，同时定义的TAB1也被删除了 基本表的定义、删除与修改一、定义基本表 基本格式： 1234CREATE TABLE &lt;表名&gt;(&lt;列名&gt; &lt;数据类型&gt;[列级完整性约束条件] [,&lt;列名&gt; &lt;数据类型&gt;[列级完整性约束条件]] ....... [,&lt;表级完整性约束条件&gt; ])； 例子：执行完语句后，会在数据库中建立一个新的空的“学生”表Student，并将有关“学生”表的定义及有关约束条件存放到数据字典中 1234567CREATE TABLE Student ( sno CHAR(9) PRIMARY KEY, /* 列级完整性约束条件，Sno是主码*/ Sname CHAR(20) UNIQUE , /* Sname取唯一值*/ Ssex CHAR(2), Sage SMALINT, Sdept CHAR(20) ); 二、数据类型 关系模型中重要的概念是域，每一个属性来自一个域，它的取值必须是域中的值。在SQL中域的概念用数据类型来实现，不同的RDBMS在支持的数据类型不完全相同。一个属性选用哪种数据类型要根据实际情况来决定，一般考虑两个方面，一是取值范围，二是要什么什么运算。下面是MySQL 数据类型：：文本、数字和日期/时间类型。 Text 类型： 123456789101112131415161718192021222324CHAR(size):保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符.VARCHAR(size):保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。TINYTEXT:存放最大长度为 255 个字符的字符串。TEXT:存放最大长度为 65,535 个字符的字符串。 BLOB:用于 BLOBs (Binary Large OBjects)。存放最多 65,535 字节的数据。MEDIUMTEXT:存放最大长度为 16,777,215 个字符的字符串。MEDIUMBLOB:用于 BLOBs (Binary Large OBjects)。存放最多 16,777,215 字节的数据。LONGTEXT:存放最大长度为 4,294,967,295 个字符的字符串。LONGBLOB:用于 BLOBs (Binary Large OBjects)。存放最多4,294,967,295 字节的数据ENUM(x,y,z,etc.)：允许你输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照你输入的顺序存储的。可以按照此格式输入可能的值：ENUM(&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;)SET：与 ENUM 类似，SET 最多只能包含 64 个列表项，不过 SET 可存储一个以上的值。 | Number 类型： 123456789101112131415TINYINT(size)：-128 到 127 常规。0 到 255 无符号*。在括号中规定最大位数。SMALLINT(size)：-32768 到 32767 常规。0 到 65535 无符号*。在括号中规定最大位数。MEDIUMINT(size)：-8388608 到 8388607 普通。0 to 16777215 无符号*。在括号中规定最大位数。INT(size)：-2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数。BIGINT(size)：-9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。FLOAT(size,d)：带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。DOUBLE(size,d)：带有浮动小数点的大数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。DECIMAL(size,d)：作为字符串存储的 DOUBLE 类型，允许固定的小数点。 这些整数类型拥有额外的选项 UNSIGNED。通常，整数可以是负数或正数。如果添加 UNSIGNED 属性，那么范围将从 0 开始，而不是某个负数。 Date 类型： 12345678910111213DATE() : 日期。格式：YYYY-MM-DD注释：支持的范围是从 &apos;1000-01-01&apos; 到 &apos;9999-12-31&apos;DATETIME() : *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 &apos;1000-01-01 00:00:00&apos; 到 &apos;9999-12-31 23:59:59&apos;TIMESTAMP() : *时间戳。TIMESTAMP 值使用 Unix 纪元(&apos;1970-01-01 00:00:00&apos; UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 &apos;1970-01-01 00:00:01&apos; UTC 到 &apos;2038-01-09 03:14:07&apos; UTCTIME() : 时间。格式：HH:MM:SS 注释：支持的范围是从 &apos;-838:59:59&apos; 到 &apos;838:59:59&apos; YEAR() : 2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。 三、模式与表 每一个基本表都属于某一个模式，一个模式包含多个基本表定义表所属的模式，有三种方法 方法一：在表明中给出模式名CREATE table “S-T”.Student(…..); / Student所属的模式是S-T/CREATE table “S-T”.Course(……); / Course所属的模式是S-T/CREATE table “S-T”.SC(…….); / SC所属的模式是S-T / 方法二：在创建模式语句中同时创建表，在定义模式的例子里可以看到 方法三：设置所属的模式，这样创建表时不用给出模式名 当用户创建基本表的时候没指定模式，那么系统会搜索路径来确定所属模式，如果路径包含一组模式列表，则使用第一个存在的模式作为对象的模式名。如果路径中的模式名都不存在，系统就给出错误。 四、修改基本表 SQL语言用ALTER TABLE来修改基本表，一般格式为：1234ALTER TABLE &lt;表名&gt;[ADD &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]];[DROP &lt;完整性约束名&gt;];[ALTER COLUMN&lt;列名&gt; &lt;数据类型&gt;]; &lt;表名&gt;是要修改的基本表，ADD子句用于增加新列和新的完整性约束，DROP子句用于删除指定的完整性约束条件，ALTER COLUMN 子句用于修改原有的列定义，包括列名和数据类型 例子：向Student表中增加“入学时间”列，其数据类型为日期型 ALETER TABLE Student ADD_S_ENTRANCE DATE; 不论基本表是否原来有数据，新增加的一列均为日期型 五、删除基本表 当某个表不再需要时，用DROP TABLE语句删除它，格式为 DROP TABLE &lt;表名&gt; [ RESTRICT | CASCADE ]; 若选择RESTRICT，则该表的删除是有限制条件,不能被其他表的约束所引用，也不能有视图，触发器，存储过程或函数等 若选择CASCADE，则没有限制条件，删除基本表的时候，相关的依赖对象也会一起删除，例如视图等 缺省的情况的是RESTRICT。 例子：删除Student表 1DROP TABLE Student CASCADE； 基本表定义一旦被删除，不仅表中数据和定义被删除，而且表上建立的索引、视图、触发器等有关对象也一般会被删除。所以执行该操作需要特别小心 索引的建立与删除建立索引是加快查询速度的有效手段，根据需要，在基本表上建议一个或者多个的索引，以提供多种存取路径，加快查找速度。但是索引也有不适宜的情况，原因是建立索引后，更新索引上的数据时会导致表中记录的物理顺序的变更，代价较大，且会占用一定的系统资源，因此对于经常更新的列不宜建立索引。 建议建立索引的情况： 主码和外码一般会建立索引 以读为主或只读的表，只要空间允许可以建立多个索引 等值查询，且满足条件的元组数小于总元组数的5%，可以考虑在相关属性上建立索引 范围查询 不建议建立索引的情况： 不出现或很少出现查询的属性 属性值很少的属性 属性值分布严重不均的属性 经常更新的属性或表 过长的属性 太小的表 一般建立与删除索引是有数据库管理员或者表的属主（owner），即建立表的人完成。系统存取数据时自动选择合适的索引作为存取路径，用户不必也不能显式的选择索引 。 一、建立索引 建立索引的一般格式为： 12create [unique][cluster]index&lt;索引名&gt;on &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]...); 其中，表名是要建立索引的基本表的名字。索引可以建立在一列或多列上，每个&lt;列名&gt;后面还可以用&lt;次序&gt;指定索引值的排列次序，可选ASC（升序）或DESC（降序），缺省值为ASC。unique表示此索引的每一个索引值只对应唯一的数据记录。cluster表示要建立的索引是聚簇索引。所谓聚簇索引是指索引项的数据与表中记录的物理顺序一致的索引组织。 例：在Student表上的姓名列建立一个聚簇索引。 12create cluster index Stusnameon Student(Sname); 例：在sc表的Sno(升序), Cno(升序)和grade (降序)三列上建立一个普通索引SCno。 12create index SCnoon table SC(Sno,Cno,Grade DESC); 二、删除索引 索引一旦建立，就由系统使用和维护它，不需要用户干预。建立索引是为了减少查询操作的时间。但如果数据增删改查频繁，就会浪费很多时间来维护索引，从而降低了查询效率，可以通过删除一些不必要的索引。 删除索引的一般格式为： 1drop index&lt;索引名&gt;; 例：删除Student表上的Stusname索引。 1drop index Stusname; 删除索引时，系统会同时从数据字典中删去有关该索引的描述。 在RDBMS中索引一般采用B+树，HASH索引来实现，B+树索引具有动态平衡的优点。HSAH索引具有查找速度快的特点。索引是关系数据库的内部实现技术，属于内模式的范畴。 用户使用CREATE INDEX 语句定义索引的时候，可以定义索引是唯一索引、非唯一索引或者聚簇索引。至于某一个索引是采用B+树还是HASH索引则由具体的RDBMS来决定。 数据查询数据库查询是数据库的核心操作 一般格式为： 12345SELECT [ALL | DISTINCT] &lt;目标列表达式&gt; [，&lt;目标列表达式&gt;] ...FROM &lt;表名或者视图名&gt; [，&lt;表名或者视图名&gt;] ....[WHERE &lt;条件表达式&gt;] [GROUP BY &lt;列名1&gt;[HAVING &lt;条件表达式&gt;] ][ORDER BY &lt;列名2&gt; [ ASC | DESC ] ]； 根据where子句的条件表达式，从from子句指定基本表或者视图找出满足条件的元组，再按select子句中的目标列表达式，选出元组的属性值形成结果表 如果有group by子句，则将结果按&lt;列名1&gt;的值进行分组，该属性列值相等的元组为一个组。通常用在每组中作用聚集函数。如果group by子句滴啊有having短语，则只有满足指定条件的组才予以输出。 如果有order by子句，则结果表还要按照&lt;列名2&gt;的值升序或者降序排序。 单表查询单表查询是指仅涉及一个表的查询 一、选择表中的若干列 选择表中的全部列或者部分列，就是关系代数的投影运算 查询制定列在很多情况下，用户只需要一部分属性列，通过在select子句&lt;目标列表达式&gt;中指定要查询的属性列。例子1 查询全体学生的学号和姓名。 12SELECT Sno ,SnameFROM Student; 该语句的执行过程：从Student表中取出一个元组，在该元组属性Sno和Sname上取值，形成一个新的元组走位输出。对表中所有元组做相同的处理，最后形成一个结果关系作为输出。 例子2 12SELECT Sname ,Sno ,SdeptFROM Student; &lt;目标列表达式&gt;中各个列的先后顺序可以与表中的顺序不一致，根据需要改变列的显示顺序。 查询全部列将表中所有属性列出来，两种方法第一种是在关键字后面把所有列都列出来第二种就是指定为 * 这个符号。例子：查询全体学生详细记录。 12SELECT *FROM Student 等价于 12 SELECT Sno ,Sname,Ssex ,Sage, SdeptFROM Studetn; 查询经过计算的量SELECT 子句的&lt;目标列表达式&gt;不仅可以是表中的属性列，也可以是表达式 例子：查询全体学生的姓名及其出生年份 12SELECT Sname ,2004- Sage /*查询结果的第二列是一个算术表达式*/FROM Student; 例子 查询全体学生的姓名、出生年份和所在院系，要求用小写字母表示所有系名 12SELECT Sname ,'Year of Birth:' 2004-Sage ,LOWER (Sdept)FROM Student; 结果为 Sname ‘Year of Birth:’ 2004-Sage LOWER (Sdept) ———————————————————————————————————— 刘勇 ‘Year of Birth:’ 1984 cs 刘晨 ‘Year of Birth:’ 1985 cs 王敏 ‘Year of Birth:’ 1986 ma 张立 ‘Year of Birth:’ 1985 is ———————————————————————————————————— 还可以通过指定别名来改变查询结果的列标题 修改如下 12SELECT Sname ,'Year of Birth:' BIRTH ,2004-Sage BIRTHDAY,LOWER (Sdept) DEPARTMENTFROM Student; 结果为 Sname BIRTH BIRTHDAY DEPATMENT ———————————————————————————————————— 刘勇 ‘Year of Birth:’ 1984 cs 刘晨 ‘Year of Birth:’ 1985 cs 王敏 ‘Year of Birth:’ 1986 ma 张立 ‘Year of Birth:’ 1985 is ———————————————————————————————————— 二、选择表中的若干元组 消除取值重复的行两个本来并不完全相同的元组，投影到制定的某些列上后，就可能变成了相同的行了，可以用DISTINCT取消他们。 例子 查询选修了课程的学生学号 12SELECT SnoFROM SC; 输出结果为： Sno——————200215121200215121200215121200215122200215122 如果为了去掉重复的行，必须制定DISTINCT关键词 12SELECT DISTINCT SnoFROM SC 输出结果为 Sno——————200215121200215122 如果没有指定DISTINCT关键词，那么缺省为ALL，则保留结果中重复的行 查询满足条件的元组查询满足指定条件的元组可以通过where子句实现， 常用的查询条件——————————————————————————————————————查询条件 谓词 ——————————————————————————————————————比较 =，&gt;，&lt;,&lt;=,&gt;=,!=,&lt;&gt;,!&gt;,!&lt;;NOT + 上述比较运算符确定范围 BETWEEN AND,NOT BETWWEN AND确定集合 IN, NOT IN字符匹配 LIKE , NOT LIKE空值 IS NULL , IS NOT NULL多重条件（逻辑运算） AND, OR , NOT—————————————————————————————————————— （1）比较大小用于进行比较的运算符一般包括=（等于），&gt;（大于），&lt;（小于）, &lt;=（小于等于）, &gt;=（大于等于）,!=（不等于）或 &lt;&gt;（不等于）, !&gt;（不大于）, !&lt;（不小于）; （2）确定范围谓词BETWEEN…AND….相对谓词是NOT BETWEEN …ADN…. 例子 查询年龄不在20~23之间的学生姓名、系别和年龄 123SELECT Sname ,Sdept,SageFROM StudentWHERE Sage NOT BETWEEN 20 AND 23; （3）确定集合谓词IN可以用来查找属性值属于指定集合的元组 例子 查询计算机科学系（CS）、数学系（MA）和信息系（IS）学生的姓名和性别123SELECT Sname ,SsexFROM StudentWHERE Sdept IN('CS' , 'MA' , 'IS'); （4）字符匹配谓词LIKE可以用来进行字符串的匹配，一般格式为：[NOT] LIKE ‘&lt;匹配符&gt;’ [ESCAPE’ &lt;换码字符&gt;’]其含义是查找指定的属性列值与&lt;匹配串&gt;相匹配的元组。&lt;匹配串&gt;可以是一个完整的字符串，也可以是含有通配符%和 _ 其中： % (百分号)代表任意长度的字符串,例如a%b表示以a开头，以b结尾的任意长度的字符串，如acb、addgb、ab等都满足该匹配 _ (下横线)代表任意单个字符，例如 a_b表示以a开头，以b结尾的的长度为3的任意字符串，如acb、adb、asb等都满足。注意的是一个汉字占用两个字符。所以匹配汉字的时候需要两个下横线。 例子 ： 查询学号为200212121的学生的详细情况 1234567891011SELECT *FROM StudentWHERE Soo LIKE '200215121'``` 等价于```sqlSELECT *FROM StudentWHERE Sno ='200215121' 如果like后面的匹配串不含通配符，则可以用 =（等于）运算符取代like谓词，用！=或&lt;&gt; 运算符取代NOT LIKE 如果用户查询的字符串本身就含有通配符 % 或 _ ,这时候就要用escape ‘&lt;换码字符&gt;’短语，对通配符进行转义了。 例子 123SELECT Cno,CereditFROM CourseWHERE Cname LIKE 'DB\_Design' ESCAPE '\' ; 这里就是escape ‘\’表示把’\’表示为转码字符，这样匹配串中紧跟在 ‘\’ 后面的字符 ‘‘ 不在具有通配符的含义转义为普通的 ‘‘ 字符 （5）涉及空值的查询例：某些学生选修课程后没有参加考试，所以有选课记录没有考试成绩，查询缺少成绩的学生的学号和相应的课程号 123SELECT Sno , CnoFROM SCWHERE Grade IS NULLL /* 分数是grade是空值*/ 这里的IS不能用 = 来代替 （6）多重条件查询逻辑运算符AND 和OR可用联结多个查询条件，AND 的优先级高于OR，但用户可以用括号来改变优先级 例 查询计算机科学系年龄在20岁以下的学生姓名 123SELECT SnameFROM StudentWHERE Sdept = 'CS' AND Sage &lt;20; 三、 ORDER BY子句 用户可以用ORDER BY子句对查询结果按照一个或者多个属性的升序（ASC）或降序（DESC）排列，缺省值为升序 例 查询小选修了3号课程的学生的学号和成绩，查询结果按分数的降序排列 1234SELECT Sno,GradeFROM SC WHERE Cno='3'RODER BY Grade DESC; 对于空值，若按升序排，含空值的元组将最后显示，若按降序排，空值的元组将最先显示。 四、 聚集函数 （aggregate functions） 为了增强检索功能，sql提供许多聚集函数 1 count : 行数 2 sum : 总和 （求总和） 3 avg : 平均值 4 max 最大值 5 min : 最小值 例： 查询选修了课程的学生人数 12SELECT COUNT (DISTINCT Sno)FROM SC; 学生每选修一门课，在sc中都有一条相应的记录，一个学生要选修多门课程，为避免重复计算学生人数，必须在count函数中用distinct短语 例：计算1号课程的学生平均成绩 123SELECT AVG (Grade)FROM SCWHERE Cno= '1'; 例： 查询学生200215012选修课程的总分数 123SELECT SUM(Ceredit)FROM SC ,CourseWHERE Sno= '200215012' AND SC.Cno=Course.Cno 在聚集函数遇到空值时，除COUNT(*)外，都跳过空值而处理非空值 五、GROUP BY子句 GROUP BY 子句将查询结果按某一列或多列的值分组，值相等的为一组对查询结果分组的目的是为了细化聚集函数的作用对象，如果未对查询结果分组，聚集函数将作用于整个查询结果。 例子 查询各个课程号及其相应的选课人数 123SELECT Cno ,COUNT (Sno)FROM SCGROUP BY Cno; 该语句是对查询结果按Cno的值分组，所有具有相同Cno值的元组为一组，对每一组进行聚集函数count计算，以求得该组的学生人数 查询结果可能为 Cno COUNT(Sno)———————————————————————————— 1 22 2 34 3 44 4 33 5 48———————————————————————————— 如果分组后还要按照一定的条件去进行筛选，最终只输出满足指定条件的组，则可以使用HAVING 短语指定筛选条件 查询选修了3门以上的课程的学生学号 1234SELECT SnoFROM SCGROUP BY SnoHAVING COUNT (*) &gt;3; 先用group by按Sno进行分组，再用聚集函数COUNT对每一组计算。HAVING短语给出了选择组的条件，且只有满足条件（即元组个数&gt;3），表示此学生选修的课超过3门的才会选出来 WHERE子句与HAVING子句区别在于作用对用不同，WHRE子句作用于基本表或视图，从中选择满足条件的与阿奴，HAVING短语作用于组，从中选择满足条件的组。 连接查询若查询同时设计到两个以上的表，则称之为连接查询 连接查询是关系数据库中最主要的查询，包括了等值连接查询，自然连接查询，非等值连接查询，自身连接查询，外连接查询和符合条件连接查询等 一、 等值与非等值连接查询 连接查询的WHERE子句用来连接两个表的条件称为 连接条件 或 连接谓词，起一般格式为： [&lt;表名1&gt;] &lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;]&lt;列名2&gt; 其中比较运算符主要有： =、&gt;、&lt; 、 &gt;= 、&lt;=、 != (或&lt;&gt;) 还可以用以下格式：[&lt;表名1&gt;] &lt;列名1&gt; BETWEEN [&lt;表名2&gt;]&lt;列名2&gt; AND [&lt;表名2&gt;]&lt;列名3&gt; 当连接运算符为 = 时，称为等值连接，使用其他运算符时为非等值连接 连接谓词中的列名称为连接字段，连接条件中的各连接字段类型必须是可比的，但名字不必相同。 例子 查询每个学生及其选修课程的情况 学生情况存放在Student表中，学生选课情况存在SChema表中，所以本查询实际上涉及Student和SC两个表， 这两个表之间的联系是通过公共属性Sno实现的。 123SELECT Student * , SC . * FROM Student ,SCWHERE Student.Sno =SC.Sno; /* 将Student和SC中同一个学生的元组连接起来*/ 假设 Student表和SC表的数据如上面 学生-课程数据库的表一样 那么执行结果如下： Student.Sno Sname Ssex Sage Sdept SC.Sno Cno Grade————————————————————————————————————200215121 李勇 男 20 CS 200215121 1 92200215121 李勇 男 20 CS 200215121 2 85200215121 李勇 男 20 CS 200215121 3 88200215122 刘晨 女 19 CS 200215122 2 90200215122 刘晨 女 19 CS 200215122 3 80———————————————————————————————————— 在本例中中，select子句与where子句中的属性名前都加上了表名前缀，为了避免混淆，如果属性名在参加连接的各表中是唯一的，则可以省略表名前缀。 RDBMS执行该连接操作的一种可能过程是：首先在表Student中找第一个元组，就开始扫描SC表，查找与Student第一个元组的Sno相等的SC元组，找到后将Student中第一个元组与该元组拼接起来，形成结果表中的一个元组，SC中全部查找完后，再找Student中第二个元组，不断的重复上述操作。这是嵌套循环算法的基本思想。 如果在SC表Sno上建立索引的话，就不用每次全表扫描SC表了，二十根据Sno值通过索引找到相应的SC元组，用索引查询SC中满足条件的元组一般比全表扫描快。 若在等值连接中把目标列中重复的属性列去掉则为自然连接。 对上例子用自然连接完成。 123SELECT Student Sno,Sname,Ssex,Sage,Sdept,Cno,GradeFROM Student ,SCWHERE Student , Sno = SC.Sno; 二、自身连接 连接操作不仅可以在两个表之间进行，也可以是一个表与其自己进行连接，称为表的自身连接需要给表 例 查询每一门课的间接先修课（即先修课的先修课） 在Course表中，只有每门课的直接先修课信息，而没有先修课的先修课。要得到这个信息，必须对一门课找到其先修课，再按此先修课的课程号，查找它的先修课程。这就要将Course表与其自身连接。 为此，要为Course表取两个别名，一个是FIRST，另一个是SECOND FIRST表（Course表）——————————————————————————————————————Cno Cname Cpno Ccredit 1 数据库 5 4 2 数学 2 3 信息系统 1 4 4 操作系统 6 3 5 数据结构 7 4 6 数据处理 2 ７ PASCAL 6 4—————————————————————————————————————— SECOND表 （Course表）——————————————————————————————————————Cno Cname Cpno Ccredit 1 数据库 5 4 2 数学 2 3 信息系统 1 4 4 操作系统 6 3 5 数据结构 7 4 6 数据处理 2 ７ PASCAL 6 4—————————————————————————————————————— 完成该查询的SQL语句为 123SELECT FIRST Cno ,second.CpnoFROM Course FIRST , Course SECONDWHERE FIRST Cpno =SECOND.Cno 结果为 Cno Pcno————————————1 73 55 6 三、外连接 一般来说，只有满足连接条件的元组才会作为结果输出，例如上面的输出结果没有200215123和200215125两个学生的信息，是因为没有选课，在SC中没有相应的元组，在Student这些元组在连接时就被舍弃了。 如果还想以Student表为主体列出每个学生的基本情况及其选课情况，其中某个学生没有选课，仍把舍弃的Student元组保存在结果关系中，而在SC表的属性上填空值（null），这时候就需要外连接。 1234SELECT Student ,Sno, Sname,Ssx,Sage,Sdept,Cno,GradeFROM Student LEFT OUT JOIN SC ON(Student.Sno = SC.Sno)/*也可以使用USING来去掉结果中的重复值； FROM Student LEFT OUT JOIN SC USING （Sno）； */ 执行结果如下 Student.Sno Sname Ssex Sage Sdept SC.Sno Cno Grade————————————————————————————————————————200215121 李勇 男 20 CS 200215121 1 92200215121 李勇 男 20 CS 200215121 2 85200215121 李勇 男 20 CS 200215121 3 88200215122 刘晨 女 19 CS 200215122 2 90200215122 刘晨 女 19 CS 200215122 3 80200215123 王敏 女 18 MA 200215122 NULL NULL200215125 张立 男 19 IS 200215122 NULL NULL———————————————————————————————————————— 左外连接列出左边关系（如本利Student）中所有的元组，右外连接列出关系中所有的元组。 四、复合条件连接 在上面各个连接查询中，where子句中只有一个条件，即连接谓词，where子句中可以有多个连接条件，称为复合条件连接 例 查询选修２号课程且成绩在90分以上的所有学生 1234SELECT Student.Sno,SnameFROM Student.SCWHERE Student.Sno= SC.Sno AND /* 连接谓词 */ SC.Cno='2' AND SC.Grade&gt;90; /* 其他限定条件 */ 该查询的一种优化（高效）的执行过程是先从SC中挑选出Cno=’2’ 并且 Grade&gt;90的元组形成一个中间关系，再和Student中满足连接条件的元组进行连接得到最终的结果关系。 连接操作除了可以是两表连接，一个表与自身连接外，还可以是两个以上的表进行连接，后者通常称为多表连接。 查询每个学生的学号、姓名、选修的课程号及成绩本查询涉及三个表，查询语句如下： 123SELECT Student,Sno , Sname ,Cname ,GradeFROM Student , SC , CourseWHERE Student.Sno = SC.Sno AND SC.Cno =Course.Cno; 嵌套查询在SQL语言中， 一个SELECT-FROM -WHERE语句称为一个查询块，将一个查询块嵌套在另一个查询块的where子句或having短语条件中的查询称为嵌套查询。例如： 123456SELECT Sname /*外层查询或者父查询*/ FROM StudentWHERE Sno IN (SELECT Sno /* 内层查询或者子查询 */ FROM SC WHERE Cno='2'); SQL语言支持多层嵌套查询，即一个子查询里还可以嵌套其他子查询。但是注意：子查询的select语句中不能使用order by子句，order by子句只能对最终查询结果排序。 以层层嵌套的方式来构造程序正是SQL中“结构化”的含义所在。 一、带有IN谓词的子查询在嵌套查询中，子查询的结果往往是一个集合，所以谓词IN是嵌套查询中最经常使用的谓词。 例：查询与“刘晨”在同一个系的学生。 先分步完成此查询，然后再构造嵌套查询。①确定“刘晨”所在系名 123SELECT SdeptFROM StudentWHERE Sname= '刘晨'； 结果为：CS ②查找所有在CS系学习的学生 123SELECT Sno ,Sname ,SdeptFROM StudentWHERE Sdept ='CS'; 结果为： Student.Sno Sname Sdep——————————————————200215121 李勇 CS200215122 刘晨 CS—————————————————— 将第一步查到嵌入到第二步查询的条件中，构造嵌套查询如下： 123456SELECT Sno , Sname ,SdeptFROM StudentWHERE Sdept IN (SELECT Sdept FROM Student WHERE Sname='刘晨'); 这个例子不依赖父查询，所以称为不相关子查询 二、带有比较运算符的子查询 带有比较运算符的子查询是指父查询与子查询之间用比较运算符进行连接，当用户能确切知道内层查询返回的单值时，可以用 &gt; , &lt; , = , &gt;= ,&lt;= ,!= 或&lt;&gt;等比较运算符。 比如刚刚上面的例子查询与“刘晨”在同一个系的学生。由于一个学生只能在一个系学习，也就是说内查询的结果是一个值，因此可以用‘=’来代替IN 123456SELECT Sno , Sname ,SdeptFROM StudentWHERE Sdept = (SELECT Sdept FROM Student WHERE Sname='刘晨'); 注意的是子查询一定要跟在比较符之后，下面是错误语法 12345SELECT Sno , Sname ,SdeptFROM StudentWHERE (SELECT Sdept FROM Student WHERE Sname='刘晨')=Sdept; 如果子查询条件依赖于父查询，这类子查询称为相关子查询，整个查询语句称为相关嵌套查询语句。 下面是相关嵌套查询 例： 找出每个学生超过他选修课平均成绩的课程号 12345SELECT Sno ,CnoFROM SC xWHERE Grade &gt;= (SELECT AVG(Grade) /* 某学生的平均成绩 */ FROM SC y WHERE y.Sno =x.Sno); 其中x是表SC的表名，又称为元组变量，可以用来表示SC的一个元组，内层查询是求一个学生所有选修课程平均成绩的，至于是哪个学生的平均成绩要看参数x.Sno的值，而该值是与父查询相关的，因此这类查询称为相关子查询。 该语句的一种可能的执行过程是： 从外层查询中取出SC的一个元组x,将元组x的Sno值（200215121）传送给内层查询 123SELECT AVG(Grade)FROM SC yWHERE y.Sno='200215121'; 执行内层查询，得到值88（近似值），用该值替代内层查询，得到外层查询 123SELECT Sno,CnoFROM SC xWHERE Grade ='200215121' 执行这个查询，得到（200215121，1）（200215121，3）然后外层查询取出下一个元组重复做上述的操作，知道全部处理完毕。结果为（200215121，1）（200215121，3）（200215122，2） 三、带有ANY（SOME）或ALL谓词的子查询 子查询返回单值时可以用比较运算符，但返回多值时要用ANY（有的系统用SOME）或者ALL谓词修饰符，而使用ANY或ALL谓词时必须同时使用比较运算符，其语义为 1234567891011121314151617181920212223&gt; ANY 大于子查询结果中的某个值&gt; ALL 大于子查询结果中的所有值&lt; ANY 小于子查询结果中的某个值&lt; ALL 小于子查询结果中的所有值&gt;= ANY 大于等于子查询结果中的某个值&gt;= ALL 大于等于子查询结果中的所有值&lt;= ANY 小于等于子查询结果中的某个值&lt;= ALL 小于等于子查询结果中的所有值= ANY 等于子查询结果中的某个值= ALL 等于子查询结果中的所有值（通常没有实际意义）!=(或&lt;&gt;) ANY 不等于子查询结果中的某个值!=(或&lt;&gt;) ALL 不等于子查询结果中的任何一个值 例 ： 查询其他系中比计算机科学系某一学生年龄小的学生姓名和年龄 123456SELECT Sname,Sage FROM Student WHERE Sage &lt; ANY ( SELECT Sage FROM Student WHERE Sdept='CS' ) AND Sdept &lt;&gt; 'CS'; /* 这是父查询块中的条件 */ 结果如下：Sname Sage—————————— 王敏 18 张立 19 RDBMS 执行此查询时，首先处理子查询，找出CS系中所有学生的年龄，构成一个（20，19）集合，然后处理父查询，找所有不是CS系且年龄小于该集合中年龄的学生。 这个例子也可以用聚集函数实现，SQL如下 1234567SELECT Sname ,SageFROM StudentWHERE Sage &lt; (SELECT MIN (Sage) FROM Student WHERE Sdept='CS')AND Sdept &lt;&gt; 'CS'; 事实上，用聚集函数实现子查询通常比直接用ANY或ALL查询效率高。ANY，ALL与聚集函数的对应关系如表 四、带有EXISTS谓词的子查询EXISTS代表存在量词 ，带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值‘true’或逻辑假值‘FALSE’ 可以利用EXISTS来判断 x∈S ，S⊆R， S=R ，S∩R 非空等是否成立 例 查询所有选修了 1 号课程的学生姓名该查询设计了Student表和SC表，可以在Student中依次取每个元组的Sno值，用此值去检查SC表，若SC中存在这一的元组，其Sno值等与此Student.Sno值，并且其Cno=‘1’，则取此Student.Sname送入结果表 123456SELECT SnameFROM StudentWHERE EXISTS (SELECT * FROM SC WHERE Sno = Student.Sno AND Cno='1'); 使用存在量词EXISTS后，若内层查询结果非空，则外层的where子句返回真值，否则返回假值 由EXISTS引出的子查询，起目标列表达式通常用 * 号，因为带EXISTS的子查询只返回真价值，给出列名无实际意义。 本例中的查询条件是依赖于外层父查询的某个属性值（这里是STudent的Sno值）因此也是相关子查询，这个相关子查询的处理过程是：首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值（Sno值）处理内层查询，若where子句返回值为真，则取外层查询中该元组的Sname放入结果表，然后再取（Student）表的下一个元组，重复这一过程，直至外层（Student表）全部检查完为止。 例 ： 查询至少选修了学生200215122选修的全部课程的学生号码本查询可以用逻辑蕴含来表达：查询学号为x的学生，对所有的课程y，只要200215122学生选修了课程y,则x也选修了y，形式化表示如下：用p表示谓词”学生200215122选修了课程“用q表示谓词“学生x选修了课程y”则上述查询为： （ ∀y ）p→q 但是SQL语言没有蕴含逻辑运算，但是可以利用谓词演算将一个逻辑蕴含的谓词等价转换为 p → q ≡ ¬ p ∨ q 该查询可以转换为如下等价形式：（ ∀y ）p→q ≡ ¬（∃y（ ¬（p→q））≡¬（∃y（¬（¬p∨ q）≡ ¬ ∃y（p ∧ ¬q）））） sql语言表达： 1234567891011SELECT DISTINCT SnoFROM SC SCXWHERE NOT EXISTS (SELECT * FROM SC SCY WHERE SCY.Sno =' 200215122 ' AND NOT EXISTS (SELECT * FROM SC SCZ WHERE SCZ.Sno=SCX.Sno AND SCZ.Cno= SCY.Cno)); 集合查询SELECT语句的查询结果是元组的集合，所以多个SELECT语句的结果可进行集合操作。集合操作的主要 并操作UNION、交操作INTERSECT和 差操作EXCEPT。注意，参加集合操作的各查询结果的列数必须相同，对应项的数据类型也必须相同 例 查询计算机科学系的学生及年龄不大于19岁的学生 1234567SELECT *FROM StudentWHERE Sdept ='CS'UNIONSELECT *FROM StudentWHERE Sage &lt;= 19; 使用UNION将多个查询结果合并起来时，系统会自动去掉重复元组，如果要保留重复元组则用UNION ALL操作符 例 查询选修课程 1 的学生 或 选修课程2 的学生 1234567SELECT *FROM StudentWHERE Cno ='1'UNIONSELECT *FROM StudentWHERE Cno ='2' 例 查询计算机科学系的学生与年龄不大于19岁的学生的交集 1234567SELECT *FROM StudentWHERE Sdept ='CS'INTERSECTSELECT *FROM StudentWHERE Sage &lt;= 19; SELECT 语句的一般格式 12345SELECT [ ALLDISTINCT ] &lt; 目标列表达式 &gt; [别名] [,&lt;目标列表达式&gt; [别名]] .......FROM &lt;表名或视图名&gt; [ 别名 ] [,&lt; 表名或视图名 &gt; [别名]] ......[WHERE &lt; 条件表达式&gt;]&#123;GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt;]][ORDER BY &lt;列名2&gt; [ASCIDESC]]; 目标列表达式有以下可选格式：（1） （2） &lt;表名&gt;.（3） COUNT ([DISTINCT | ALL])（4）[&lt;表名&gt;.] &lt;属性列名表达式&gt;[.[&lt;表名&gt;.]&lt;属性列名表达式&gt;]….. 其中&lt;属性列表达式&gt;可以是由属性列，作用于属性列的聚集函数和常量的任意算术运算（+、-、、/）组成的运算公式 聚集函数一般格式为： COUNT ↘ SUM ↘ AVG →→ ([DISTINCT|ALL]&lt;列名&gt;) MAX ↗ MIN ↗ WHERE子句的条件表达式有以下可选格式 （1）123 &lt;属性列名&gt;&lt;属性列名&gt; θ &lt; 常量 &gt; [ANY | ALL]（SELECT 语句） （2）123 &lt;属性列名&gt; &lt;属性列名&gt;&lt;属性列名&gt; [NOT] BETWEEN &lt;常量&gt; AND &lt;常量&gt; (SELECT语句） &lt;SELECT语句&gt; （3） 123 ↗(&lt;值1&gt; [,&lt;值2&gt;]....) &lt;属性列名&gt; [NOT] IN ↘ (SELECT 语句) （4）&lt;属性列名&gt; [NOT] LIKE &lt;匹配串&gt; （5）&lt;属性列名&gt; IS [NOT] NULL （6）[NOT] EXISTS (SELECT语句) （7）123 AND AND&lt;条件表达式&gt; [ &lt;条件表达式&gt; &lt;条件表达式&gt;]..... OR OR 数据更新三种操作：添加，修改，删除 插入数据SQL插入语句INSERT通常两种形式：插入一个元组，插入子查询结果，其中后者可以一次插入多个元组。 一、 插入元组 格式为： 123INSERTINTO &lt;表名&gt; [ (&lt;属性列1&gt;[,&lt;属性列2&gt;]...)]VALUES (&lt; 常量1 &gt; [,&lt; 常量2 &gt;]....); 功能是将新元组插入指定表中，INTO子句中没有出现的属性列，新元组将取空值，但是表定义的时候，说明了NOT NULL的属性列不能取空值，否则会出错。如果INTO子句中没有指明任何属性列名，则新插入的元组必须每个属性列上均有值 例 将一个新学生元组（学号：200215128；姓名：陈冬；性别：男；所在系：IS；年龄：18岁）插入到Student表中。 123insert into student(sno,sname,ssex,sdept,sage)values( '200215128' , '陈冬','男' , 'is' , 18 ); 属性的顺序可以与CREATE TABLE 中的顺序不一样，VALUES子句对新元组的各属性赋值，字符串常数要用单引号括起来。 例 将学生张成民的信息插入到Student表中信息：‘200215126’ ‘张成民’ ‘男’ 18 ‘CS’ 123insert into studentvalues( '200115126' , '张成民' , '男' , 'cs' , 18 ); 这个与上个例子不同的是没有指明属性名，所以新元组要在所有的属性列上都指定值，并且属性列顺序与CRAETE TABLE上的次序要相同。VALUES子句对新元组的各属性列赋值，一定要注意值与属性列要一一对应，赋值错会造成数据类型不同而出错。 例 插入一条选课记录( ‘200215128’，’1 ‘) 123insert into SC（Sno,Cno）values('200215128','1'); RDBMS自动在新插入的记录Grade上赋空值 或者123insert into scvalues('200215128','1',NULL); 没有指定出SC的属性名，在Grade列上要明确给出空值 二、 插入子查询结果子查询不仅可以嵌套在SELECT语句中，用以构造父查询的条件，也可以 嵌套在INSERT语句中，用以生成要插入的批量数据 插入子查询结果的INSERT语句的格式为 123INSERT INTO &lt;表名&gt; [(&lt;属性列1&gt; [,&lt;属性列2&gt;]....) ]子查询; 例 对每一个系，求学生的平均年龄，并把结果存入数据库。 首先在数据库中建立一个新表，其中一列存放系名，另一列存放相应的学生平均年龄。123create table dept_age (sdept char(15) avg_age smllint); 然后对Student表按系分组求平均年龄，再把系名和平均年龄存入新表中 12345insertinto dept_age(sdept,avg_age)select sdept,avg(sage)from studentgroup by sdept; 修改数据又称为更新操作 ，一般格式为 123UPDATE &lt;表名&gt;SET &lt;列名&gt; = &lt;表达式&gt; [,&lt;列名&gt; = &lt;表达式&gt; ]....[WHERE &lt;&gt;]; 其功能是修改指定表中满足 WHERE子句条件的元组，其中set子句给出&lt;表达式&gt;的值用子取代相应的属性列值，如果省略where子句，则表示要修改表中的所有元组。 一、 修改某一个元组的值 例 将学生200215121的年龄改为22岁 123update studentset sage=22where sno='200212121'; 二、修改多个元组的值 例 将所有的学生年轻增加1岁 12update studentset sage= Sage+1； 三、带子查询的修改语句 子查询也嵌套在UPDATE语句中，用以构造修改的条件。例 将计算机科学系全体学生的成绩置零 123456update scset grade=0where 'cs'= (select sdept from student where student.sno=sc.sno); 删除数据格式为： 123DELETE FROM &lt;表名&gt;[WHERE &lt;条件&gt;]; DELETE语句功能从指定表中删除满足where子句的所有元组，如果没有指定，那么就删除所有元组，但表的定义仍在字典中，delete语句删除的是表中的数据，而不是关于表的定义。 一、删除某一个元组的值 例 删除学号为200215128的学生记录 123DELETE FROM StudentWHERE Sno = '200215128' 二、删除多个元组的值 12DELETE FROM SC 这条delete语句使SC表变为空表，删除了SC所有元组 三、带子查询的删除语句子查询同样也可以嵌套在delete语句中，用以构造执行删除操作的条件。例：删除计算机科学系所有学生的选课记录。 123456delete from scwhere 'cs'= (select sdept from student where student.sno=sc.sno); 视图视图是从一个或几个基本表(或视图)导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。视图一经定义，就可以和基本表一样被查询、被删除。也可以在一个视图之上再定义新的视图，但对视图的更新（增、删、改）操作则有一定得限制。 定义视图一、建立视图 一般格式： 123CREATE VIEW &lt;视图名&gt; [(&lt;列名&gt; [,&lt;列名&gt;]…)] AS &lt;子查询&gt; [WITH CHECK OPTION]; 其中，子查询可以是任意复杂的SELECT语句，但通常不允许有order by子句和DISTINCT短语 with chech option 表示对视图进行update，insert和delete操作时要保证更新，插入，或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）。组成视图的属性列名或者全部省略或全部指定，没有第三选择，如果省略了视图的各个属性列名，则隐含该视图由子查询中select子句目标列中的诸字段组成，但在下列三种情况下必须明确指定组成视图的所有列名：（1）某个目标列不是单纯的属性名，而是聚集函数或列表达式（2）多表连接时选出几个同名列作为视图的字段；（3）需要在视图中为某个列启用新的更合适的名字。 例 建立信息系学生的视图 12345CREATE VIEW IS_Student AS SELECT Sno,Sname,Sage FROM Student WHERE Sdept= 'IS'; 本例中省略了视图 IS_Student的列名，则用select子句目标列中的诸字段来组成属性列名， RDBMS 执行 CREATE VIEW 语句的结果只是把视图的定义存入了数据字典，并不执行其中的select语句，只是在对视图查询时，才按视图的定义从基本表中将数据查出。 例 建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生 123456CREATE VIEW IS_Student AS SELECT Sno,Sname,Sage FROM Student WHERE Sdept= 'IS' WITH CHECK OPTION; 由于定义视图时加入了WITH CHECK OPTION子句，以后对该视图进行插入、修改和删除操作时，RDBMS会自动加上Sdept =‘IS’ 的条件 若一个视图是从单个基本表到处的，并且只是去掉基本表的某些行或者某些列，但保留了主码，我们称这类视图为行列子集视图，IS_Student就是一个行列子集视图。 视图不仅可以建立在单个基本表上，也可以建立在多个基本表上 例 建立信息系选修了1号课程的学生的视图 1234567CREATE VIEW IS_S1(Sno,Sname,Grade)ASSELECT Student.Sno ,Sname ,GradeFROM Student ,SCWHERE Sdept ='IS' AND Student.Sno=SC.Sno AND SC.Cno='1'; 由于视图IS_S1的属性列中包含了Student表与SC表的同名列Sno，所以必须在视图后面明确说明视图的各个属性列名。 视图不仅可以建立在一个或多个基本表，还可以建立在一个或多个已定义好的视图，或建立在视图与视图上。例： 建立信息系选修了1 号课程且成绩在90分以上的学生的视图 12345CREATE VIEW IS_S2ASSELECT Sno,Sname,GradeFROM IS_S1WHERE Grade&gt;=90; 这个视图IS_S2就是定义在IS_S1之上的。 定义基本表时，为了减少数据库中的冗余数据，表中只存放基本数据，由基本数据经过各种计算派生出的数据一般是不存储的。 但由于视图中的数据并不实际存储，所以定义视图时可以根据应用的需要，设置一些派生属性列。 这些派生属性列由于在基本标中并不实际存在也称他们为 虚拟列，带虚拟列的视图也称为 带表达式的视图 。 例 定义一个反映学生出生年份的视图 1234CREATE VIEW BT_S(Sno, Sname, Sbirth) /*BT_S带表达式的视图*/AS SELECT Sno, Sname, 2004-SageFROM Student; 视图中的出生年份是根据计算得到的 还可以用带有聚集函数和 GROUP BY子句的查询来定义视图，这种视图称为 分组视图 例 将学生的学号及他的平均成绩定义为一个视图 12CREATE VIEW S_G(Sno, Gavg)AS 由于AS子句中select语句的目标列平均成绩是通过作用聚集函数得到的，所以CREATE VIEW 中必须明确定义组成S_G视图的各个属性列名，S_G是一个分组视图 例 将Student表中所有女生记录定义为一个视图 12345CREATE VIEW F_Student(stdnum, name, sex, age, dept)AS SELECT * FROM Student WHERE Ssex='女'; F_Student是由子查询 ‘select * ’建立起来的。F_Student视图的属性列与Student表的属性列一一对应。如果以后修改了基本表Student的结构，则Student表与F_Student视图的映像关系就被破坏了，该视图不能正常工作 为避免这种情况，最好修改基本表之后删除由该基本表导出的视图。然后重建这个视图。 二、删除视图 格式为： 1DROP VIEW &lt;视图名&gt; [CASCADE]; 该语句从数据字典中删除指定的视图定义 如果该视图上还导出了其他视图，使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除 删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除 例 删除视图BT_S：1DROP VIEW BT_S; 删除视图IS_S1：1DROP VIEW IS_S1; 其中IS_S1视图上还导出了IS_S2视图，所以该语句被拒绝执行，如果要删除，那么使用级联删除语句 1DROP VIEW IS_S1 CASCADE /* 级联删除IS_S!和它到处的所有视图*/ 查询视图视图定义以后，就可以对基本表一样对视图进行查询了 例 信息系学生的视图中找出年龄小于20岁的学生 123SELECT Sno, SageFROM IS_StudentWHERE Sage&lt;20; RDBMS 执行对视图查询时，首先进行有效性查询，检查查询中涉及的表、视图等是否存在，如果存在，则从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询，这一转换过程称为视图消解。 取出S_Student视图的定义： 1234CREATE VIEW IS_StudentAS SELECT Sno, Sname, Sage FROM Student WHERE Sdept= 'IS'; 本例转换后的查询语句： 123SELECT Sno, SageFROM StudentWHERE Sdept='IS' AND Sage&lt;20; 例 查询选修了 1号课程的信息系学生 123SELECT IS_Student.Sno,SnameFROM IS_Student.SCWHERE IS_Student.Sno =SC.Sno AND SC.Cno='1'; 本查询涉及视图IS_Student （虚表）和基本表SC ，通过这两个表的联结来完成用户请求。在一般情况下，视图查询的转换是直接了当的，但有些情况下，这种转换不能直接进行，查询时会出现问题，如下面的例子 例 在上面S_G视图 中查询的平均成绩在90分以上的学生学号和平均成绩。语句为： 123SELECT * FROM S_CWHERE Gavg &gt;= 90; 其中S_G 视图的子查询为 123SELECT Sno, AVG(Grade) FROM SC GROUP BY Sno; 将本例中的查询语句与定义S_G视图的子查询结合，形成下列错误的查询语句： 1234SELECT Sno ,AVG(Grade)FROM SCWHERE AVG(Grade) &gt;= 90GROUP BY Sno; 因为where子句中是不能用聚集函数作为条件表达式，因此执行此修正后的查询将会出现语法错误，正确的转换的查询语句应该是： 1234SELECT Sno,AVG(Grade)FROM SCGROUP BY SnoHAVING AVG(Grade) &gt;= 90; 目前多数关系数据库系统对行列子集视图的查询均能进行正确转换，但对非行列子集视图的查询就不一定能做转换，这类查询应该直接对基本表进行。 更新视图更新视图是指通过视图来插入（INSERT）、更新（UPDATE）和删除（DELETE）表中的数据。因为视图是一个虚拟的表，其中没有数据。通过视图更新时，都是转换基本表来更新。从用户角度看，更新视图与更新基本表相同；RDBMS将之转化为对基本表的更新操作。为了防止用户通过视图对数据进行增加、删除、修改时，有意无意的对不属于视图范围内的基本表数据进行操作，可在定义视图时加上with check option子句，这样在视图上增删改数据时，RDBMS会检查视图定义的条件，若不满足条件，则拒绝该操作。更新视图时，只能更新权限范围内的数据。超出了范围，就不能更新。 例 将信息系学生视图IS_Student中学号95002的学生姓名改为“刘辰” 123UPDATE IS_StudentSET Sname='刘辰'WHERE Sno='95002'; 转换后的更新语句： 123UPDATE StudentSET Sname='刘辰'WHERE Sno='95002' AND Sdept = 'IS'; 例 向信息系学生视图IS_Student中插入一个新的学生记录, 学号为95029,姓名为”赵新”, 年龄为20岁 123INSERTINTO IS_StudentVALUES('200215129','赵新' , 20 ，'IS'); 转换后对基本表的更新 123INSERTINTO Student (Sno, Sname ,Sage ,Sdept)VALUES( '200215129' , '赵新' ,20 , 'IS'); 这里系统自动将系名 ‘ IS ‘ 放入VALUES子句中， 例 删除信息系学生视图 IS_Student中学号为200215129的记录 123DELETEFROM IS_StudentWHERE Sno= '2OO215129' 转换为对基本表的更新： 123DELETE FROM StudentWHERE Sno ='200215129' AND Sdept ='IS'; 在关系数据库中，并不是所有的视图的都是可更新的，因为有些视图的更新不能唯一的有意义的转换成相应的基本表的更新 例如 视图S_G是由学号和平均成绩两个属性列组成的，其中平均成绩是由Student表中对元组分组后计算平均值得到的 12345CREATE VIEW S_G(Sno,Gavg)ASSELECT Sno,AVG(Grade)FROM SCGROUP BY Sno; 但是修改平均成绩是错误的，错误的语句如下： 123UPDATE S_GSET Gvag = 90WHERE Sno= '200215121'; 这个对视图的更新是无法转换成对基本表SC的更新的，因为系统无法修改各科成绩，以使平均成绩为90，所以S_G视图是不可更新的 一般来说，行列子集视图是可更新的。目前各个关系数据库一般都只允许对行列子集进行更新，而且各个系统对视图的更新还有进一步的规定。 视图的作用 视图能够简化用户的操作视图机制使用户可以将注意力集中在所关心地数据上。如果这些数据不是直接来自基本表，则可以通过定义视图，使数据库看起来结构简单、清晰，并且可以简化用户的的数据查询操作。例如，那些定义了若干张表连接的视图，就将表与表之间的连接操作对用户隐藏起来了。换句话说，用户所作的只是对一个虚表的简单查询，而这个虚表是怎样得来的，用户无需了解。 视图使用户能以多种角度看待同一数据视图机制能使不同的用户以不同的方式看待同一数据，当许多不同种类的用户共享同一个数据库时，这种灵活性是非常必要的。 视图对重构数据库提供了一定程度的逻辑独立性数据的物理独立性是指用户的应用程序不依赖于数据库的物理结构。数据的逻辑独立性是指当数据库重构造时，如增加新的关系或对原有的关系增加新的字段，用户的应用程序不会受影响。层次数据库和网状数据库一般能较好地支持数据的物理独立性，而对于逻辑独立性则不能完全的支持。在关系数据库中，数据库的重构造往往是不可避免的。重构数据库最常见的是将一个基本表“垂直”地分成多个基本表。例如：将学生关系Student（Sno，Sname，Ssex，Sage，Sdept）分为SX（Sno，Sname，Sage）和SY（Sno，Ssex，Sdept）两个关系。这时原表Student为SX表和SY表自然连接的结果。如果建立一个视图Student： 12345CREATE VIEW Student（Sno，Sname，Ssex，Sage，Sdept）ASSELECT SX.Sno，SX.Sname，SY.Ssex，SX.Sage，SY.SdeptFROM SX，SYWHERE SX.Sno=SY.Sno； 这样尽管数据库的逻辑结构改变了（变为SX和SY两个表了），但应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。 当然，视图只能在一定程度上提供数据的逻辑独立，比如由于视图的更新是有条件的，因此应用程序中修改数据的语句可能仍会因为基本表构造的改变而改变。 视图能够对机密数据提供安全保护有了视图机制，就可以在设计数据库应用系统时，对不同的用户定义不同的视图，使机密数据不出现在不应该看到这些数据的用户视图上。这样视图机制就自动提供了对机密数据的安全保护功能。例如，Student表涉及全校15个院系学生数据，可以在其上定义15个视图，每个视图只包含一个院系的学生数据，并只允许每个院系的主任查询和修改本原系学生视图。 适当的利用视图可以更清晰地表达查询例如经常需要执行这样的查询“对每个学生找出他获得最高成绩的课程号”。可以先定义一个视图，求出每个同学获得的最高成绩： 12345CREATE VIEW VMGRADEASSELECT Sno，MAX(Grade) MgradeFROM SCGROUP BY Sno； 然后用如下的查询语句完成查询： 123SELECT SC.Sno，Cno FROM SC，VMGRADE WHERE SC.Sno = VMGRADE.Sno AND SC.Grade = VMGRADE.Mgrade；]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iBatis]]></title>
    <url>%2Fposts%2F115b549a.html</url>
    <content type="text"><![CDATA[iBatis内容包括 iBatis 简介搭建环境配置文件读取配置基本的CRUD操作模糊查询自动主键selectKey优点 iBatis 简介&nbsp; iBATIS一词来源于“internet”和“abatis”的组合，是一个由Clinton Begin在2001年发起的开放源代码项目。于2010年6月16号被谷歌托管，改名为MyBatis。是一个基于SQL映射支持Java和·NET的持久层框架。 &nbsp; Ibatis是开源软件组织Apache推出的一种轻量级的对象关系映射(ORM)框架，和Hibernate、Toplink等在java编程的对象持久化方面深受开发人员欢迎。 &nbsp; 对象关系映射(ORM)：简单原理是通过面向对象方式操作关系型数据库，目前存储数据最常用最流行的工具是关系型数据库，其操作方式是通过 SQL语句操作数据库的表，但是对于Java面向对象编程语言中，所有的操作对象都是对象，因此对象关系映射就是把数据库表和java编程语言中的对象对 应起来，把表的列同java对象中的字段对应起来，程序员在程序开发过程中不再是使用原始SQL语句去直接操作数据库，而是通过ORM提供的查询语句操作 普通的java对象，ORM将其提供的对普通java对象的查询语句翻译成SQL语句来操作数据库，从而屏蔽了不同数据库SQL语句的差别，简化了程序开 发工作，提高了程序的可移植性。 环境搭建导入jar包ibatis-2.3.4.726.jarsqljdbc.jar 配置文件这是总配置文件 SqlMapConfig.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE sqlMapConfig PUBLIC "-//iBATIS.com//DTD SQL Map Config 2.0//EN" "http://www.ibatis.com/dtd/sql-map-config-2.dtd" &gt; &lt;sqlMapConfig&gt;&lt;properties resource="Resources/SqlMap.properties"/&gt;&lt;transactionManager type ="JDBC" &gt; &lt;!-- 定义了ibatis的事务管理器有3中（JDBC,JTA,EXTERNAL） --&gt; &lt;dataSource type ="SIMPLE"&gt; &lt;!-- type属性指定了数据源的链接类型，也有3种类型(SIMPLE,DBCP,JNDI) --&gt; &lt;property name ="JDBC.Driver" value ="$&#123;driver&#125;" /&gt;&lt;property name ="JDBC.ConnectionURL" value ="$&#123;url&#125;" /&gt;&lt;property name ="JDBC.Username" value ="$&#123;username&#125;" /&gt;&lt;property name ="JDBC.Password" value ="$&#123;password&#125;" /&gt;&lt;property name ="Pool.MaximumActiveConnections" value ="10"/&gt; &lt;!-- 连接池维持的最大容量 --&gt;&lt;property name ="Pool.MaximumIdleConnections" value ="5" /&gt; &lt;!-- 连接池允许挂起的最大连接 --&gt;&lt;property name ="Pool.MaximumCheckoutTime" value ="120000" /&gt; &lt;!-- 连接被某个任务所允许占用的最大时间 --&gt; &lt;property name ="TimeToWait" value ="500" /&gt; &lt;!-- 线程允许等待的最大时间 --&gt; &lt;/dataSource &gt;&lt;/transactionManager &gt;&lt;sqlMap resource = "cn/shelhon/Student.xml" /&gt;&lt;/sqlMapConfig &gt; 这是映射文件 student.xml表示实体类的映射文件，它的里面是对实体的一些操作，即增、删、改、查。 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE sqlMap PUBLIC "-//ibatis.apache.org//DTD SQL Map 2.0//EN" "http://ibatis.apache.org/dtd/sql-map-2.dtd"&gt; &lt;sqlMap&gt;&lt;!-- 定义别名,可以在指定类型时不用输入类型全路径 方便开发--&gt;&lt;typeAlias alias="Student" type="cn.shelhon.Student"/&gt;&lt;select id="selectAllStudent" resultClass="Student"&gt;select * from student&lt;/select&gt;&lt;select id="selectAllStudentByID" parameterClass="int" resultClass="Student"&gt;select * from student where sid= #sid# &lt;/select&gt;&lt;/sqlMap&gt; 其中映射文件可以不断修改来增加功能 属性文件 SqlMap.properties 1234driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost/test username=root password=12345 创建实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package cn.shelhon;import java.sql.Date;public class Student &#123; private int sid = 0; private String sname =null; private String major =null; private Date birth= null; private float score = 0; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; public int getSid() &#123; return sid; &#125; public void setSid(int sid) &#123; this.sid = sid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public String getMajor() &#123; return major; &#125; public void setMajor(String major) &#123; this.major = major; &#125; public float getScore() &#123; return score; &#125; public void setScore(float score) &#123; this.score = score; &#125; @Override public String toString() &#123; return "Student&#123;" + "sid=" + sid + ", sname='" + sname + '\'' + ", major='" + major + '\'' + ", birth=" + birth + ", score=" + score + '&#125;'; &#125;&#125; 创建接口类 12345678910111213package cn.shelhon;import java.util.List;public interface IStudentDAO &#123; public void addStudent (Student student); public void addStudentBySequence(Student student); public void deleteStudentByID(int id); public void updateStudent(Student student); public List&lt;Student&gt; queryAllStudent(); public List&lt;Student&gt; queryStudentByName(String name); public Student queryStudentByID(int id);&#125; 然后再创建实现类来实现方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package cn.shelhon;import com.ibatis.sqlmap.client.SqlMapClient;import java.io.IOException;import java.io.Reader;import java.sql.SQLException;import java.util.List;public class IStudentDAOImpl implements IStudentDAO&#123; private static SqlMapClient sqlMapClient= null;//读取配置信息 static &#123; try&#123; Reader reader=com.ibatis.common.resources.Resources.getResourceAsReader("SqlMapConfig.xml"); sqlMapClient = com.ibatis.sqlmap.client.SqlMapClientBuilder.buildSqlMapClient(reader); reader.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; @Override public void addStudent(Student student) &#123; &#125; @Override public void addStudentBySequence(Student student) &#123; &#125; @Override public void deleteStudentByID(int id) &#123; &#125; @Override public void updateStudent(Student student) &#123; &#125;//查询所有信息 @Override public List&lt;Student&gt; queryAllStudent() &#123; List&lt;Student&gt; studentList =null; try &#123; studentList = sqlMapClient.queryForList("selectAllStudent"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return studentList; &#125; @Override public List&lt;Student&gt; queryStudentByName(String name) &#123; return null; &#125;//通过id来查询信息 @Override public Student queryStudentByID(int id) &#123; Student student= null; try &#123; student = (Student) sqlMapClient.queryForObject("selectAllStudentByID",id); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return student; &#125; public static void main(String[] args) &#123; IStudentDAO dao =new IStudentDAOImpl(); /* for(Student student:dao.queryAllStudent())&#123; System.out.println(student); &#125;*/ Student student=dao.queryStudentByID(1); System.out.println(student); &#125;&#125; 查询所有对象 增加查询接口 1public List&lt;Student&gt; queryAllStudent(); 映射文件 123&lt;select id="selectAllStudent" resultClass="Student"&gt;select * from student&lt;/select&gt; 实现接口 1234567891011//查询所有对象 @Override public List&lt;Student&gt; queryAllStudent() &#123; List&lt;Student&gt; studentList =null; try &#123; studentList = sqlMapClient.queryForList("selectAllStudent"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return studentList; &#125; 测试 12345public static void main(String[] args) &#123; IStudentDAO dao =new IStudentDAOImpl(); for(Student student:dao.queryAllStudent())&#123; System.out.println(student); &#125;&#125; 查询指定id的对象 接口 1public void deleteStudentByID(int id); 映射文件 1234&lt;select id="selectAllStudentByID" parameterClass="int" resultClass="Student"&gt;select * from student where sid= #sid# &lt;/select&gt; 方法 1234567891011//通过id来查询信息 @Override public Student queryStudentByID(int id) &#123; Student student= null; try &#123; student = (Student) sqlMapClient.queryForObject("selectAllStudentByID",id); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return student; &#125; 测试 12345public static void main(String[] args) &#123; IStudentDAO dao =new IStudentDAOImpl(); Student student=dao.queryStudentByID(1); System.out.println(student); &#125; 增加对象 接口 1public void addStudent (Student student); 映射文件 1234&lt;insert id="insertStudent" parameterClass="Student"&gt; insert into Student (sid,sname,major,birth,score) values (#sid#,#sname#,#major#,#birth#,#score#);&lt;/insert&gt; 实现类 1234567public void addStudent(Student student) &#123; try &#123; sqlMapClient.insert("insertStudent",student); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 测试 12345678910public static void main(String[] args) &#123; IStudentDAO dao = new IStudentDAOImpl(); Student student = new Student(); student.setSid(3); student.setMajor("体育"); student.setBirth(Date.valueOf("1993-10-11")); student.setSname("qsx"); student.setScore(919); dao.addStudent(student);&#125; 删除指定id的对象 接口 1public void deleteStudentByID(int id); 映射文件 12345&lt;delete id="deleteStudentByID" parameterClass="int"&gt; delete from student where sid =#sid# &lt;/delete&gt; 实现 12345678// 通过id删除对象 public void deleteStudentByID(int id) &#123; try &#123; System.out.println(sqlMapClient.delete("deleteStudentByID",id));//为了验证效果，打印影响了几行 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 测试 12345public static void main(String[] args) &#123; IStudentDAO dao = new IStudentDAOImpl();//测试删除id为13的对象 dao.deleteStudentByID(13);&#125; 注意在映射文件的mysql语句where sid = #sid#后面的 #sid#可以写成 #任意内容#因为这两个#号只是占位符，会自动匹配但是在多个值要输入的时候，就还是按照模板来写，不然还是会报错因为错误的值会导致找不到对应对象里面的get方法 更新修改对象 接口 1public void updateStudent(Student student); 映射文件 1234567&lt;update id="updateStudentByID" parameterClass="Student"&gt; update Student set sname=#sname#, major=#major#, score=#score#, birth=#birth# where sid=#sid# &lt;/update&gt; 特别要注意里面set sname 、major、score、birth之间要加逗号不然又是语法错误 实现 1234567@Override // 修改对象 public void updateStudent(Student student) &#123; try &#123; System.out.println(sqlMapClient.update("updateStudentByID",student)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 测试 12345678910public static void main(String[] args) &#123; IStudentDAO dao = new IStudentDAOImpl(); Student student =new Student(); student.setSid(2); student.setScore(10); student.setSname("shelhon"); student.setBirth(Date.valueOf("1993-12-30")); student.setMajor("科学"); dao.updateStudent(student);&#125; 通过名字模糊查找 接口 1public List&lt;Student&gt; queryStudentByName(String name); 映射文件 12345&lt;select id="selectStudentByName" parameterClass="String" resultClass="Student"&gt; select sid,sname,score,major,birth from Student where sname like '%$sname$%'&lt;/select&gt; 这里要注意最后的符号问题！！！ 1&apos;%$sname$%&apos; 实现 1234567891011@Override //通过名字模糊查询 public List&lt;Student&gt; queryStudentByName(String name) &#123; List&lt;Student&gt; studentList=null; try &#123; studentList=sqlMapClient.queryForList("selectStudentByName",name); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return studentList;&#125; 测试 123456IStudentDAO dao = new IStudentDAOImpl();for(Student student:dao.queryStudentByName("q"))&#123; System.out.println(student);&#125; 通过序列插入对象 接口 1public void addStudentBySequence(Student student); 映射文件 1234567&lt;insert id="addStudentBySequence" parameterClass="Student"&gt;&lt;selectKey resultClass="int" keyProperty="sid"&gt; SELECT @@IDENTITY as sid &lt;/selectKey&gt; insert into Student (sid, sname, major, birth, score) value (#sid#,#sname#,#major#,#birth#,#score#)&lt;/insert&gt; 实现 1234567891011@Override // 增加序列 public void addStudentBySequence(Student student) &#123; try &#123; //1从数据库序列中获取主键值 //2往student表中插入记录 sqlMapClient.insert("addStudentBySequence",student); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 测试 1234567Student student =new Student();student.setSid(2);student.setScore(100);student.setSname("qsx");student.setBirth(Date.valueOf("1993-12-30"));student.setMajor("科学1");dao.addStudentBySequence(student); 由于视频学习的是Oracle的数据库操作，然后我使用的是mysql的,所以在配置上有点不同，但是我个人觉得，MySQL数据库在添加对象的时候，没必要输入id，因为数据库的主键id可以自增，直接不输入id，表生成的时候id就会自己添加进去。效果跟这个通过序列插入对象是一样的。 优缺点优点与JDBC相比： 减少了百分之60的代码量 简单 架构级性能增强 SQL语句和程序代码分离 简化项目中的分工 增强了移植性 缺点： SQL需要自己写 参数数量只能是一个 已经出了第三代Mybatis的版本，ibatis已经落后了]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>iBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2学习(二）]]></title>
    <url>%2Fposts%2F3a01fcdf.html</url>
    <content type="text"><![CDATA[主要内容 struts2值栈struts2拦截器 struts2值栈ognl概述 EL表达式在jsp中获取域对象里面的值 OGNL也是一种表达式，这个表达式功能更加强大（1）在struts2里面操作值栈数据（2）一般把ognl在struts2操作：和struts2标签一起使用操作值栈 OGNL不是struts2的一部分，单独的项目，经常和struts2一起使用（1）使用ognl时候首先导入jar包，struts2提供jar包 OGNL入门案例 使用ognl+struts2标签实现计算字符串长度支持对象方法调用，比如objName.methodName()在Java代码中，调用字符串length() 使用struts2标签 （1）使用jstl时候，导入jar包之外，在jsp页面中引入标签库使用struts2标签时候，在jsp中引入标签库1&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt; （2）使用struts2标签实现操作1&lt;!-- 使用ognl加struts2标签实现计算字符串长度 --&gt; &lt;s:property value="'asdasd'.length()"/&gt; 什么是值栈 之前在web阶段，在servlet里面进行操作，把数据放到域对象里面，在页面中使用el表达式获取到，域对象在一定范围内，存值和取值 在struts2里面提供本身一种存储机制，类似于域对象，是值栈，可以存值和取值（1）在action里面把数据放到值栈里面，在页面中获取到值栈数据 servlet和action区别（1）Servlet：默认在第一次访问时候创建，创建一次，单实例对象（2）Action：访问时候创建，每次访问action时候，都会创建action对象，创建多次，多实例对象 值栈存储位置（1）每次访问action时候，都会创建action对象，（2）在每个action对象里面都会有一个值栈对象（只有一个） 获取值栈对象 获取值栈对象有多种方式（1）常用方式：使用ActionContext类里面的方法得到值栈对象1234567public String execute() throws Exception &#123; //获取ActionContext类对象 ActionContext context =ActionContext.getContext(); //调用方法得到值栈 ValueStack stack1 = context.getValueStack(); return NONE;&#125; 值栈内部结构 值栈分为两部分： 第一部分 root，结构是list集合 一般操作都是root里面数据 第二部分 context，结构map集合 具体看下图 struts2里面标签 s:debug，使用这个标签可以查看值栈结构和存储值（1）访问action，执行action的方法有返回值，配置返回值到jsp页面中，在jsp页面中使用这个标签 12&lt;!--struts2标签查看值栈结构--&gt; &lt;s:debug&gt;&lt;/s:debug&gt; 就会多一个debug按钮来查看信息 action对象里面有值栈对象值栈对象里面有action引用 向值栈放数据向值栈放数据多种方式第一种 获取值栈对象，调用值栈对象里面的 set 方法 12345678public String execute() throws Exception &#123; //第一种方法 获取值栈对象里面的set方法 //获取值栈对象 ActionContext context = ActionContext.getContext(); ValueStack stack = context.getValueStack(); //调用方法set方法 stack.set("username","shelhon"); return "ok"; debug页面就会多一个入栈 java.util.HashMap 第二种 获取值栈对象，调用值栈对象里面的 push方法12//调用方法push方法 stack.push("abdc"); 又多一个入栈 ：java.lang.String 第三种 在action定义变量，生成变量的get方法 123456789private String name;public String getName() &#123; return name;&#125;@Override public String execute() throws Exception &#123; //在执行方法里面向变量来赋值 name ="asdasd"; return "ok";&#125; 这种方法直接在原来的值栈上面写入数据，不需要生成新的值栈来存储，可以节省空间 向值栈放对象 实现步骤 第一步 定义对象变量12//1定义变量 private User user = new User(); 第二步 生成变量的get方法123public User getUser() &#123; return user;&#125; 第三步 在执行的方法里面向对象中设置值1234567public String execute() throws Exception &#123; //3 向值栈的user里面放数据 user.setUsername("luck"); user.setPassword("123"); user.setAddress("gz"); return "ok";&#125; 向值栈放list集合第一步 定义list集合变量1private List&lt;User&gt; list = new ArrayList&lt;User&gt;(); 第二步 生成变量的get方法123public List&lt;User&gt; getList() &#123; return list;&#125; 第三步 在执行的方法里面向list集合设置值123456789101112131415public String execute() throws Exception &#123; User user1= new User(); user1.setUsername("ben"); user1.setAddress("gz"); user1.setPassword("111"); User user2 =new User(); user2.setUsername("jack"); user2.setPassword("009"); user2.setAddress("cd"); list.add(user1); list.add(user2); return "ok";&#125; 从值栈获取数据使用struts2的标签+ognl表达式获取值栈数据&lt;s:property value=”ognl表达式”/&gt; 获取字符串 向值栈放字符串 12345678910111213public class ValueStackAction extends ActionSupport &#123; //定义变量 private String username; public String getUsername()&#123; return username; &#125; @Override public String execute() throws Exception &#123; //给变量赋值 username="shelhon"; return "ok"; &#125;&#125; 在jsp使用struts2标签+ognl表达式获取 1&lt;s:property value="username"/&gt; 获取对象 向值栈放对象 123456789101112131415public void setUser(User user) &#123; this.user = user;&#125;private User user =new User();public User getUser() &#123; return user;&#125;public String execute() throws Exception &#123; user.setUsername("asd"); user.setPassword("222"); user.setAddress("gz"); return "ok"; 在页面中获取值123&lt;s:property value="user.username"/&gt;&lt;s:property value="user.password"/&gt;&lt;s:property value="user.address"/&gt; 获取list集合三种方法一开始先把list放到值栈去1234567891011121314151617private List&lt;User&gt; list = new ArrayList&lt;User&gt;();public List&lt;User&gt; getList() &#123; return list;&#125;@Override public String execute() throws Exception &#123; User user1= new User(); user1.setUsername("qsx"); user1.setAddress("gz"); user1.setPassword("111"); User user2 =new User(); user2.setUsername("jack"); user2.setPassword("009"); user2.setAddress("cd"); list.add(user1); list.add(user2); return "ok"; 第一种 1234567&lt;!-- 第一种方式 --&gt; &lt;s:property value="list[0].username"/&gt;&lt;s:property value="list[0].possword"/&gt;&lt;s:property value="list[0].address"/&gt;&lt;s:property value="list[1].username"/&gt;&lt;s:property value="list[1].possword"/&gt;&lt;s:property value="list[1].address"/&gt; 第二种 1234567&lt;!-- 使用struts2标签，类似jst1的foreach标签 &lt;s:iterator&gt;遍历值栈的list集合--&gt;&lt;s:iterator value="list"&gt;&lt;!-- 遍历list得到list里面每一个user对象 --&gt; &lt;s:property value="username"/&gt; &lt;s:property value="password"/&gt; &lt;s:property value="address"/&gt; &lt;/s:iterator&gt; 第三种1234567&lt;s:iterator value="list" var="user"&gt; &lt;!-- 遍历值栈list集合，得到每个user对象 机制：把每次遍历出来的user对象放到context里面 获取context里面的数据特点：写ognl表达式， 使用特殊符号 # --&gt; &lt;s:property value="#user.username"/&gt; &lt;s:property value="#user.username"/&gt; &lt;s:property value="#user.username"/&gt;&lt;/s:iterator&gt; 其他操作 先获取set方法设置的值 使用set方法向值栈放数据，获取12ValueStack stack = context.getValueStack();stack.set("shelhon","shelhon.cn"); 1&lt;s:property value="shelhon"/&gt; 使用push方法向值栈放数据，获取 1stack.push("asdb"); （1）使用push方法设置值，没有名称，只有设置的值（2）向值栈放数据，把向值栈放数据存到数组里面，数组名称 top，根据数组获取值1&lt;s:property value="[0].top"/&gt; EL表达式获取值栈数据首先要先导入两个jar包，分别是jstl.jar和standard.jar切记用idea的maven时，需要把这个jar包导入到tomcat里面去，具体看另一篇笔记，配置依赖的问题。 在jsp上面补个标签1&lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt; 1234&lt;c:forEach items="$&#123;list &#125;" var="user"&gt; $&#123;user.username &#125; $&#123;user.password &#125; $&#123;user.address &#125; &lt;/c:forEach&gt; EL表达式获取域对象值 向域对象里面放值使用setAttribute方法，获取值使用getAttribute方法 底层增强request对象里面的方法getAttribute方法（1） 首先从request域获取值，如果获取到，直接返回（2）如果从request域获取不到值，到值栈中把值获取出来，把值放到域对象里面 源码：public class StrutsRequestWrapper extends HttpServletRequestWrapperpublic Object getAttribute(String key) 不建议这么做，性能很低 OGNL的#、%使用关于 # 号的使用 使用#获取context里面数据 123&lt;s:property value="#user.username"/&gt;&lt;s:property value="#user.username"/&gt;&lt;s:property value="#user.username"/&gt; 关于 % 的使用 在struts2标签中表单标签（1） 在struts2标签里面使用ognl表达式，如果直接在struts2表单标签里面使用ognl表达式不识别，只有%之后才会识别。 错误示范,识别不了1&lt;s:textfield name="username" value="#request.req"&gt;&lt;/s:textfield&gt; 正确的应该是 1&lt;s:textfield name="username" value="%&#123;#request.req&#125;"&gt;&lt;/s:textfield&gt; 就是一个 %{} 里面写入ognl表达式 Struts2拦截器概述 struts2是框架，封装了很多的功能，struts2里面封装的功能都是在拦截器里面 struts2里面封装了很多的功能，有很多拦截器，不是每次这些拦截器都执行，每次执行默认的拦截器 struts2里面默认拦截器位置在struts2-core-2.3.24.jar里面有个叫struts-default.xml的文件最下面的内容是默认的拦截器 1234567891011121314151617181920212223242526&lt;interceptor-stack name="defaultStack"&gt; &lt;interceptor-ref name="exception"/&gt; &lt;interceptor-ref name="alias"/&gt; &lt;interceptor-ref name="servletConfig"/&gt; &lt;interceptor-ref name="i18n"/&gt; &lt;interceptor-ref name="prepare"/&gt; &lt;interceptor-ref name="chain"/&gt; &lt;interceptor-ref name="scopedModelDriven"/&gt; &lt;interceptor-ref name="modelDriven"/&gt; &lt;interceptor-ref name="fileUpload"/&gt; &lt;interceptor-ref name="checkbox"/&gt; &lt;interceptor-ref name="datetime"/&gt; &lt;interceptor-ref name="multiselect"/&gt; &lt;interceptor-ref name="staticParams"/&gt; &lt;interceptor-ref name="actionMappingParams"/&gt; &lt;interceptor-ref name="params"/&gt; &lt;interceptor-ref name="conversionError"/&gt; &lt;interceptor-ref name="validation"&gt; &lt;param name="excludeMethods"&gt;input,back,cancel,browse&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="workflow"&gt; &lt;param name="excludeMethods"&gt;input,back,cancel,browse&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="debugging"/&gt; &lt;interceptor-ref name="deprecation"/&gt;&lt;/interceptor-stack&gt; 拦截器在什么时候执行？在action对象创建之后，action的方法执行之前 拦截器底层原理 拦截器底层使用两个原理第一个: aop思想文字描述：Aop是面向切面（方面）编程，有基本功能，扩展功能，不通过修改源代码方式扩展功能 看图理解 第二个 ：责任链模式（1）在java中有很多的设计模式，责任链模式是其中的一种（2）责任链模式和过滤链很相似的责任链模式： 要执行多个操作，有添加、修改、删除三个操作。首先执行添加操作，添加操作执行之后 做类似于放行操作，执行修改操作，修改操作执行之后做类似于放行操作，执行删除操作 过滤链：一个请求可有多个过滤器进行过滤，每个过滤器只有做放行才能到下一个过滤器 aop思想和责任链模式如何应用到拦截器里面？ 1）文字描述： 拦截器在action对象创建之后，action的方法执行之前执行 在action方法执行之前执行默认拦截器，执行过程使用aop思想，在action没有直接调用拦截器的方法，使用配置文件方式进行操作 在执行拦截器时候，执行很多的拦截器，这个过程使用责任链模式 假如执行三个拦截器，执行拦截器1，执行拦截器1之后做放行操作，执行拦截器2，执行拦截器2之后做放行，执行拦截器3，执行拦截器3之后放行，执行action的方法 看图分析 重要的概念 过滤器和拦截器区别（1）过滤器：过滤器理论上可以任意内容，比如html、jsp、servlet、图片路径（2）拦截器：拦截器只可以拦截action Servlet和action区别（1）servlet默认第一次访问时候创建，创建一次，单实例对象（2）action每次访问时候创建，创建多次，多实例对象 自定义拦截器 在struts2里面有很多的拦截器，这些拦截器是struts2封装的功能，但是在实际开发中，struts2里面的拦截器中可以没有要使用的功能，这个时候需要自己写拦截器实现功能 拦截器结构 （1）从源码查看拦截器结构 继承类1class ModelDrivenInterceptor extends AbstractIntercetor 1class AbstractInterceptor implements Interceptor 在接口里有三个方法初始化： 1void init(); 销毁：1void destroy(); 拦截逻辑操作： 1String intercept(ActionInvocation invocation) (2)开发中，建议使用另外一种方式 写类，继承 MethodFilterInterceptor类实现 让action里面某个的方法不进行拦截 （3）让拦截器和action有关系 不是在action调用拦截器的方法，而是通过配置文件方式让建立关系 自定义登录拦截器 需求：在项目中，有很多的action的超链接，实现只有是登录的状态，才可以点击action的超链接实现功能，如果不是登录状态，点击action超链接返回到登录页面 登录的状态：使用session域对象实现（1）登录成功之后，把数据放到session里面（2）判断session是否有值，可以知道是否是登录状态 实现登录的基本功能查询数据库判断用户名和密码（另外实现） 添加登录拦截器功能 （1）判断是否登录：判断session里面是否有名称是username的值 （2）拦截器实现过程 第一步 创建类，继承MethodFilterInterceptor类 第二步 重写MethodFilterInterceptor类里面的方法写拦截器逻辑 第三步 配置action和拦截器关系（注册拦截器） （1）在要拦截的action标签所在的package标签里面声明拦截器 （2）在具体的action标签里面使用声明的拦截器 （3）struts2里面执行很多的默认拦截器，但是如果在action里面配置自定义拦截器.问题：默认的拦截器不会执行了解决：把默认拦截器手动使用一次 配置拦截器，对action里面所有的方法都进行拦截（1）在action里面有login的登录的方法，这个方法不需要拦截，如果这个方法都拦截，问题是，永远登录不进去了（2）解决：让login方法不进行拦截 直接通过配置方式让action里面某些方法不进行拦截 Struts2的标签库 struts2标签只能使用jsp页面中 s:property： 和ognl表达式在jsp页面中获取值栈数据 s:iterator: 获取值栈list集合数据，表示list集合 s:debug: 查看值栈结构和数据 Struts2表单标签（会用）1 html表单标签 （1）form : action、method、enctype （2）输入项 大部分在input里面封装 type=”值” text：普通输入项 password：密码输入项 radio：单选输入项 checkbox：复选输入项 file：文件上传项 hidden：隐藏项 button：普通按钮 submit：提交按钮 image：图片提交 reset：重置 select：下拉输入项 textarea：文本域 2.在struts2里面对应html表单标签大部分都有 12345678910111213141516&lt;s:form&gt; &lt;s:textfield name="username" label="username"&gt; &lt;/s:textfield&gt; &lt;s:password name="password" label="mima"&gt; &lt;/s:password&gt; // 值和名称一样 &lt;s:radio list="&#123;'nv','nan'&#125;" name="sex" label="xingbie"&gt;&lt;/s:radio&gt; //值和名称不一样 &lt;s:radio list="#&#123;'nv':'女','nan':'男'&#125;" name="sex" label="xingbie"&gt;&lt;/s:radio&gt; &lt;s:checkboxlist list="&#123;'1','2','3','4'&#125;" name="fav" label="随便挑"&gt;&lt;/s:checkboxlist&gt; &lt;s:select list="&#123;'a','b','c','d'&#125;" name="abcd" label="abcd"&gt;&lt;/s:select&gt;&lt;s:textarea rows="3" cols="10" value="jianli" label="jianli"&gt; &lt;/s:textarea&gt;&lt;s:file name="file" label="dakai"&gt; &lt;/s:file&gt;&lt;s:hidden name="hid" value="asdb"&gt; &lt;/s:hidden&gt;&lt;s:submit name="sub" value="tijiao"&gt; &lt;/s:submit&gt;&lt;s:reset value="chongzhi"&gt; &lt;/s:reset&gt;&lt;/s:form&gt;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2学习]]></title>
    <url>%2Fposts%2Fc240a0d6.html</url>
    <content type="text"><![CDATA[主要内容 stuts2入门 struts2数据操作 Struts2 概述 struts2框架应用javaee三层结构中的web层框架 struts2 是struts1和webwork基础上发展全新的框架、 struts2解决问题 struts2 版本 struts2-2.3.24 web层常用框架 struts2 springMVC struts2 框架入门第一个例子 老规矩导入jar包 创建action 123456789public class HelloAction &#123; /* (1)每次访问servlet的时候，都会访问service方法 - 写类继承HTTPServlet，重写类里面的方法 (2)访问action的时候 每次访问action默认执行execute方法 */ public String execute()&#123; return "ok";&#125;&#125; 配置action类访问路径(1)、创建struts2核心配置文件核心配置文件必须是固定名称和位置位置必须是再src下面，名称必须是struts.xml(2)、引入dtd约束 123&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; (3)、action配置 1234567&lt;package name="hellodemo" extends="struts-default" namespace="/"&gt; &lt;!-- name: 访问名称 --&gt; &lt;action name="hello" class="cn.shelhon.action.HelloAction"&gt; &lt;!-- 配置方法的返回值到页面 --&gt; &lt;result name="ok"&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 访问路径http://127.0.0.1:8080/struts2/hello.action (4) 配置struts2过滤器 在Tomcat上面运行的时候，发现一直各种报错 12严重: Exception starting filter struts2java.lang.ClassNotFoundException: org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter 估计是在idea的时候，运行Tomcat时，maven依赖那里出现了问题。导入缺少了jar包，Tomcat运行不起来。最后在项目结构Artifacts里available Elements右键把里面的jar包导入到lib文件夹里。 ！！还有就是一定要把struts2.xml文件放到resources文件夹里 基本流程： 查看源码 class StrutsPrepareAndExecuteFilter implements StrutsStatics, Filter 过滤器在服务启动的时候创建，创建过滤器时候执行init方法 在init方法中主要是加载配置文件包含自己创建的配置文件和struts2自带的配置文件主要注意struts.xml和web.xml struts 配置struts2核心配置文件 名称和位置是固定的固定是在src里面，名字是struts.xml但是由于用了maven，所以位置是在src的resources里面 在配置文件中主要三个标签 package、action、result，标签里面的属性 标签package1、 类似于代码包，区别不同的action，要配置action，必须首先写package标签，在package里面才能 配置action 2、 package标签属性 （1）name属性 name属性值跟功能本身没有关系的， 在一个配置文件中可以写多个package标签，name属性值不能相同的 （2）extends属性 extends = “struts-default” 属性值固定的，struts-default 写了这个属性之后，在package里面配置的类具有action功能 （3）namespace属性 namespace属性值和action标签里面的name属性值构成访问路径 标签action1、action标签配置action访问路径 2 、action标签属性 （1）name属性 namespace属性值和action标签里面的name属性值构成访问路径 在package标签里面写多个action标签，但是action的name属性值不能相同的 （2）class属性 action全路径 （3）method属性 比如在action里面默认执行的方法execute方法，但是在action里面写其他的方法 让action里面多个方法执行，使用method进行配置 标签result1 、根据action的方法返回值，配置到不同的路径里面 2 、result标签属性 （1）name属性 和方法返回值一样 /hello.jsp （2）type属性 配置如何到路径中（转发或者重定向） type属性默认值 做转发操作 struts2常量配置 struts2框架，帮我们实现一部分功能，struts2里面有常量，在常量里面封装一部分功能 struts2默认的常量位置（记住） xxxxxxx/org\apache\struts\struts2-core\2.3.24\struts2-core-2.3.24.jar!\org\apache\struts2\default.properties 修改struts2默认常量值 （1）常用的方式 在struts.xml中进行配置 （2）还有两种方式（了解） 在src下面创建 struts.properties，进行修改 在web.xml进行配置 介绍最常用常量 struts.i18n.encoding=UTF-8 （1）表单提交数据到action里面，在action可以获取表单提交数据， （2）表单提交数据有中文，有乱码问题，解决： post提交直接设置编码 get提交做编码转换 （3）如果在action获取表单通过post方式提交中文，中文乱码问题帮解决了，不需要自己处理问题 分模块开发 单独写配置文件hello.xml，把配置文件引入到核心配置文件中 12&lt;!-- 引入hello.xml --&gt; &lt;include file="hello.xml"&gt;&lt;/include&gt; 这样就可以在工作的时候，大家一起协同办公 action编写方式 action编写有三种方式 第一种 创建普通类，这个不继承任何类，不实现任何接口 1public class HelloAction&#123;&#125; 第二种 创建类，实现接口 Action123456//实现接口 public class UserAction implements Action &#123; public String execute() throws Exception &#123; return null; &#125;&#125; 第三种 创建类，继承类 ActionSupport（一般使用） 123//继承类 public class PersonAction extends ActionSupport &#123;&#125; 访问action里面的方法 有三种方式实现 第一种 使用action标签的method属性，在这个属性里面写执行的action的方法 第二种 使用通配符方式实现 第三种 动态访问实现（不用） 演示错误 （1）如果action方法有返回值，在配置文件中没有配置，出现错误 Message No result defined for action cn.shelhon.action.HelloAction and result success （2）在action里面的方法有返回值，如果有返回值时候类型必须是String （3）action里面的方法可以没有返回值，没有返回值时候，在result标签不需要配置 把方法写成void 让返回值，返回 ”none” 在idea创建新的模块的时候，放到Tomcat上面一直没办法运行新的struts.xml的配置，然后在运行设置里面的把原来的给移除了，加上新创建的就能运行了 使用action标签method属性 (1). 创建action，创建多个方法 123456789101112public class BookAction extends ActionSupport &#123; //添加 public String add()&#123; System.out.println("add----"); return NONE; &#125; //修改 public String update()&#123; System.out.printf("update---"); return NONE; &#125;&#125; (2). 使用method配置 1234567&lt;!-- 配置action的方法访问 --&gt; &lt;package name="demo1" namespace="/" extends="struts-default"&gt; &lt;action name="method" class="cn.shelhon.method.BookAction" method="add"&gt; &lt;/action&gt; &lt;action name="method1" class="cn.shelhon.method.BookAction" method="update"&gt; &lt;/action&gt;&lt;/package&gt; 缺陷：action每个方法都需要配置，如果action里面有多个方法，配置很多的action 使用通配符实现（重点） (1) 在action标签里面name属性，name属性值里面写 符号 * 星号 *理解： 表示匹配任意内容 比如访问hello，* 可以匹配到 比如访问add，* 可以匹配到 12345678910&lt;!-- 配置通配符方法 --&gt; &lt;package name="tongpei" extends="struts-default" namespace="/"&gt;&lt;!-- name属性值里面要写一个符号 *(1)执行 action里面的add方法，访问book_add (2)执行 action里面的update方法，访问book_update 上面两个路径使用book_*可以匹配到 --&gt; &lt;action name="book_*" method="&#123;1&#125;" class="cn.shelhon.method.BookAction"&gt;&lt;/action&gt;&lt;/package&gt; 这种方法的话，访问就是用book_add.action ,或者book_update.action来实现如果name的属性值=”*”的话，那么访问就是输入add.action，或者update.action就可以实现。 结果页面配置 result标签配置action方法的返回值到不同的路径里面 创建两个action，执行默认的方法execute方法，让两个action的方法都返回success，返回success之后，配置到同一个页面里面 （1）如果多个action，方法里面返回值相同的，到页面也是相同的，这个时候可以使用全局结果页面配置 12345678910&lt;package name="demo1" extends="struts-default" namespace="/"&gt;&lt;action name="book" class="cn.shelhon.action.BookAction" method="execute"&gt;&lt;result name="success"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt;&lt;action name="orders" class="cn.shelhon.action.OrdersAction" method="execute"&gt;&lt;result name="success"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt;&lt;/package&gt; 修改后代码12345678910&lt;package name="demo1" extends="struts-default" namespace="/"&gt; &lt;!-- 全局结果页面配置 --&gt; &lt;global-results&gt; &lt;result name="success"&gt;hello.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name="book" class="cn.shelhon.action.BookAction" method="execute"&gt; &lt;/action&gt; &lt;action name="orders" class="cn.shelhon.action.OrdersAction" method="execute"&gt; &lt;/action&gt;&lt;/package&gt; 但是要注意的是，这个全局变量是在package里面用的 局部结果页面 123&lt;action name="book" class="cn.shelhon.action.BookAction" method="execute"&gt;&lt;result name="success"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt; 如果同时配置了局部和全局结果页面，最后以局部变量为准 Result标签的type属性 result标签里面除了name属性之外，还有一个属性 type属性type属性：如何到路径里面（转发还是重定向） type属性值（1）默认值，做转发操作，值是 dispatcher就是说在浏览器上面的地址还是看到http://localhost:8080/struts2Day02/book.action但是实际内容是hello.jsp的内容（2）做重定向操作，值是 redirect输入http://localhost:8080/struts2Day02/book.action然后链接变成了http://localhost:8080/hello.jsp（3）上面两个值dispatcher、redirect，这两个值一般针对到页面中配置 配置到其他的action里面 chain：转发到action，一般不用，缓存问题输入http://localhost:8080/struts2Day02/book.action链接不变，但是实际内容已经是orders的内容 redirectAction：重定向到action比如输入http://localhost:8080/struts2Day02/book.action链接变成http://localhost:8080/orders.action Action获取表单提交数据 之前web阶段，提交表单到servlet里面，在servlet里面使用request对象里面的方法获取，getParameter，getParameterMap 提交表单到action，但是action没有request对象，不能直接使用request对象 action获取表单提交数据主要三种方式（1）使用ActionContext类（2）使用ServletActionContext类（3）使用接口注入方式(一般不用) 使用ActionContext类获取Map getParameters() : 返回一个包含所有HTTPSServletRequest参数信 因为这方法不是静态的方法，所以需要创建ActionContext类的对象 这个ActionContext不是new出来的 static ActionContext getContext() :获取当前线程的ActionContext对象 具体演示 （1）创建表单，提交表单到action里面 （2）在action使用ActionContext获取数据 12345678910111213141516public String execute() throws Exception &#123; // 第一种方式 使用ActionContext类获取 // 1获取Action Context ActionContext context =ActionContext.getContext(); //2 调用方法得到表单数据 // key是表单输入项的name属性值，value值是输入的值 Map&lt;String,Object&gt; map = context.getParameters(); Set&lt;String&gt; keys =map.keySet(); for (String key :keys)&#123; //根据key得到value //数据形式：因为输入项里面可能有复选的情况 Object[] obj = (Object[]) map.get(key); System.out.println(Arrays.toString(obj)); &#125; return NONE;&#125; 123&lt;package name="demo2" namespace="/" extends="struts-default"&gt; &lt;action name="form1" class="cn.shelhon.action.form.Form1Demo"&gt; &lt;/action&gt; 使用ServletActionContext类获取 调用类里面静态方法，得到request对象 12345678910public String execute() throws Exception &#123; //第一种方式，使用ServletActionContext类获取 //1使用ServletActionContext获取request对象 HttpServletRequest request = ServletActionContext.getRequest(); String username = request.getParameter("username"); String password = request.getParameter("password"); String address = request.getParameter("address"); System.out.println(username+password+address); return NONE;&#125; 使用接口注入（了解）1234567891011121314public class Form3Demo extends ActionSupport implements ServletRequestAware &#123; //使用接口方式private HttpServletRequest request;public void setServletRequest(HttpServletRequest request) &#123; this.request=request; &#125; public String execute() throws Exception &#123; String username = request.getParameter("username"); String password = request.getParameter("password"); String address = request.getParameter("address"); System.out.println(username+password+address); return NONE; &#125;&#125; 在action操作域对象12345678910//操作三个域 // 1 request域 HttpServletRequest request = ServletActionContext.getRequest();request.setAttribute("req","reqValue");//2 session域 HttpSession session = request.getSession();session.setAttribute("sess","sessValue");//3 ServletContext域 ServletContext context = ServletActionContext.getServletContext();context.setAttribute("contextname","contextValue");return NONE; Struts2封装获取表单数据方式原始方式获取表单封装到实体类对象123456789101112131415public String execute() throws Exception &#123; // 使用servletActionContext获取表单数据封装到实体类对象里面 // 1获取表单数据 HttpServletRequest request = ServletActionContext.getRequest(); String username = request.getParameter("username"); String password = request.getParameter("password"); String address = request.getParameter("address"); //2 把数据封装到实体类对象里面 User user = new User(); user.setUsername(username); user.setPassword(password); user.setAddress(address); System.out.println(user); return NONE;&#125; 123456789101112131415161718192021222324252627282930public class User &#123; private String username; private String password; private String address; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "username='" + username + '\'' + ", password='" + password + '\'' + ", address='" + address + '\'' + '&#125;'; &#125; 属性封装 实现过程（1）使用表达式封装可以把表单数据封装到实体类对象里面 第一步 在action里面声明实体类1&lt;action name="data1" class="cn.shelhon.data.DataDemo1Action"&gt; &lt;/action&gt; 第二步 生成实体类变量的set和get方法 12345678910111213141516171819202122232425262728293031public class DataDemo1Action extends ActionSupport &#123;//定义变量 //变量的名称和表单的name属性一样 private String username; private String password; private String address; // 生成变量的set和get方法 public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; System.out.println(username+" "+password+" "+address); this.password = password; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String execute() throws Exception &#123; return NONE; &#125;&#125; 模型驱动封装（重点） 使用模型驱动方式，可以直接把表单数据封装到实体类对象里面 实现步骤 （1）action实现接口 ModelDriven 1public class DataDemo2Action extends ActionSupport implements ModelDriven&lt;User&gt; &#123;&#125; （2）实现接口里面的方法 getModel方法 把创建对象返回 12345678910public class DataDemo2Action extends ActionSupport implements ModelDriven&lt;User&gt; &#123; public User getModel() &#123; return user; &#125; @Override public String execute() throws Exception &#123; return NONE; &#125;&#125; （3）在action里面创建实体类对象 123public User getModel() &#123; return user;&#125; 使用模型驱动和属性封装注意问题：在一个action中，获取表单数据可以属性封装，使用模型驱动封装，不能同时使用属性封装和模型驱动封装获取同一个表单数据。如果同时使用，执行模型驱动。 表达式封装（会用） 实现过程（1）使用表达式封装可以把表单数据封装到实体类对象里面第一步 在action里面声明实体类private User user;第二步 生成实体类变量的set和get方法 123456public User getUser() &#123; return user;&#125;public void setUser(User user) &#123; this.user = user;&#125; 第三步 在表单输入项的name属性值里面写表达式形式12345username:&lt;input type="text" name="user.username"/&gt;&lt;br/&gt;password:&lt;input type="text" name="user.password"/&gt;&lt;br/&gt;address:&lt;input type="text" name="user.address"/&gt; 比较表达式封装和模型驱动封装使用表达式封装和模型驱动封装都可以把数据封装到实体类对象里面不同点：（1）使用模型驱动只能把数据封装到一个实体类对象里面在一个action里面不能使用模型驱动把数据封装到不同的实体类对象里面（2）使用表达式封装可以把数据封装到不同的实体类对象里面 12345678910111213141516171819202122public class DataDemo3Action extends ActionSupport &#123; //声明实体类 private User user; private Book book; public Book getBook() &#123; return book; &#125; public void setBook(Book book) &#123; this.book = book; &#125; //生成实体类变量的set和get方法 public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public String execute() throws Exception &#123; System.out.println(user); System.out.println(book.getBname()); return NONE; &#125; 1234567891011&lt;form action="$&#123;pageContext.request.contextPath&#125;/data3.action" method="post"&gt; username:&lt;input type="text" name="user.username"/&gt; &lt;br/&gt; password:&lt;input type="text" name="user.password"/&gt; &lt;br/&gt; address:&lt;input type="text" name="user.address"/&gt; &lt;br/&gt; bname:&lt;input type="text" name="book.bname"/&gt; &lt;br/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; 封装到集合里面 封装数据到List集合 第一步 在action声明List1private List&lt;User&gt; list; 第二步 生成list变量的set和get方法 第三步 在表单输入项里面写表达式123456789101112131415&lt;form action="$&#123;pageContext.request.contextPath&#125;/list.action" method="post"&gt; username:&lt;input type="text" name="list[0].username"/&gt; &lt;br/&gt; password:&lt;input type="text" name="list[0].password"/&gt; &lt;br/&gt; address:&lt;input type="text" name="list[0].address"/&gt; &lt;br/&gt; &lt;br/&gt; username:&lt;input type="text" name="list[1].username"/&gt; &lt;br/&gt; password:&lt;input type="text" name="list[1].password"/&gt; &lt;br/&gt; address:&lt;input type="text" name="list[1].address"/&gt; &lt;br/&gt; &lt;input type="submit" value="提交"/&gt; 封装数据到Map集合 第一步 声明map集合private Map&lt;String,User&gt; map;第二步 生成get和set方法 123456public Map&lt;String,User&gt; getMap() &#123; return map;&#125;public void setMap(Map&lt;String,User&gt; map) &#123; this.map = map;&#125; 第三步 在表单输入项的name属性值里面写表达式123456789101112131415161718&lt;form action="$&#123;pageContext.request.contextPath&#125;/map.action" method="post"&gt; &lt;!-- 设置key的值 ['key值'] 设置value值 --&gt; username:&lt;input type="text" name="map['one'].username"/&gt; &lt;br/&gt; password:&lt;input type="text" name="map['one'].password"/&gt; &lt;br/&gt; address:&lt;input type="text" name="map['one'].address"/&gt; &lt;br/&gt; &lt;br/&gt; username:&lt;input type="text" name="map['two'].username"/&gt; &lt;br/&gt; password:&lt;input type="text" name="map['two'].password"/&gt; &lt;br/&gt; address:&lt;input type="text" name="map['two'].address"/&gt; &lt;br/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 框架学习(二)]]></title>
    <url>%2Fposts%2F14042445.html</url>
    <content type="text"><![CDATA[大概内容 基于aspectj的注解aop操作 spring的jdbcTemplate操作 spring配置连接池 spring事务管理 基于aspectj的注解aop操作 使用注解方式创建aop操作 第一步 ：创建对象123&lt;!-- 1 配置对象 --&gt; &lt;bean id="book" class="cn.shelhon.cn.shelhon.aop.Book"&gt; &lt;/bean&gt; &lt;bean id="myBook" class="cn.shelhon.cn.shelhon.aop.Book"&gt; &lt;/bean&gt; 第二步 ：在spring核心配置文件里面开启AOP操作 12&lt;!-- 开启aop操作 --&gt; &lt;aop:aspectj-autoproxy&gt; &lt;/aop:aspectj-autoproxy&gt; 第三步 ： 在增强类上面使用注解完成aop操作 123@Aspect public class Mybook &#123; //在方法上面使用注解完成增强配置 @Before(value = "execution(* cn.shelhon.aop.Book.*(..)") Spring的jdbcTemplate操作 实现crud操作 - 增加、修改、删除，调用模板update方法 - 查询某个值时候，调用queryForObject方法 - 自己写实现类封装数据 - 查询对象，调用queryForObject方法 - 查询list集合，调用query方法 spring框架一站式框架 针对javaee三层，每一层都有解决技术 在dao层，使用 jdbcTemplate spring对不同的持久化层技术都进行封装 其中jdbcTemplate对jdbc进行封装 jdbcTemplate使用和dbutils使用很相似，都数据库进行crud操作 增加 导入jdbcTemplate使用的jar包 创建对象，设置数据库信息 创建JdbcTemplate对象，设置数据源 调用jdbcTemplate对象里面的方法 操作的时候，记得还要导入驱动数据库的jar包 1234567891011121314151617181920212223// 添加操作 @Test public void add()&#123; //创建对象，设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("conm.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://test"); dataSource.setUsername("root"); dataSource.setPassword("12345"); // 创建JdbcTemplate对象，设置数据源 JdbcTemplate jdbcTempalate = new JdbcTemplate(dataSource); //调用jdbcTemplate对象里面的方法 String sql = "insert into user value(?,?)"; int rows = jdbcTempalate.update(sql,"lucy","22"); System.out.println(rows); &#125; 特别要注意的是，在运行的时候报错出现的问题 1org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: Unknown character set index for field &apos;255&apos; received from server. 这个问题是由于我使用的数据库版本比较新，导致旧的mysql-connector-java的版本使用的时候报错。 (1) MYSQL 5.5 之前， UTF8 编码只支持1-3个字节;从MYSQL5.5开始，可支持4个字节UTF编码utf8mb4;如emoji表情需要使用utf8mb4 (2) 如果服务器级使用的编码是utf8mb4(在客户端链接后使用sql语句show variables like ‘char%’可查看所有编码)，而mysql的jar包低版本不支持utf8mb4,连接时报错”Unknown character set index for field ‘224’ received from server.” (3) 建议使用mysql-connector-java-5.1.30-bin.jar (4) 注意：如果数据库不支持utf8mb4，使用mysql-connector-java-5.1.30-bin.jar的jar包时则会报错，此时应该使用低版本的jar包。 然后这个时候我又用了最新版本的mysql-connector的jar包又报错1java.lang.UnsupportedClassVersionError: com/mysql/jdbc/Driver : Unsupported major.minor version 52.0 这种问题是jdk版本和mysql数据库版本不兼容从网上寻找的答案有如下： 1、jdk7+老版5.0驱动com/mysql/jdbc/Driver 2、jdk8+新版6.0驱动com/mysql/cj/jdbc/Driver 所以就是最新的jar是不能跟jdk1.7搭配使用的。最后解决问题的是这样的搭配 jdk1.7.0_80 mysql-connector-java 5.1.46 spring-jdbc 4.2.4.RELEASE 更新更新的方法跟增加差不多。 1234//调用jdbcTemplate对象里面的方法 String sql = "update user set password=? where name=?"; int rows = jdbcTemplate.update(sql,"lucy","99"); System.out.println(rows); 删除删除也是同理1234//调用jdbcTemplate对象里面的方法 String sql = "delete from user where name=?"; int rows = jdbcTemplate.update(sql,"null"); System.out.println(rows); 查询1、查询表中有多少记录12345// 创建JdbcTemplate对象，设置数据源JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);String sql = "select count(*) from user";int count =jdbcTemplate.queryForObject(sql,Integer.class);System.out.println(count); &#125; 2、查询返回对象jdbc底层原理12345678910111213141516171819202122232425262728293031323334353637383940@Test public void testJDBC()&#123;Connection conn = null;PreparedStatement psmt =null;ResultSet rs = null;try &#123; Class.forName("com.mysql.jdbc.Driver");//创建连接conn = DriverManager.getConnection("jdbc:mysql:///test", "root", "12345");//编写sql语句String sql = "select * from user where name =?";//预编译sql语句psmt = conn.prepareStatement(sql);//设置参数值psmt.setString(1, "lucy");//遍历结果集rs =psmt.executeQuery(); while(rs.next())&#123; //得到返回值String username =rs.getString("name");String password = rs.getString("password"); //放到User对象里面User user =new User();user.setUsername(username);user.setPassword(password);System.out.println(user); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try&#123; rs.close();psmt.close();conn.close();; &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125; &#125;&#125; User.java代码 123456789101112131415161718192021222324252627282930package cn.shelhon.jdbc; public class User &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public String getPassword() &#123; return password; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User&#123;" + "username='" + username + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 具体的实现 1234567891011121314151617181920212223242526272829@Test public void testObject()&#123; //创建对象以及设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql:///test"); dataSource.setUsername("root"); dataSource.setPassword("12345"); // 创建JdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); //写sql语句，根据name来查询 String sql ="select * from user where name = ?"; //调用jdbctempla的方法实现 //第二个参数是接口ROWMapper，需要自己写个类,自己做数据封装 User user=jdbcTemplate.queryForObject(sql,new MyRowMapper(),"rose"); System.out.println(user); &#125;&#125;class MyRowMapper implements RowMapper&lt;User&gt;&#123; public User mapRow(ResultSet rs, int i) throws SQLException &#123; //从结果集里把数据拿到 String username = rs.getString("name"); String password = rs.getString("password"); //把得到的数据封装到对象里面 User user = new User(); user.setUsername(username); user.setPassword(password); return user; &#125;&#125; 3、查询返回list集合 1234567891011121314@Test public void testList()&#123; //创建对象以及设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql:///test"); dataSource.setUsername("root"); dataSource.setPassword("12345"); // 创建JdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); //写sql语句，根据name来查询 String sql ="select * from user"; //调用jdbctempla的方法实现 //第二个参数是接口ROWMapper，需要自己写个类,自己做数据封装List&lt;User&gt; list =jdbcTemplate.query(sql,new MyRowMapper()); System.out.println(list); &#125; Spring配置连接池配置c3p0连接池 导入jar包c3p0-0.9.2.1mchange-commons-java-0.2.3.4 创建spring文件，建立连接池 1234567&lt;!-- 配置c3p0连接池 --&gt; &lt;bean id ="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 注入属性值--&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt; &lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://test"&gt; &lt;/property&gt; &lt;property name="user" value="root"&gt; &lt;/property&gt; &lt;property name="password" value="12345"&gt; &lt;/property&gt; &lt;/bean&gt; dao使用jdbcTemplate 创建service和dao，配置service和dao对象，在service注入dao对象 1234&lt;bean id="userService" class="cn.shelhon.c3p0.UserService"&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id="userDao" class="cn.shelhon.c3p0.UserDao"&gt;&lt;/bean&gt; 创建jdbcTemplate对象，把模板对象注入到dao里面创建对象12345private JdbcTemplate jdbcTemplate; //添加操作public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; 注入dao里面123&lt;bean id="userDao" class="cn.shelhon.c3p0.UserDao"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt; &lt;/property&gt;&lt;/bean&gt; 在jdbcTemplate对象里面注入dataSource 1234&lt;!-- 创建JdbcTemplate对象 --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;!-- 把datasource传递到模板对象里面 --&gt; &lt;property name="dataSource" ref="dataSource"&gt; &lt;/property&gt; &lt;/bean&gt; 关于数据库语句因为我的表里用了主键，在插入新的数据的时候 12String sql ="insert into user values(?,?)"; jdbcTemplate.update(sql,"李峰","asd"); 按照这语法就报错了 后来改这样就通过了12String sql="insert into user(id,name,password) values(null,?,?)"; jdbcTemplate.update(sql,"李峰","asd"); Spring事务管理事务概念 什么是事务Spring事务 的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。 理解事务之前，先讲一个你日常生活中最常干的事：取钱。比如你去ATM机取1000块钱，大体有两个步骤：首先输入密码金额，银行卡扣掉1000元钱；然后ATM出1000元钱。这两个步骤必须是要么都执行要么都不执行。如果银行卡扣除了1000块但是ATM出钱失败的话，你将会损失1000元；如果银行卡扣钱失败但是ATM却出了1000块，那么银行将损失1000元。所以，如果一个步骤成功另一个步骤失败对双方都不是好事，如果不管哪一个步骤失败了以后，整个取钱过程都能回滚，也就是完全取消所有操作的话，这对双方都是极好的。事务就是用来解决类似问题的。事务是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。在企业级应用程序开发中，事务管理必不可少的技术，用来确保数据的完整性和一致性。 事务特性：四大特性(简称ACID) 原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 一致性（Consistency）：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 隔离性（Isolation）:隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 持久性（Durability）:持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 不考虑隔离性产生读问题 脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。 不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。 虚读(幻读)： 幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 解决读问题 设置隔离级别数据库隔离级别： ① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 ② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。 ③ Read committed (读已提交)：可避免脏读的发生。 ④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 spring进行事务管理apispring事务管理有两种方法 编程式事务管理（一般不用） 声明式事务管理： 基于xml配置文件实现 基于注解实现 spring事务管理的api介绍spring事务管理高层抽象主要包括3个接口 PlatformTransactionManager事务管理器 TransactionDefinition事务定义信息（隔离、传播、超时、只读） TransactionStatus事务具体运行状态 其中spring针对不同的dao层框架，提供不同的实现类比如： org.springframework.jdbc.datasource.DataSourceTransactionManager是使用springJDBC或者iBatis进行持久化数据时使用。 org.springframework.orm.hibernate5.HibernateTransactionManager使用Hiber5版本进行持久化数据时使用 搭建转账环境首先配置事务管理器 创建数据库的表，添加数据 创建service类和dao类，完成注入关系。 12345678910111213&lt;bean id="ordersService" class="cn.shelhon.service.OrdersService"&gt; &lt;property name="ordersDao" ref="ordersDao"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id="ordersDao" class="cn.shelhon.Dao.OrdersDao"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; service层又叫业务逻辑层 dao层，单独对数据库操作层，在dao层不添加业务 比较齐全的约束 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:context="http://www.springframework.org/schema/context"xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;&lt;/beans&gt; 需求甲 转账给 乙 1000甲 少 1000乙 多 1000 先在dao层写操作数据库的方法 12345678910111213141516public class OrdersDao &#123; //注入jdbcTemplate模板 private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; //提供对数据库操作的方法，不写业务操作 // 少钱的方法 public void lessMoney()&#123; String sql ="update account set salary=salary-? where name = ?"; jdbcTemplate.update(sql,1000,"甲"); &#125; // 加钱的方法 public void addMoney()&#123; String sql ="update account set salary=salary+? where name =?"; jdbcTemplate.update(sql,1000,"乙"); &#125;&#125; 然后再service层调用dao层写业务逻辑 123456789101112public class OrdersService &#123; private OrdersDao ordersDao; public void setOrdersDao(OrdersDao ordersDao) &#123; this.ordersDao = ordersDao; &#125; //调用dao的方法 //业务逻辑层，写转账业务 public void accountMoney()&#123; // 甲少1000 ordersDao.lessMoney();; // 乙多1000 ordersDao.addMoney(); &#125;&#125; 产生的问题 ： 如果甲扣钱了以后，出现异常，乙的钱并没有增加，钱丢失了 解决： -添加事务解决，出现异常进行回滚操作 spring进行事务配置（声明式）基于xml配置文件 配置文件使用aop思想 12345&lt;!-- 第一步配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入datasource --&gt; &lt;property name="dataSource" ref="dataSource"&gt; &lt;/property&gt; &lt;/bean&gt; 配置事务的增强 1234567&lt;!-- 第二步 配置事务增强 --&gt; &lt;tx:advice id ="txadvice" transaction-manager="transactionManager"&gt; &lt;!-- 做事务操作 --&gt; &lt;tx:attributes&gt; &lt;!-- 设置进行事务操作的方法匹配规则 --&gt; &lt;tx:method name="account*"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 配置切面 1234567&lt;!-- 第三步 --&gt; &lt;!-- 配置切面 --&gt; &lt;aop:config&gt; &lt;!-- 切入点 --&gt; &lt;aop:pointcut expression ="execution(* cn.shelhon.service.OrdersService.*(..))" id = "pointcut1"/&gt; &lt;!--切面--&gt; &lt;aop:advisor advice-ref="txadvice" pointcut-ref="pointcut1"/&gt; &lt;/aop:config&gt; 经过上面的配置以后，出现异常就能自动回滚操作 基于注解方式 第一步也是要先配置事务管理器 12345&lt;!-- 配置事务管理器 --&gt; &lt;bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt; &lt;/property&gt;&lt;/bean&gt; 配置事务注解 12&lt;!-- 开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager="dataSourceTransactionManager"/&gt; 要在使用事务的方法所在类上添加注解 12345678910111213141516@Transactional public class OrdersService &#123; private OrdersDao ordersDao; public void setOrdersDao(OrdersDao ordersDao) &#123; this.ordersDao = ordersDao; &#125; //调用dao的方法 //业务逻辑层，写转账业务 public void accountMoney()&#123; // 甲少1000 ordersDao.lessMoney();; //出现异常 // int i =10/0; // 乙多1000 ordersDao.addMoney(); &#125;&#125;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用IDEA遇到的问题记录]]></title>
    <url>%2Fposts%2Fada285ba.html</url>
    <content type="text"><![CDATA[人可以做他想做的，但不能要他想要的 记录在使用idea的过程中遇到的问题 比如 配置环境遇到的问题 导入jar包 依赖 maven Tomcat jdk和jar包版本的问题 将会比较随意的记录 post4 配置环境说到底原本最初是用idea，后来实习公司又要用eclipse，不怎么熟悉这个开发工具，本来就艰难，jdk就用一开始的1.8版本jdk，结果按照公司要求用回jdk1.7和Tomcat1.7的时候，eclipse就无法打开了。因为photon不支持1.8以下的版本。果断回头idea。 关于那个新建项目以后的文件目录格式，可以创建后自己修改。不用太纠结位置。 在创建项目以后，可以再创建模块，一个模块就相当于原来eclipse里面的项目。 在idea里面移除模块以后，不会删除本地硬盘里的文件，如果需要再导入这个模块进入项目里面的话，就找到 xxxx.iml文件，然后导入就会自动加载原来的那个模块了。 在运行的过程中，试过出现以下报错 1org.springframework.beans.factory.BeanDefinitionStoreException: IOException parsing XML document from class path resource [applicationContext.xml]; nested exception is java.io.FileNotFoundException: class path resource [applicationContext.xml] cannot be opened because it does not exist 最后是把applicationContext.xml放入resources文件夹里才成功。包括什么log4j.properties等这类型的文件都是要放进去才能生效。 导入jar包要注意框架的版本，因为不同版本，可能jar包就取消了，或者集合在一起了，这个必须得注意。 配置依赖大概就是maven添加的依赖，在配置到tomcat上的时候，没有关联到jar包，导致服务器 一直出错，如果碰到与maven和Tomcat相关的报错，可以考虑下面的解决方法。 IDEA: 遇到问题Error during artifact deployment. See server log for details.详细的报错是12严重: Exception starting filter struts2java.lang.ClassNotFoundException: prg.apache.struts2.dispatcher.FilterDispatcher 虽然不太懂原因，但是解决方法是打开项目结构，然后在Artifacts上面找到报错模块的地方，接着在output Layout找到WEB-INF文件夹，创建一个lib文件夹，然后右键文件夹添加副本，选择库文件，选择需要的jar包文件，问题就解决了。 maven在配置好系统环境变量以后在idea里的setting里设置maven的东西比如默认读取setting.xml的位置和仓库的位置因为idea自带的maven和我们自己安装位置的会不同 新建的时候就对着模块右键，选择添加框架支持 在里面找到maven然后直接新建就行。 创建pom.xml后好像会提示更新目录什么的，让idea来完成就好 默认的pom.xml里面需要我们自己去添加依赖，但是文件里会少了一些代码 &lt;dependencies&gt; #中间这里把maven依赖网站上面的配置自己找下来，复制上去就行 &lt;/dependencies&gt; 如果要移除依赖的话，直接删除pom.xml就可以了，同时idea会自动调整目录结构的 使用过程中，如果发现项目没有添加依赖，那么在项目结构中，找到这个项目的依赖，然后删除重新导入。 maven的依赖查询网站 ：http://mvnrepository.com/ 在idea右侧的工具栏里是可以找到maven插件的，通过这个可以很快查看每个项目的依赖。 Tomcat tomcat1.7版本不支持Servlet3.0以上的版本 然而idea创建web.xml的时候基本默认是4.0版本 Servlet 3.1 部署描述符Java EE 7 XML schema, namespace is http://xmlns.jcp.org/xml/ns/javaee/ 123456&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaeehttp://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"version="3.1"&gt;&lt;/web-app&gt; Servlet 3.0 部署描述符Java EE 6 XML schema, namespace is http://java.sun.com/xml/ns/javaee 123456&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://java.sun.com/xml/ns/javaeehttp://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"version="3.0"&gt;&lt;/web-app&gt; Servlet 2.5 部署描述符Java EE 5 XML schema, namespace is http://java.sun.com/xml/ns/javaee 123456&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://java.sun.com/xml/ns/javaeehttp://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"version="2.5"&gt;&lt;/web-app&gt; Servlet 2.4 部署描述符J2EE 1.4 XML schema, namespace is http://java.sun.com/xml/ns/j2ee 1234567&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://java.sun.com/xml/ns/j2eehttp://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"version="2.4"&gt; &lt;display-name&gt;Servlet 2.4 Web Application&lt;/display-name&gt;&lt;/web-app&gt; Servlet 2.3 部署描述符J2EE 1.3 DTDs schema. This web.xml file is too old, highly recommend you to upgrade it.123456&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Servlet 2.3 Web Application&lt;/display-name&gt;&lt;/web-app&gt; Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。 idea 快捷键alt+鼠标左键 可以查看源代码 CTRL+shift+i 可以小窗口查看源代码–再加上CTRL+enter可以打开窗口 CTRL+shift+t 可以打开try catch等语句 sout pvsm ctrl+alt+j 添加环绕 ctrl+j 自动代码提示 ctrl+y 删除行 ctrl+d 复制当前行 ctrl+shilf+12345..添加标签ctrl+1234…跳到标签 alt+鼠标选区可以实现批量修改，要对齐的代码才好用 ctrl+左右键 代码里块选择 alt+左右键，代码文件切换 alt+上下键，方法之间选择 ctrl+alt+enter空出所在行 关于module一个模块是一个独立的功能单元，可以被编译，运行，测试和调试独立module可以被分组module的dependencies的面板里的lib包顺序是依赖顺序，不能乱排序， 容易引起包冲突 使用svn的时候，一开始没下载插件，然后就自己下载装好svn插件以后，在设置里面的SVN不要修改配置，装好是怎样的就怎样，不要弄然后在菜单file里选择new，project form version control在里面输入连接地址，找到自己的开发文档，把代码弄下来就好，保存开发文档的文件夹需要为空，不然无法check out下来。日常使用的时候先更新，然后提交之前也先更新，免得有冲突]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>IDEA</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 框架学习]]></title>
    <url>%2Fposts%2F46958.html</url>
    <content type="text"><![CDATA[spring框架的介绍 &nbsp; Spring框架是一个轻量级的控制反转（IOC）和面向切面（AOP）的容器框架。 &nbsp; 记录了一些关于框架特点和特性以及Spring工作流程图。比如： IOC AOP的底层原理 属性注入 注解 bean管理 一、 一些基本特性 轻量：大小与开销轻量级，完整的spring框架可以在大小只有1MB多的JAR文件中发布，且spring框架是非侵入式的，spring应用不依赖于spring特定类。 控制反转：Spring通过一种称为控制反转的（IOC）的技术促进松耦合。当应用了IOC，一个对象依赖的其他对象通过被动的方式传递进来，而不是对象自己创建或者查找依赖对象。不是对象从容器中查找依赖，而是容器在对象初始化的不等对象请求就主动依赖传递过去.把对象的创建不是通过new方式，而是交给spring配置创建类对象。 面向切面：Spring提供面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发（AOP）。 容器：Spring包含并管理应用对象的配置和生命周期，可以配置每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以可以创建一个单独的实例，或每次需要都生成一个新的实例——以及他们是如何相互关联。 框架：Spring框架可以将简单的组件配置，组合成为复杂的应用。在Spring应用对象被声明组合，典型是在一个XML文件里面，Spring也提供许多基础功能（事务管理，持久化框架集成，自己开发应用逻辑） 二、 Spring流程图 解析：这个图在Struts结构图的基础上加了spring流程图，在web.xml配置文件中加入了spring监听器，在Struts配置文件中添加是告知Struts2运行的时候使用spring来创建对象，spring在其中要做就是注入实例，将所有需要类的实例都由spring管理。 三、 深入了解Spring是一站式框架spring在Javaee三层结构： 每一层都提供不同的解决技术。 web层：SpringMVC service层：Spring的IOC DAO层：Spring的jdbcTemplate 该笔记的学习是基于spring4.x版本 业精于勤 ，荒于嬉；行成于思，毁于随 spring的IOC操作把对象创建交给spring进行管理ioc操作两部分： （1）IOC的配置文件方式 （2）IOC的注解方式 IOC的底层原理 xml配置文件 dom4j解决xml 工厂设计模式 反射 1234567public class UserService&#123;&#125;public class UserServlet&#123; //得到UserServlet的对象 //原始：new创建 uersFactory.getService();&#125; 第一步 创建xml配置文件，配置要创建对象类 1&lt;bean id ="userService" class="cn.itcast.Userservice"/&gt; 第三步 创建工厂类，使用dom4j解析配置+反射123456789101112public class Userfacorty&#123; //返回UserService对象的方法&#125;public static UserService getService()&#123; //使用dom4j解析xml文件 //根据id值userService,得到id值对应class属性值 String class = "class属性值"; class clazz= class.forname(classValue); //创建类对象 Userservice service =clazz.newInstance(); return service;&#125; 在创建spring配置文件的时候注意，spring核心配置和位置不是固定的，建议放到src下面，官方建议的名称叫applicationContext.xml 配置的时候引入schema约束可以在docs文档 →spring-framenwork-reference →html里找最后一个configuration.xsd里有 IOC和DI的区别 IOC：控制反转，把对象创建交给spring进行配置 DI ：依赖注入，向类里面的属性中设置值 关系：依赖注入不能单独存在，需要在IOC的基础上完成操作的。 Spring的Bean管理（XML配置文件）Bean实例化的三种方式使用类的无参数构造创建12&lt;!-- ioc入门 --&gt;&lt;bean id ="user" class="cn.itcast.ioc.User"&gt;&lt;/bean&gt; 如果类里面没有无参数的构造，就会出现异常 使用静态工厂创建创建类的方法，返回类的对象123456public class Bean2Factory&#123; //静态方法，返回Bean2对象 public static Bean2 getBean2()&#123; return new Bean2(); &#125;&#125; 12&lt;!-- 使用静态工厂创建对象 --&gt;&lt;bean id="bean2" class="cn.itcast.bean.Bean2Factory" factory-method="getBean2"&gt; 使用实例工厂创建创建不是静态的方法，返回类对象 123456public class Bean3Factory&#123; //普通的方法。返回bean3对象 public Bean3 getBean3()&#123; return new Bean3(); &#125;&#125; Bean的常用标签id属性起名称，不能包含特殊符号根据id值得到配置对象 class属性创建对象所在类的全路径 name属性根据属性值得到配置对象但在name属性里可以包含特殊符号现在不怎么用，都是旧版本的遗留问题 scope属性 singleton：默认值，单例 prototype：多例 request：创建对象把对象放到request域里面(request的生命周期是一次访问，如果登陆信息放在request域的话，第二次访问就丢失了） session：创建对象把对象放到session域里面(session域的生命周期是默认30分钟，也叫一次会话，当浏览器访问的时候，就创建了session，当浏览器关闭了，或者超过30分钟了，session就会关闭。 globalSession：创建对象把对象放到globalSession里面 属性注入介绍创建对象的时候，向类里面属性设置值 属性注入的三种方式 使用set方法123456public class User&#123; private String name; public void setName(String name)&#123; this.name = name; &#125;&#125; 12User user =new User();user.setName("abcd"); 使用有参数的结构注入123456public class User&#123; private String name; public User(String name)&#123; this.name = name; &#125;&#125; 1User user =new User("lucy"); 使用接口注入123public interface Dao&#123; public void delete(String name);&#125; 123456public class DaoImpl implements Dao&#123; private String name; public void delete (String name)&#123; this.name = name; &#125;&#125; 注意的地方在spring框架里面，支持前两种方式 set方法注入（重点） 有参数结构注入 使用有参数构造注入属性 1234&lt;!-- 使用有参数构造注入属性 --&gt;&lt;bean id =&quot;demo&quot; class =&quot;cn.itcast.property.PropertyDemo1&quot;&gt;&lt;!-- 使用有参数构造注入 --&gt;&lt;constructor-arg name=&quot;username&quot; value =&quot;tom&quot;&gt;&lt;/constructor-arg&gt; 1234567private String name ;public PropertyDemo1(String user name)&#123; this.username =username;&#125;public void test1&#123; System.out.println("demo1----"+username);&#125; 使用set方法注入属性（重点）12345private String bookname;//set 方法public void setBookname(String bookname)&#123; this.bookname =bookname;&#125; 1234567&lt;!-- 使用set方法注入属性 --&gt;&lt;bean id =&quot;book&quot; class =&quot;cn.itcast.property.Book&quot;&gt; &lt;!-- 注入属性 name属性值，类里面定义的属性名称 value属性：设置属性的值 --&gt; &lt;property name =&quot;bookname&quot; value =&quot;hamlet&quot;&gt;&lt;/property&gt; 注入 对象类型 属性（重点）创建service类和dao类 在service得到dao对象 具体的实现过程 在service 里面把dao作为类型属性 生成dao类型属性的set方法 12345678public class UserService&#123; //1定义dao类型属性 private UserDao userDao; //2生成set方法 public void setUserDao(UserDao userDao)&#123; this.userDao =userDao; &#125;&#125; 配置文件中注入关系 123456789&lt;!-- 1配置service和dao对象 --&gt;&lt;bean id = "userDao" class ="cn.itcast.ioc.UserDao"&gt;&lt;/bean&gt;&lt;bean id= "userService" class ="cn.itcast.ioc.Userservice"&gt;&lt;!-- 注入dao对象name属性值：service类里面属性名称但是现在不要写value属性，因为之前的是字符串，现在是对象 。写ref属性：dao配置中的bena标签的id值--&gt;&lt;property name ="userDao" ref ="userDao"&gt;&lt;/property&gt; P名称空间注入修改配置文件，加入下面这一条 1xmls : p =&quot;http://www.spring.framework.org/schema/p&quot; 然后再加入这条 12&lt;!-- P名称空间注入 --&gt;&lt;bean id ="person" class= "cn.itcast.property.Person" p :name="Lucy"&gt; 注入复杂类型属性 数组 list集合 map集合 properties类型 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- 注入复杂类型属性 --&gt;&lt;bean id = "person" class ="cn.itcast.property.Person"&gt;&lt;!-- 数组 --&gt;&lt;property name="arrs"&gt; &lt;list&gt; &lt;value&gt;小王&lt;/value&gt; &lt;value&gt;小马&lt;/value&gt; &lt;value&gt;小宋&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!-- list --&gt;&lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;小奥&lt;/value&gt; &lt;value&gt;小金&lt;/value&gt; &lt;value&gt;小普&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!-- map --&gt;&lt;property name="map"&gt; &lt;map&gt; &lt;entry key="aa" value=_lucy"&gt;&lt;/entry&gt; &lt;entry key="bb" value="mary"&gt;&lt;/entry&gt; &lt;entry key="cc" value="tom"&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/property&gt;&lt;!-- properties --&gt;&lt;property name="properties"&gt; &lt;props&gt; &lt;prop key="driverclass"&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key="username"&gt;root&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;/bean&gt; Spring的bean管理（注释）关于注解 代码里特殊的标记，使用注解可以完成功能 注解写法 @ 注解名称（属性名称=属性值） 注解使用在类、方法属性上面 注解开发准备 导入的基本包 导入jar包的时候要多一个sop的包 创建类、创建对象 在创建Spring配置文件，引入约束（1）做ioc基本功能，引入约束beans（2）做Spring的IOC注解发开，引入新的约束 开启注解扫描 注解创建对象 @Component：组件（作用在类上） 三个衍生注解 @ Controller：web层 @Service：业务层 @Repository :持久层目前这个四个功能差不多，只是为了区分用途，都是创建对象 创建是单实例还是多实例 @ scope（value=“prototype”） 注解注入属性第一个注解 @Autowired 创建service类，创建dao类 123@Service (value="userService") public class Userservice &#123;&#125; 12345678@Component (value="userDao") //注解里的value可以不写//写成Component("userService")也是可以的public class UserDao &#123; public void add() &#123; System.out.println("Dao----") &#125;&#125; 在service里面定义dao类型属性 123@Autowired private UserDao userDao; //使用注解的方法不需要set方法 注入属性第二个注解 @Resource123//name的属性值写注解创建dao对象，也就是写value值 @Resource(name="userDao") private UserDao userDao; Autowired和Resource的区别 @Resource默认按照名称方式进行bean匹配，@Autowired默认按照类型方式进行bean匹配,就是Autowired去匹配的时候是找类，不是名称，而Resource是按照名称来寻找。 Spring属于第三方的，J2EE是Java自己的东西。使用@Resource可以减少代码和Spring之间的耦合。 两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。 @Resource装配顺序：①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。 ②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。 ③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。 ④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。 配置文件和注解混合使用 在创建对象操作使用配置文件方式实现 1234&lt;!-- 配置对象 --&gt;&lt;bean id ="bookService" class="cn.itcast.xmlanno.BookService"&gt;&lt;/bean&gt;&lt;bean id ="ordersDao" class= "cn.itcast.xmlanno.OrdersDao"&gt;&lt;/bean&gt;&lt;bean id ="bookDao" class ="cn.itcast.xmlanno.BookDao"&gt;&lt;/bean&gt; 注入属性的操作使用注解方式实现 12345//得到bookdao和ordersdao的对象@Resource(name="bookDao")private BookDao bookDao; @Resource(name="ordersDao")private OrdersDao ordersDao; AOPAOP概念 aop：面向切面（方面）编程，扩展功能不修改源代码实现 AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码 AOP原理下图是最原始方法和纵向抽取机制解决方法 AOP：横向抽取机制底层使用动态代理方式实现看下图 AOP操作术语 Joinpoint(连接点):类里面可以被增强的方法，这些方法称为连接点 Pointcut(切入点):所谓切入点是指我们要对哪些Joinpoint进行拦截的定义. Advice(通知/增强):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) Aspect(切面):是切入点和通知（引介）的结合 Introduction(引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field. Target(目标对象):代理的目标对象(要增强的类) Weaving(织入):是把增强应用到目标的过程.把advice 应用到 target的过程 Proxy（代理）:一个类被AOP织入增强后，就产生一个结果代理类 AOP操作 在Spring里面进行AOP操作，使用aspectj实现 aspectj不是spring一部分，和spring一起使用进行aop操作 Spring2.0以后新增了对AspectJ支持 使用aspectj实现aop有两种方式 基于aspectj的xml配置 基于aspectj的注解方式 AOP操作准备（包含引入约束） 除了最基本的jar包，还需要导入跟AOP相关的jar包 spring-aop-4.2.2.RELEASE.jar spring-aspects-4.2.2.RELEASE.jar后两个是要另外下载，不在spring包里面 aspectjweaver-1.8.7.jar aopalliance-1.0.jar 创建spring核心配置文件，导入aop的约束 在docs文档里面查找AOP的约束 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- bean definitions here --&gt; &lt;/beans&gt; 使用表达式配置切入点 切入点：实际增强的方法 常用的表达式execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;) execution(* cn.itcast.aop.Book.add(..))匹配cn.itcast.aop.Book.add的方法，参数用..表示 execution( cn.itcast.aop.Book.(..))匹配所有cn.itcast.aop.Book.*中的方法 execution( .*(..))匹配所有类中的所有方法 匹配所有save开头的方法 execution( save(..)) AOP配置1234567891011121314151617181920&lt;!-- 配置对象 --&gt;&lt;bean id ="book" class = "cn.itcast.aop.Book" &gt;&lt;/bean&gt;&lt;bean id ="myBook" class ="cn.itcast.aop.MyBook"&gt;&lt;/bean&gt;&lt;!-- 2配置AOP操作 --&gt; &lt;aop:config&gt; &lt;!-- 2.1配置切入点 --&gt; &lt;aop:pointcut expression="execution(* cn.itcast.aop.Book.add(..))" id="pointcut1"/&gt; &lt;!-- 注意在表达式前面第一个修饰符 * 号的后面要加空格 id值可以随便写，相当于起名字 --&gt; &lt;!-- 2.2配置切面,把增强用到方法上面 --&gt; &lt;aop:aspect ref="myBook"&gt; &lt;!-- 配置增强类型 method:增强类里面选择哪个方法做前置 --&gt; &lt;aop:before method="before1" pointcut-ref="pointcut1"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 加入其他配置12public void around() &#123; System.out.println("环绕增强"); 12345&lt;aop:aspect ref="myBook"&gt; &lt;!-- 配置增强类型 method:增强类里面选择哪个方法做环绕 --&gt; &lt;aop:around method="around" pointcut-ref="pointcut1"/&gt; &lt;/aop:aspect&gt; 输出结果 ： 环绕增强 这种方法应该是属于替换了原来的方法，但是如果修改了around的参数的话，效果很不同，就真的是环绕如下12345public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println("环绕增强之前"); proceedingJoinPoint.proceed(); System.out.println("之后");&#125; 然后配置文件不变输出结果： 环绕增强之前 add---------Book.java 之后 log4jlog4j介绍 通过log4j可以看到程序运行过程中更详细的信息 经常使用log4j查看日志 使用方法 导入log4j的jar包 复制log4j的配置文件，复制到src下面配置文件：log4j.properties 其中log4j.properties的内容中 log4j.rootLogger=info, stdout 是代表了日志级别 设置日志级别 info：看到基本信息 debug：看到更详细信息 Spring整合web项目原理基础原理加载Spring核心配置文件 new对象，功能可以实现，但是效率很低 实现思想：把加载配置文件和创建对象过程，在服务器启动时完成 实现原理 serlvletContext 对象 监听器 具体使用（1）在服务器启动时，为每一个项目创建一个servletContext对象（2）在servletContext 对象创建时，可以用监听器具体到servletContext对象在什么时候创建。（3）当使用监听器听到servletContext对象创建的时候，加载spring配置文件，创建配置对象。（4）把创建出来的对象放到ServletContext域对象里面（setAttribute方法）（5）获取对象时候，到ServletContext域得到 （getAttribute方法） web项目演示 演示问题 action 调用service，service调用dao 每次访问action的时候，都会加载spring配置文件功能没问题，可是性能不行123456信息: Deployment of web application directory C:\Program Files\Java\apache-tomcat-7.0.90\webapps\manager has finished in 90 msaction..........21:09:55,491 INFO ClassPathXmlApplicationContext:578 - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@4a3ef897: startup date [Wed Jul 25 21:09:55 CST 2018]; root of context hierarchy21:09:55,492 INFO XmlBeanDefinitionReader:317 - Loading XML bean definitions from class path resource [applicationContext.xml]service..........dao.......... 解决方案 在服务器启动的时候，创建对象加载配置文件 底层使用监听器，servletContext对象 spring里面不需要我们自己写代码，已经封装好了，这就是使用框架的好处 封装了一个监听器，只需要配置监听器就可以了 配置监听器之前，导入spring整合web项目jar包spring-web-4.2.4.RELEASE.jar 12&lt;!-- 配置监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 指定加载spring配置文件，因为默认是找不到位置的。 123&lt;!-- 指定spring配置文件位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立自己的博客]]></title>
    <url>%2Fposts%2F43831.html</url>
    <content type="text"><![CDATA[前言&nbsp; 苦于一直没有一个良好的学习习惯，感觉自己进步的效率太低，用IPad Pro加apple pen来手写也不行，字丑写的慢，即使记下来了也丑的不想回头看了。一天看到同学用 markdown来做笔记，美观而且很有条例，就想着学习着来搭一个博客来做笔记。GitHub上面可以提供代码托管，可以把自己的网站托管到GitHub上面，这样自己的学习成果就能在上面记录下来了。希望这种学习方法能对自己有所帮助。 一、初步准备1.github账户2 .电脑安装node.js、npmnode.js的下载网站一路默认吧 3 .安装了git for windowsgit的下载链接 基本一直next就行 二、搭建github博客1 .注册github账号2 .需要建立一个仓库注意的是仓库名字必须和账号名字一样，如果账号是admin，仓库名字也必须一样。 3 .在setting里面找到options按钮&nbsp; 看看Repository name名字是否改为账号名称，必须一摸一样，不然后面的步骤没法做。&nbsp; 然后往下拉，找到GitHub Pages里的Theme Chooser，随便选择一个主题先，这样就会出现我们的GitHub Pages的地址。 三、安装hexo1 .利用npm命令先桌面右键选择 Git Bash Here输入命令 npm install -g hexo 2 .初始化hexo先在自己想管理hexo博客框架的地方创建文件夹比如在D盘根目录下创建hexo文件夹在Git Bash里面输入命令 cd D:/hexo 然后再输入 hexo init 进行初始化 3 .修改配置文件找到_config.yml文件，然后打开修改里面的设置。并在最后面添加配置 deploy: type: git repo: https://github.com/Shelhon/Shelhon.github.io.git branch: master 其中repo里面的网址是自己的github上面的网址 4 .获取好看的主题在github上面比较高分好评的是next在Git Bash上面运行命令获取 git clone https://github.com/iissnan/hexo-theme-nextthemes/next 然后输入命令 hexo g hexo s 打开本地 localhost:4000 的页面，如果出现页面就成功。 5 .创建文章Git Bash在hexo目录下，输入 new post &quot;文章名称（最好英文）&quot; 就会在 source_posts\下出现 文章名称.md 文件 四、Github上面部署网站1. 安装hexo-deployer-git输入命令 npm install hexo-deployer-git --save 2. 发布到Github输入命令： hexo clean ps:如果修改了配置，打算在本地服务器运行试看的话，就建议每次修改后都clean一下，不然可能生效不了 然后再输入命令： hexo d -g 在第一次部署的时候，会出现下图的验证 这时候打开GitHub网站我们能看到仓库上已经更新了文件 3. 访问测试在浏览器输入：https://(github账户名字).github.io 能出现网页就算大功告成了。 至于如何绑定一个私人域名以及在过程中有些遇到的坑留以后再写一下。]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇]]></title>
    <url>%2Fposts%2F18842.html</url>
    <content type="text"><![CDATA[什么也不写先放一只猫镇楼 一些特殊符号 真包含：⊃或⫋真包含于：⊂包含：⊇包含于：⊆ 另外，还有⊄，⊄，⊈，⊉ 跟属于和不属于很像∈ 属于（如”A∈B”，即“A属于B”）∉ 不属于 ≡ 恒等于 ≠ 不等于 ≥ 大于等于 ≤ 小于等于 ≌ 全等 &gt;&gt;远远大于号 ∪ 集合的并运算 ⊕集合的对称差运算 〡 限制 ∑连加 连乘：∏ ∵ 因为 ∴ 所以 ∀ 全称量词 ∃ 存在量词 ﹁ 命题的“非”运算，如命题的否定为﹁p ∧ 命题的“合取”（“与”）运算 ∨ 命题的“析取”（“或”，“可兼或”）运算 → 命题的“条件”运算 ↔ 命题的“双条件”运算的 p&lt;=&gt;q 命题p与q的等价关系 p=&gt;__命题p与q的蕴涵关系（p是q的充分条件，q是p的必要条件 ∅ 空集 下划线 矩阵的画法简单Matrix 使用$$\begin{matrix}…\end{matrix}$$来生成矩阵，其中... 表示的是LaTeX 的矩阵命令，矩阵命令中每一行以 \\ 结束，矩阵的元素之间用&amp;来分隔开。 例如： 1234567$$ \begin&#123;matrix&#125; 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end&#123;matrix&#125; \tag&#123;1&#125;$$ 得到如下结果 $$\begin{matrix} 1 &amp; 2 &amp; 3 \4 &amp; 5 &amp; 6 \ 7 &amp; 8 &amp; 9\end{matrix} \tag{1}$$]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>心情随笔</tag>
      </tags>
  </entry>
</search>
