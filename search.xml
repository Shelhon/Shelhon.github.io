<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用IDEA遇到的问题记录]]></title>
    <url>%2Fposts%2Fada285ba.html</url>
    <content type="text"><![CDATA[人可以做他想做的，但不能要他想要的 记录在使用idea的过程中遇到的问题 比如 配置环境遇到的问题 导入jar包 依赖 maven Tomcat jdk和jar包版本的问题 将会比较随意的记录 配置环境说到底原本最初是用idea，后来实习公司又要用eclipse，不怎么熟悉这个开发工具，本来就艰难，jdk就用一开始的1.8版本jdk，结果按照公司要求用回jdk1.7和Tomcat1.7的时候，eclipse就无法打开了。因为photon不支持1.8以下的版本。果断回头idea。 关于那个新建项目以后的文件目录格式，可以创建后自己修改。不用太纠结位置。 导入jar包要注意框架的版本，因为不同版本，可能jar包就取消了，或者集合在一起了，这个必须得注意。 配置依赖以后补 maven还没弄 Tomcat tomcat1.7版本不支持xml3.0以上的版本 然而idea创建web.xml的时候基本默认是4.0版本 可以通过修改web.xml里面的版本数字来直接改变，改成3就行]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>踩坑</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 框架学习]]></title>
    <url>%2Fposts%2F46958.html</url>
    <content type="text"><![CDATA[spring框架的介绍&nbsp; Spring框架是一个轻量级的控制反转（IOC）和面向切面（AOP）的容器框架。 &nbsp; 记录了一些关于框架特点和特性以及Spring工作流程图。比如：IOC 、AOP的底层原理，属性注入，注解，bean管理 一、 一些基本特性 轻量：大小与开销轻量级，完整的spring框架可以在大小只有1MB多的JAR文件中发布，且spring框架是非侵入式的，spring应用不依赖于spring特定类。控制反转：Spring通过一种称为控制反转的（IOC）的技术促进松耦合。当应用了IOC，一个对象依赖的其他对象通过被动的方式传递进来，而不是对象自己创建或者查找依赖对象。不是对象从容器中查找依赖，而是容器在对象初始化的不等对象请求就主动依赖传递过去.把对象的创建不是通过new方式，而是交给spring配置创建类对象。面向切面：Spring提供面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发（AOP）。容器：Spring包含并管理应用对象的配置和生命周期，可以配置每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以可以创建一个单独的实例，或每次需要都生成一个新的实例——以及他们是如何相互关联。框架：Spring框架可以将简单的组件配置，组合成为复杂的应用。在Spring应用对象被声明组合，典型是在一个XML文件里面，Spring也提供许多基础功能（事务管理，持久化框架集成，自己开发应用逻辑） 二、 Spring流程图 解析：这个图在Struts结构图的基础上加了spring流程图，在web.xml配置文件中加入了spring监听器，在Struts配置文件中添加是告知Struts2运行的时候使用spring来创建对象，spring在其中要做就是注入实例，将所有需要类的实例都由spring管理。 三、 深入了解Spring是一站式框架spring在Javaee三层结构： 每一层都提供不同的解决技术。 web层：SpringMVC service层：Spring的IOC DAO层：Spring的jdbcTemplate 该笔记的学习是基于spring4.x版本 业精于勤 ，荒于嬉；行成于思，毁于随 spring的IOC操作把对象创建交给spring进行管理ioc操作两部分： （1）IOC的配置文件方式 （2）IOC的注解方式 IOC的底层原理 xml配置文件 dom4j解决xml 工厂设计模式 反射 1234567public class UserService&#123;&#125;public class UserServlet&#123; //得到UserServlet的对象 //原始：new创建 uersFactory.getService();&#125; 第一步 创建xml配置文件，配置要创建对象类 &lt;bean id =&quot;userService&quot; class=&quot;cn.itcast.Userservice&quot;/&gt; 第三步 创建工厂类，使用dom4j解析配置+反射123456789101112public class Userfacorty&#123; //返回UserService对象的方法&#125;public static UserService getService()&#123; //使用dom4j解析xml文件 //根据id值userService,得到id值对应class属性值 String class = "class属性值"; class clazz= class.forname(classValue); //创建类对象 Userservice service =clazz.newInstance(); return service;&#125; 在创建spring配置文件的时候注意，spring核心配置和位置不是固定的，建议放到src下面，官方建议的名称叫applicationContext.xml 配置的时候引入schema约束可以在docs文档 →spring-framenwork-reference →html里找最后一个configuration.xsd里有 IOC和DI的区别 IOC：控制反转，把对象创建交给spring进行配置 DI ：依赖注入，向类里面的属性中设置值 关系：依赖注入不能单独存在，需要在IOC的基础上完成操作的。 Spring的Bean管理（XML配置文件）Bean实例化的三种方式使用类的无参数构造创建12&lt;!-- ioc入门 --&gt; &lt;bean id =&quot;user&quot; class=&quot;cn.itcast.ioc.User&quot;&gt;&lt;/bean&gt; 如果类里面没有无参数的构造，就会出现异常 使用静态工厂创建创建类的方法，返回类的对象123456public class Bean2Factory&#123; //静态方法，返回Bean2对象 public static Bean2 getBean2()&#123; return new Bean2(); &#125;&#125; 12&lt;!-- 使用静态工厂创建对象 --&gt;&lt;bean id=&quot;bean2&quot; class=&quot;cn.itcast.bean.Bean2Factory&quot; factory-method=&quot;getBean2&quot;&gt; 使用实例工厂创建创建不是静态的方法，返回类对象 123456public class Bean3Factory&#123; //普通的方法。返回bean3对象 public Bean3 getBean3()&#123; return new Bean3(); &#125;&#125; Bean的常用标签id属性起名称，不能包含特殊符号根据id值得到配置对象 class属性创建对象所在类的全路径 name属性根据属性值得到配置对象但在name属性里可以包含特殊符号现在不怎么用，都是旧版本的遗留问题 scope属性 singleton：默认值，单例 prototype：多例 request：创建对象把对象放到request域里面 session：创建对象把对象放到session域里面 globalSession：创建对象把对象放到globalSession里面 属性注入介绍创建对象的时候，向类里面属性设置值属性注入的三种方式 使用set方法123456public class User&#123; private String name; public void setName(String name)&#123; this.name = name; &#125;&#125; 12User user =new User();user.setName("abcd"); 使用有参数的结构注入123456public class User&#123; private String name; public User(String name)&#123; this.name = name; &#125;&#125; 1User user =new User("lucy"); 使用接口注入123public interface Dao&#123; public void delete(String name);&#125; 123456public class DaoImpl implements Dao&#123; private String name; public void delete (String name)&#123; this.name = name; &#125;&#125; 注意的地方在spring框架里面，支持前两种方式 set方法注入（重点） 有参数结构注入 使用有参数构造注入属性 1234&lt;!-- 使用有参数构造注入属性 --&gt;&lt;bean id =&quot;demo&quot; class =&quot;cn.itcast.property.PropertyDemo1&quot;&gt;&lt;!-- 使用有参数构造注入 --&gt;&lt;constructor-arg name=&quot;username&quot; value =&quot;tom&quot;&gt;&lt;/constructor-arg&gt; 1234567private String name ;public PropertyDemo1(String user name)&#123; this.username =username;&#125;public void test1&#123; System.out.println("demo1----"+username);&#125; 使用set方法注入属性（重点）12345private String bookname;//set 方法public void setBookname(String bookname)&#123; this.bookname =bookname;&#125; 1234567&lt;!-- 使用set方法注入属性 --&gt;&lt;bean id =&quot;book&quot; class =&quot;cn.itcast.property.Book&quot;&gt; &lt;!-- 注入属性 name属性值，类里面定义的属性名称 value属性：设置属性的值 --&gt; &lt;property name =&quot;bookname&quot; value =&quot;hamlet&quot;&gt;&lt;/property&gt; 注入 对象类型 属性（重点）创建service类和dao类 在service得到dao对象 具体的实现过程 在service 里面把dao作为类型属性 生成dao类型属性的set方法 12345678public class UserService&#123; //1定义dao类型属性 private UserDao userDao; //2生成set方法 public void setUserDao(UserDao userDao)&#123; this.userDao =userDao; &#125;&#125; 配置文件中注入关系123456789&lt;!-- 1配置service和dao对象 --&gt;&lt;bean id = &quot;userDao&quot; class =&quot;cn.itcast.ioc.UserDao&quot;&gt;&lt;/bean&gt;&lt;bean id= &quot;userService&quot; class =&quot;cn.itcast.ioc.Userservice&quot;&gt;&lt;!-- 注入dao对象name属性值：service类里面属性名称但是现在不要写value属性，因为之前的是字符串，现在是对象 。写ref属性：dao配置中的bena标签的id值--&gt;&lt;property name =&quot;userDao&quot; ref =&quot;userDao&quot;&gt;&lt;/property&gt; P名称空间注入修改配置文件，加入下面这一条 xmls : p =&quot;http://www.spring.framework.org/schema/p&quot; 然后再加入这条 &lt;!-- P名称空间注入 --&gt; &lt;bean id =&quot;person&quot; class= &quot;cn.itcast.property.Person&quot; p :name=&quot;Lucy&quot;&gt; 注入复杂类型属性 数组 list集合 map集合 properties类型123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- 注入复杂类型属性 --&gt;&lt;bean id = &quot;person&quot; class =&quot;cn.itcast.property.Person&quot;&gt;&lt;!-- 数组 --&gt;&lt;property name=&quot;arrs&quot;&gt; &lt;list&gt; &lt;value&gt;小王&lt;/value&gt; &lt;value&gt;小马&lt;/value&gt; &lt;value&gt;小宋&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!-- list --&gt;&lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;小奥&lt;/value&gt; &lt;value&gt;小金&lt;/value&gt; &lt;value&gt;小普&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!-- map --&gt;&lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;aa&quot; value=_lucy&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;bb&quot; value=&quot;mary&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;cc&quot; value=&quot;tom&quot;&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/property&gt;&lt;!-- properties --&gt;&lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driverclass&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;/bean&gt; Spring的bean管理（注释）关于注解 代码里特殊的标记，使用注解可以完成功能 注解写法 @ 注解名称（属性名称=属性值） 注解使用在类、方法属性上面注解开发准备 导入的基本包 导入jar包的时候要多一个sop的包 创建类、创建对象 在创建Spring配置文件，引入约束（1）做ioc基本功能，引入约束beans（2）做Spring的IOC注解发开，引入新的约束 开启注解扫描 注解创建对象 @Component：组件（作用在类上） 三个衍生注解 @ Controller：web层 @Service：业务层 @Repository :持久层目前这个四个功能差不多，只是为了区分用途，都是创建对象 创建是单实例还是多实例 @ scope（value=“prototype”） 注解注入属性第一个注解 @Autowired 创建service类，创建dao类123@Service (value="userService") public class Userservice &#123;&#125; 12345678@Component (value="userDao") //注解里的value可以不写//写成Component("userService")也是可以的public class UserDao &#123; public void add() &#123; System.out.println("Dao----") &#125;&#125; 在service里面定义dao类型属性123@Autowired private UserDao userDao; //使用注解的方法不需要set方法 注入属性第二个注解 @Resource123//name的属性值写注解创建dao对象，也就是写value值 @Resource(name="userDao") private UserDao userDao; Autowired和Resource的区别 @Resource默认按照名称方式进行bean匹配，@Autowired默认按照类型方式进行bean匹配,就是Autowired去匹配的时候是找类，不是名称，而Resource是按照名称来寻找。 Spring属于第三方的，J2EE是Java自己的东西。使用@Resource可以减少代码和Spring之间的耦合。 两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。 @Resource装配顺序：①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。 ②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。 ③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。 ④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。 配置文件和注解混合使用 在创建对象操作使用配置文件方式实现 1234&lt;!-- 配置对象 --&gt;&lt;bean id =&quot;bookService&quot; class=&quot;cn.itcast.xmlanno.BookService&quot;&gt;&lt;/bean&gt;&lt;bean id =&quot;ordersDao&quot; class= &quot;cn.itcast.xmlanno.OrdersDao&quot;&gt;&lt;/bean&gt;&lt;bean id =&quot;bookDao&quot; class =&quot;cn.itcast.xmlanno.BookDao&quot;&gt;&lt;/bean&gt; 注入属性的操作使用注解方式实现 12345//得到bookdao和ordersdao的对象@Resource(name="bookDao")private BookDao bookDao; @Resource(name="ordersDao")private OrdersDao ordersDao; AOPAOP概念 aop：面向切面（方面）编程，扩展功能不修改源代码实现 AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码 AOP原理下图是最原始方法和纵向抽取机制解决方法 AOP：横向抽取机制底层使用动态代理方式实现看下图 AOP操作术语 Joinpoint(连接点):类里面可以被增强的方法，这些方法称为连接点 Pointcut(切入点):所谓切入点是指我们要对哪些Joinpoint进行拦截的定义. Advice(通知/增强):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) Aspect(切面):是切入点和通知（引介）的结合 Introduction(引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field. Target(目标对象):代理的目标对象(要增强的类) Weaving(织入):是把增强应用到目标的过程.把advice 应用到 target的过程 Proxy（代理）:一个类被AOP织入增强后，就产生一个结果代理类 AOP操作 在Spring里面进行AOP操作，使用aspectj实现 aspectj不是spring一部分，和spring一起使用进行aop操作 Spring2.0以后新增了对AspectJ支持 使用aspectj实现aop有两种方式 基于aspectj的xml配置 基于aspectj的注解方式 AOP操作准备 除了最基本的jar包，还需要导入跟AOP相关的jar包 spring-aop-4.2.2.RELEASE.jar spring-aspects-4.2.2.RELEASE.jar后两个是要另外下载，不在spring包里面 aspectjweaver-1.8.7.jar aopalliance-1.0.jar 创建spring核心配置文件，导入aop的约束 在docs文档里面查找AOP的约束 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- bean definitions here --&gt; &lt;/beans&gt; 使用表达式配置切入点 切入点：实际增强的方法 常用的表达式execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;) execution(* cn.itcast.aop.Book.add(..))匹配cn.itcast.aop.Book.add的方法，参数用..表示 execution( cn.itcast.aop.Book.(..))匹配所有cn.itcast.aop.Book.*中的方法 execution( .*(..))匹配所有类中的所有方法 匹配所有save开头的方法 execution( save(..)) AOP配置1234567891011121314151617181920&lt;!-- 配置对象 --&gt;&lt;bean id =&quot;book&quot; class = &quot;cn.itcast.aop.Book&quot; &gt;&lt;/bean&gt;&lt;bean id =&quot;myBook&quot; class =&quot;cn.itcast.aop.MyBook&quot;&gt;&lt;/bean&gt;&lt;!-- 2配置AOP操作 --&gt; &lt;aop:config&gt; &lt;!-- 2.1配置切入点 --&gt; &lt;aop:pointcut expression=&quot;execution(* cn.itcast.aop.Book.add(..))&quot; id=&quot;pointcut1&quot;/&gt; &lt;!-- 注意在表达式前面第一个修饰符 * 号的后面要加空格 id值可以随便写，相当于起名字 --&gt; &lt;!-- 2.2配置切面,把增强用到方法上面 --&gt; &lt;aop:aspect ref=&quot;myBook&quot;&gt; &lt;!-- 配置增强类型 method:增强类里面选择哪个方法做前置 --&gt; &lt;aop:before method=&quot;before1&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 加入其他配置12public void around() &#123; System.out.println("环绕增强"); 12345&lt;aop:aspect ref=&quot;myBook&quot;&gt; &lt;!-- 配置增强类型 method:增强类里面选择哪个方法做环绕 --&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:aspect&gt; 输出结果 ： 环绕增强 这种方法应该是属于替换了原来的方法，但是如果修改了around的参数的话，效果很不同，就真的是环绕如下12345public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println("环绕增强之前"); proceedingJoinPoint.proceed(); System.out.println("之后");&#125; 然后配置文件不变输出结果： 环绕增强之前 add---------Book.java 之后 log4jlog4j介绍 通过log4j可以看到程序运行过程中更详细的信息 经常使用log4j查看日志 使用方法 导入log4j的jar包 复制log4j的配置文件，复制到src下面配置文件：log4j.properties 其中log4j.properties的内容中 log4j.rootLogger=info, stdout 是代表了日志级别 设置日志级别 info：看到基本信息 debug：看到更详细信息 Spring整合web项目原理基础原理加载Spring核心配置文件 new对象，功能可以实现，但是效率很低 实现思想：把加载配置文件和创建对象过程，在服务器启动时完成 实现原理 serlvletContext 对象 监听器 具体使用（1）在服务器启动时，为每一个项目创建一个servletContext对象（2）在servletContext 对象创建时，可以用监听器具体到servletContext对象在什么时候创建。（3）当使用监听器听到servletContext对象创建的时候，加载spring配置文件，创建配置对象。（4）把创建出来的对象放到ServletContext域对象里面（setAttribute方法）（5）获取对象时候，到ServletContext域得到 （getAttribute方法） web项目演示 演示问题 action 调用service，service调用dao 每次访问action的时候，都会加载spring配置文件功能没问题，可是性能不行123456信息: Deployment of web application directory C:\Program Files\Java\apache-tomcat-7.0.90\webapps\manager has finished in 90 msaction..........21:09:55,491 INFO ClassPathXmlApplicationContext:578 - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@4a3ef897: startup date [Wed Jul 25 21:09:55 CST 2018]; root of context hierarchy21:09:55,492 INFO XmlBeanDefinitionReader:317 - Loading XML bean definitions from class path resource [applicationContext.xml]service..........dao.......... 解决方案 在服务器启动的时候，创建对象加载配置文件 底层使用监听器，servletContext对象 spring里面不需要我们自己写代码，已经封装好了，这就是使用框架的好处 封装了一个监听器，只需要配置监听器就可以了 配置监听器之前，导入spring整合web项目jar包spring-web-4.2.4.RELEASE.jar 12&lt;!-- 配置监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 指定加载spring配置文件，因为默认是找不到位置的。 123&lt;!-- 指定spring配置文件位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立自己的博客]]></title>
    <url>%2Fposts%2F43831.html</url>
    <content type="text"><![CDATA[前言&nbsp; 苦于一直没有一个良好的学习习惯，感觉自己进步的效率太低，用IPad Pro加apple pen来手写也不行，字丑写的慢，即使记下来了也丑的不想回头看了。一天看到同学用 markdown来做笔记，美观而且很有条例，就想着学习着来搭一个博客来做笔记。GitHub上面可以提供代码托管，可以把自己的网站托管到GitHub上面，这样自己的学习成果就能在上面记录下来了。希望这种学习方法能对自己有所帮助。 一、初步准备1.github账户2 .电脑安装node.js、npmnode.js的下载网站一路默认吧 3 .安装了git for windowsgit的下载链接 基本一直next就行 二、搭建github博客1 .注册github账号2 .需要建立一个仓库注意的是仓库名字必须和账号名字一样，如果账号是admin，仓库名字也必须一样。 3 .在setting里面找到options按钮&nbsp; 看看Repository name名字是否改为账号名称，必须一摸一样，不然后面的步骤没法做。&nbsp; 然后往下拉，找到GitHub Pages里的Theme Chooser，随便选择一个主题先，这样就会出现我们的GitHub Pages的地址。 三、安装hexo1 .利用npm命令先桌面右键选择 Git Bash Here输入命令 npm install -g hexo 2 .初始化hexo先在自己想管理hexo博客框架的地方创建文件夹比如在D盘根目录下创建hexo文件夹在Git Bash里面输入命令 cd D:/hexo 然后再输入 hexo init 进行初始化 3 .修改配置文件找到_config.yml文件，然后打开修改里面的设置。并在最后面添加配置 deploy: type: git repo: https://github.com/Shelhon/Shelhon.github.io.git branch: master 其中repo里面的网址是自己的github上面的网址 4 .获取好看的主题在github上面比较高分好评的是next在Git Bash上面运行命令获取 git clone https://github.com/iissnan/hexo-theme-nextthemes/next 然后输入命令 hexo g hexo s 打开本地 localhost:4000 的页面，如果出现页面就成功。 5 .创建文章Git Bash在hexo目录下，输入 new post &quot;文章名称（最好英文）&quot; 就会在 source_posts\下出现 文章名称.md 文件 四、Github上面部署网站1. 安装hexo-deployer-git输入命令 npm install hexo-deployer-git --save 2. 发布到Github输入命令： hexo clean ps:如果修改了配置，打算在本地服务器运行试看的话，就建议每次修改后都clean一下，不然可能生效不了 然后再输入命令： hexo d -g 在第一次部署的时候，会出现下图的验证 这时候打开GitHub网站我们能看到仓库上已经更新了文件 3. 访问测试在浏览器输入：https://(github账户名字).github.io 能出现网页就算大功告成了。 至于如何绑定一个私人域名以及在过程中有些遇到的坑留以后再写一下。]]></content>
      <categories>
        <category>学习过程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇]]></title>
    <url>%2Fposts%2F18842.html</url>
    <content type="text"><![CDATA[什么也不写先放一只猫镇楼]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>心情随笔</tag>
      </tags>
  </entry>
</search>
